diff --git a/.DS_Store b/.DS_Store
new file mode 100644
index 0000000..e5b3874
Binary files /dev/null and b/.DS_Store differ
diff --git a/LGhost/.DS_Store b/LGhost/.DS_Store
new file mode 100644
index 0000000..5699dec
Binary files /dev/null and b/LGhost/.DS_Store differ
diff --git a/LGhost/LGhost.cpp b/LGhost/LGhost.cpp
index 179d353..70e837b 100644
--- a/LGhost/LGhost.cpp
+++ b/LGhost/LGhost.cpp
@@ -25,11 +25,13 @@
 
 using namespace std::literals;
 
-#ifdef LGHOST_X86
+#if defined (LGHOSTX86) || defined (__arm64)
 template<typename pixel_t> extern void filter_sse2(const VSFrameRef * src, VSFrameRef * dst, const LGhostData * const VS_RESTRICT d, const VSAPI * vsapi) noexcept;
+#if defined (LGHOSTX86)
 template<typename pixel_t> extern void filter_avx2(const VSFrameRef * src, VSFrameRef * dst, const LGhostData * const VS_RESTRICT d, const VSAPI * vsapi) noexcept;
 template<typename pixel_t> extern void filter_avx512(const VSFrameRef * src, VSFrameRef * dst, const LGhostData * const VS_RESTRICT d, const VSAPI * vsapi) noexcept;
 #endif
+#endif
 
 template<typename pixel_t>
 static void filter_c(const VSFrameRef * src, VSFrameRef * dst, const LGhostData * const VS_RESTRICT d, const VSAPI * vsapi) noexcept {
@@ -245,8 +247,18 @@ static void VS_CC lghostCreate(const VSMap * in, VSMap * out, void * userData, V
                     d->filter = filter_sse2<float>;
             }
 #endif
+#if defined (__arm64)
+            const int iset = instrset_detect();
+            if ((opt == 0 && iset >= 2) || opt == 2) {
+                if (d->vi->format->bytesPerSample == 1)
+                    d->filter = filter_sse2<uint8_t>;
+                else if (d->vi->format->bytesPerSample == 2)
+                    d->filter = filter_sse2<uint16_t>;
+                else
+                    d->filter = filter_sse2<float>;
+            }
         }
-
+#endif
         if (d->vi->format->sampleType == stInteger)
             d->peak = (1 << d->vi->format->bitsPerSample) - 1;
 
diff --git a/LGhost/LGhost.h b/LGhost/LGhost.h
index 2825a7d..16cb2d3 100644
--- a/LGhost/LGhost.h
+++ b/LGhost/LGhost.h
@@ -9,7 +9,7 @@
 #include <VapourSynth.h>
 #include <VSHelper.h>
 
-#ifdef LGHOST_X86
+#if defined(LGHOST_X86) || defined (__arm64)
 #include "VCL2/vectorclass.h"
 #endif
 
diff --git a/LGhost/LGhost_SSE2.cpp b/LGhost/LGhost_SSE2.cpp
index 0746ca9..17c3a0b 100644
--- a/LGhost/LGhost_SSE2.cpp
+++ b/LGhost/LGhost_SSE2.cpp
@@ -1,4 +1,4 @@
-#ifdef LGHOST_X86
+#if defined(LGHOST_X86) || defined (__arm64)
 #include "LGhost.h"
 
 template<typename pixel_t>
diff --git a/LGhost/VCL2/README.md b/LGhost/VCL2/README.md
new file mode 100644
index 0000000..d59b92f
--- /dev/null
+++ b/LGhost/VCL2/README.md
@@ -0,0 +1,14 @@
+# version2
+Vector Class Library, latest version
+
+This is a C++ class library for using the Single Instruction Multiple Data (SIMD) instructions to improve performance on modern microprocessors with the x86 or x86/64 instruction set on Windows, Linux, and Mac platforms. There are no plans to support ARM or other instruction sets.
+
+[Latest release](https://github.com/vectorclass/version2/releases)
+
+[Download manual](https://github.com/vectorclass/manual/raw/master/vcl_manual.pdf)
+
+[Add-on packages for particular applications](https://github.com/vectorclass/add-on)
+
+[Getting-started video.](https://www.youtube.com/watch?v=TKjYdLIMTrI) Video blogger Christopher Rose has made this nice video telling how to get started with the Vector Class Library.
+
+**Help:** You may ask for programming help on [StackOverflow](https://stackoverflow.com) using the tag vector-class-library.
diff --git a/LGhost/VCL2/instrset.h b/LGhost/VCL2/instrset.h
index 34e34b7..66b92ad 100644
--- a/LGhost/VCL2/instrset.h
+++ b/LGhost/VCL2/instrset.h
@@ -1,8 +1,8 @@
 /****************************  instrset.h   **********************************
 * Author:        Agner Fog
 * Date created:  2012-05-30
-* Last modified: 2020-06-08
-* Version:       2.01.03
+* Last modified: 2023-12-02
+* Version:       2.02.02
 * Project:       vector class library
 * Description:
 * Header file for various compiler-specific tasks as well as common
@@ -16,13 +16,56 @@
 *
 * For instructions, see vcl_manual.pdf
 *
-* (c) Copyright 2012-2020 Agner Fog.
+* (c) Copyright 2012-2023 Agner Fog.
 * Apache License version 2.0 or later.
 ******************************************************************************/
 
+/*
+ARM compatible include of the vectorclass
+
+on ARM/MAC the sse2neon lib will be imported
+and some parameters for the vectorclass are prepared.
+
+#IMPORTANT in vectorclass.h->instrset.h the cpuid function must be
+hidden, since it is not compatible with ARM-compilers.
+
+if missing, add the header-include check #if !defined(SSE2NEON_H)
+to the function to hide it when compiling on ARM
+
+remember that a dispatcher is not possible in this case.
+
+*/
+
+#if __arm64
+#include "sse2neon.h"
+
+// limit to 128byte, since we want to use ARM-neon
+#define MAX_VECTOR_SIZE 128
+
+//limit to sse4.2, sse2neon does not have any AVX instructions ( so far )
+#define INSTRSET 6
+
+//define unknown function
+#define _mm_getcsr() 1
+
+//simulate header included
+#define __X86INTRIN_H
+#endif
+// finally include vectorclass
+
 #ifndef INSTRSET_H
-#define INSTRSET_H 20102
+#define INSTRSET_H 20200
 
+// check if compiled for C++17
+#if defined(_MSVC_LANG)  // MS compiler has its own version of __cplusplus with different value
+#if _MSVC_LANG < 201703
+#error Please compile for C++17 or higher
+#endif
+#else  // all other compilers
+#if __cplusplus < 201703
+#error Please compile for C++17 or higher
+#endif
+#endif
 
 // Allow the use of floating point permute instructions on integer vectors.
 // Some CPU's have an extra latency of 1 or 2 clock cycles for this, but
@@ -47,11 +90,10 @@
 // 10: AVX512BW/DQ/VL
 // In the future, INSTRSET = 11 may include AVX512VBMI and AVX512VBMI2, but this
 // decision cannot be made before the market situation for CPUs with these
-// instruction sets is known (these future instruction set extensions are already
-// used in some VCL functions and tested with an emulator)
+// instruction sets is better known
 
 // Find instruction set from compiler macros if INSTRSET is not defined.
-// Note: Most of these macros are not defined in Microsoft compilers
+// Note: Some of these macros are not defined in Microsoft compilers
 #ifndef INSTRSET
 #if defined ( __AVX512VL__ ) && defined ( __AVX512BW__ ) && defined ( __AVX512DQ__ )
 #define INSTRSET 10
@@ -80,30 +122,6 @@
 #endif // instruction set defines
 #endif // INSTRSET
 
-// Include the appropriate header file for intrinsic functions
-#if INSTRSET > 7                       // AVX2 and later
-#if defined (__GNUC__) && ! defined (__INTEL_COMPILER)
-#include <x86intrin.h>                 // x86intrin.h includes header files for whatever instruction
-                                       // sets are specified on the compiler command line, such as:
-                                       // xopintrin.h, fma4intrin.h
-#else
-#include <immintrin.h>                 // MS/Intel version of immintrin.h covers AVX and later
-#endif // __GNUC__
-#elif INSTRSET == 7
-#include <immintrin.h>                 // AVX
-#elif INSTRSET == 6
-#include <nmmintrin.h>                 // SSE4.2
-#elif INSTRSET == 5
-#include <smmintrin.h>                 // SSE4.1
-#elif INSTRSET == 4
-#include <tmmintrin.h>                 // SSSE3
-#elif INSTRSET == 3
-#include <pmmintrin.h>                 // SSE3
-#elif INSTRSET == 2
-#include <emmintrin.h>                 // SSE2
-#elif INSTRSET == 1
-#include <xmmintrin.h>                 // SSE
-#endif // INSTRSET
 
 #if INSTRSET >= 8 && !defined(__FMA__)
 // Assume that all processors that have AVX2 also have FMA3
@@ -117,35 +135,18 @@
 #endif
 #endif
 
-// AMD  instruction sets
-#if defined (__XOP__) || defined (__FMA4__)
-#ifdef __GNUC__
-#include <x86intrin.h>                 // AMD XOP (Gnu)
-#else
-#include <ammintrin.h>                 // AMD XOP (Microsoft)
-#endif //  __GNUC__
-#elif defined (__SSE4A__)              // AMD SSE4A
-#include <ammintrin.h>
-#endif // __XOP__
-
-// FMA3 instruction set
-#if defined (__FMA__) && (defined(__GNUC__) || defined(__clang__))  && ! defined (__INTEL_COMPILER)
-#include <fmaintrin.h>
-#endif // __FMA__
-
-// FMA4 instruction set
-#if defined (__FMA4__) && (defined(__GNUC__) || defined(__clang__))
-#include <fma4intrin.h> // must have both x86intrin.h and fma4intrin.h, don't know why
-#endif // __FMA4__
-
+// Header files for non-vector intrinsic functions including _BitScanReverse(int), __cpuid(int[4],int), _xgetbv(int)
+#ifdef _MSC_VER                        // Microsoft compiler or compatible Intel compiler
+#include <intrin.h>
+#pragma warning(disable: 6323 4514 4710 4711) // Diasble annoying warnings
+#elif __x86_64__
+#include <x86intrin.h>                 // Gcc or Clang compiler
+#endif
 
 #include <stdint.h>                    // Define integer types with known size
+#include <limits.h>                    // Define INT_MAX
 #include <stdlib.h>                    // define abs(int)
 
-#ifdef _MSC_VER                        // Microsoft compiler or compatible Intel compiler
-#include <intrin.h>                    // define _BitScanReverse(int), __cpuid(int[4],int), _xgetbv(int)
-#endif // _MSC_VER
-
 
 // functions in instrset_detect.cpp:
 #ifdef VCL_NAMESPACE
@@ -158,13 +159,16 @@ namespace VCL_NAMESPACE {
     bool hasAVX512ER(void);            // true if AVX512ER instructions supported
     bool hasAVX512VBMI(void);          // true if AVX512VBMI instructions supported
     bool hasAVX512VBMI2(void);         // true if AVX512VBMI2 instructions supported
+    bool hasF16C(void);                // true if F16C instructions supported
+    bool hasAVX512FP16(void);          // true if AVX512_FP16 instructions supported
+
+    // function in physical_processors.cpp:
+    int physicalProcessors(int * logical_processors = 0);
+
 #ifdef VCL_NAMESPACE
 }
 #endif
 
-// functions in physical_processors.cpp:
-int physicalProcessors(int * logical_processors = 0);
-
 
 // GCC version
 #if defined(__GNUC__) && !defined (GCC_VERSION) && !defined (__clang__)
@@ -190,7 +194,7 @@ int physicalProcessors(int * logical_processors = 0);
 #endif
 
 // warning for poor support for AVX512F in MS compiler
-#ifndef __INTEL_COMPILER
+#if !defined(__INTEL_COMPILER) && !defined(__clang__)
 #if INSTRSET == 9
 #pragma message("Warning: MS compiler cannot generate code for AVX512F without AVX512DQ")
 #endif
@@ -200,12 +204,8 @@ int physicalProcessors(int * logical_processors = 0);
 #endif // __INTEL_COMPILER
 #endif // _MSC_VER
 
-/* Intel compiler problem:
-The Intel compiler currently cannot compile version 2.00 of VCL. It seems to have
-a problem with constexpr function returns not being constant enough.
-*/
-#if defined(__INTEL_COMPILER) && __INTEL_COMPILER < 9999
-#error The Intel compiler version 19.00 cannot compile VCL version 2. Use Version 1.xx of VCL instead
+#if defined(__INTEL_COMPILER) && __INTEL_COMPILER < 2021
+#error The Intel compiler version 19.00 cannot compile VCL version 2
 #endif
 
 /* Clang problem:
@@ -221,8 +221,9 @@ We need different version checks with and whithout __apple_build_version__
 #define FIX_CLANG_VECTOR_ALIAS_AMBIGUITY
 #endif
 
-#if defined (GCC_VERSION) && GCC_VERSION < 99999 && !defined(__clang__)
-#define ZEXT_MISSING  // Gcc 7.4.0 does not have _mm256_zextsi128_si256 and similar functions
+#if defined (__GNUC__) && __GNUC__ < 10 && !defined(__clang__)
+// Gcc 9 and earlier donot have _mm256_zextsi128_si256 and similar functions for xero-extending vector registers
+#define ZEXT_MISSING
 #endif
 
 
@@ -236,6 +237,7 @@ namespace VCL_NAMESPACE {
 constexpr int V_DC = -256;
 
 
+
 /*****************************************************************************
 *
 *    Helper functions that depend on instruction set, compiler, or platform
@@ -246,35 +248,44 @@ constexpr int V_DC = -256;
 // input:  functionnumber = leaf (eax), ecxleaf = subleaf(ecx)
 // output: output[0] = eax, output[1] = ebx, output[2] = ecx, output[3] = edx
 static inline void cpuid(int output[4], int functionnumber, int ecxleaf = 0) {
-#if defined(__GNUC__) || defined(__clang__)           // use inline assembly, Gnu/AT&T syntax
-    int a, b, c, d;
-    __asm("cpuid" : "=a"(a), "=b"(b), "=c"(c), "=d"(d) : "a"(functionnumber), "c"(ecxleaf) : );
-    output[0] = a;
-    output[1] = b;
-    output[2] = c;
-    output[3] = d;
-
-#elif defined (_MSC_VER)                              // Microsoft compiler, intrin.h included
-    __cpuidex(output, functionnumber, ecxleaf);       // intrinsic function for CPUID
-
-#else                                                 // unknown platform. try inline assembly with masm/intel syntax
-    __asm {
-        mov eax, functionnumber
-        mov ecx, ecxleaf
-        cpuid;
-        mov esi, output
-        mov[esi], eax
-        mov[esi + 4], ebx
-        mov[esi + 8], ecx
-        mov[esi + 12], edx
-    }
+#if defined(__x86_64__) || defined(_M_X64) || defined(__i386) || defined(_M_IX86)
+    // Original x86/x86_64 implementation
+    #if (defined(__GNUC__) || defined(__clang__)) && defined(__x86_64__)
+        int a, b, c, d;
+        __asm("cpuid" : "=a"(a), "=b"(b), "=c"(c), "=d"(d) : "a"(functionnumber), "c"(ecxleaf) : );
+        output[0] = a;
+        output[1] = b;
+        output[2] = c;
+        output[3] = d;
+    #elif defined (_MSC_VER)
+        __cpuidex(output, functionnumber, ecxleaf);
+    #else
+        __asm {
+            mov eax, functionnumber
+            mov ecx, ecxleaf
+            cpuid;
+            mov esi, output
+            mov[esi], eax
+            mov[esi + 4], ebx
+            mov[esi + 8], ecx
+            mov[esi + 12], edx
+        }
+    #endif
+#elif defined(__aarch64__) || defined(__arm__)
+    // Assume NEON support on ARM
+    output[0] = 1; // Indicating support for SSE
+    output[1] = 1; // Indicating support for SSE2
+    output[2] = 1; // Indicating support for SSE3
+    output[3] = 1; // Indicating support for SSSE3, SSE4.1, SSE4.2
+#else
+    #error Unsupported platform
 #endif
 }
 
 
 // Define popcount function. Gives sum of bits
 #if INSTRSET >= 6   // SSE4.2
-// popcnt instruction is not officially part of the SSE4.2 instruction set,
+// The popcnt instruction is not officially part of the SSE4.2 instruction set,
 // but available in all known processors with SSE4.2
 static inline uint32_t vml_popcnt(uint32_t a) {
     return (uint32_t)_mm_popcnt_u32(a);  // Intel intrinsic. Supported by gcc and clang
@@ -297,18 +308,19 @@ static inline uint32_t vml_popcnt(uint32_t a) {
     uint32_t e = d * 0x01010101;
     return   e >> 24;
 }
-
 static inline int32_t vml_popcnt(uint64_t a) {
-    return vml_popcnt(uint32_t(a >> 32)) + vml_popcnt(uint32_t(a));
+    return (int32_t)(vml_popcnt(uint32_t(a >> 32)) + vml_popcnt(uint32_t(a)));
 }
-
 #endif
 
 // Define bit-scan-forward function. Gives index to lowest set bit
-#if defined (__GNUC__) || defined(__clang__)
-    // gcc and Clang have no bit_scan_forward intrinsic
-#if defined(__clang__)   // fix clang bug
-    // Clang uses a k register as parameter a when inlined from horizontal_find_first
+#if (defined (__GNUC__) || defined(__clang__)) && !defined (_MSC_VER)
+// _BitScanForward intrinsics are defined only under Windows and only when _MSC_VER is defined
+
+// Use inline assembly for gcc and Clang
+#if defined(__clang_major__) && __clang_major__ < 10
+    // fix bug in Clang version 6. (not detected in version 8 and later)
+    // Clang version 6 uses a k register as parameter a when inlined from horizontal_find_first
 __attribute__((noinline))
 #endif
 static uint32_t bit_scan_forward(uint32_t a) {
@@ -322,8 +334,7 @@ static inline uint32_t bit_scan_forward(uint64_t a) {
     uint32_t hi = uint32_t(a >> 32);
     return bit_scan_forward(hi) + 32;
 }
-
-#else  // other compilers
+#else  // MS compatible compilers under Windows
 static inline uint32_t bit_scan_forward(uint32_t a) {
     unsigned long r;
     _BitScanForward(&r, a);            // defined in intrin.h for MS and Intel compilers
@@ -347,7 +358,11 @@ static inline uint32_t bit_scan_forward(uint64_t a) {
 
 
 // Define bit-scan-reverse function. Gives index to highest set bit = floor(log2(a))
-#if defined (__GNUC__) || defined(__clang__)
+#if (defined (__GNUC__) || defined(__clang__)) && !defined (_MSC_VER)
+// _BitScanReverse intrinsics are defined only under Windows and only when _MSC_VER is defined
+
+// Use inline assembly for gcc and Clang
+
 static inline uint32_t bit_scan_reverse(uint32_t a) __attribute__((pure));
 static inline uint32_t bit_scan_reverse(uint32_t a) {
     uint32_t r;
@@ -358,7 +373,7 @@ static inline uint32_t bit_scan_reverse(uint32_t a) {
 static inline uint32_t bit_scan_reverse(uint64_t a) {
     uint64_t r;
     __asm("bsrq %1, %0" : "=r"(r) : "r"(a) : );
-    return r;
+    return uint32_t(r);
 }
 #else   // 32 bit mode
 static inline uint32_t bit_scan_reverse(uint64_t a) {
@@ -367,16 +382,16 @@ static inline uint32_t bit_scan_reverse(uint64_t a) {
     else return bit_scan_reverse(uint32_t(ahi)) + 32;
 }
 #endif
-#else
+#else  // MS compatible compilers under Windows
 static inline uint32_t bit_scan_reverse(uint32_t a) {
     unsigned long r;
-    _BitScanReverse(&r, a);            // defined in intrin.h for MS and Intel compilers
+    _BitScanReverse(&r, a);            // defined in intrin.h for MS compatible compilers
     return r;
 }
 #ifdef __x86_64__
 static inline uint32_t bit_scan_reverse(uint64_t a) {
     unsigned long r;
-    _BitScanReverse64(&r, a);          // defined in intrin.h for MS and Intel compilers
+    _BitScanReverse64(&r, a);          // defined in intrin.h for MS compatible compilers
     return r;
 }
 #else   // 32 bit mode
@@ -386,7 +401,7 @@ static inline uint32_t bit_scan_reverse(uint64_t a) {
     else return bit_scan_reverse(uint32_t(ahi)) + 32;
 }
 #endif
-#endif
+#endif 
 
 // Same function, for compile-time constants
 constexpr int bit_scan_reverse_const(uint64_t const n) {
@@ -410,17 +425,22 @@ constexpr int bit_scan_reverse_const(uint64_t const n) {
 *
 *****************************************************************************/
 
-// Template class to represent compile-time integer constant
-template <int32_t  n> class Const_int_t {};      // represent compile-time signed integer constant
-template <uint32_t n> class Const_uint_t {};     // represent compile-time unsigned integer constant
-#define const_int(n)  (Const_int_t <n>())        // n must be compile-time integer constant
-#define const_uint(n) (Const_uint_t<n>())        // n must be compile-time unsigned integer constant
+#ifdef VCL_NAMESPACE
+#define NAMESPACEPREFIX VCL_NAMESPACE::
+#else 
+#define NAMESPACEPREFIX
+#endif
+
+template <int32_t  n> class Const_int_t {};                // represent compile-time signed integer constant
+template <uint32_t n> class Const_uint_t {};               // represent compile-time unsigned integer constant
+#define const_int(n)  (NAMESPACEPREFIX Const_int_t <n>())  // n must be compile-time integer constant
+#define const_uint(n) (NAMESPACEPREFIX Const_uint_t<n>())  // n must be compile-time unsigned integer constant
 
 
 // template for producing quiet NAN
 template <class VTYPE>
 static inline VTYPE nan_vec(uint32_t payload = 0x100) {
-    if constexpr ((VTYPE::elementtype() & 1) != 0) {  // double
+    if constexpr (VTYPE::elementtype() == 17) {  // double
         union {
             uint64_t q;
             double f;
@@ -429,13 +449,23 @@ static inline VTYPE nan_vec(uint32_t payload = 0x100) {
         ud.q = 0x7FF8000000000000 | uint64_t(payload) << 29;
         return VTYPE(ud.f);
     }
-    // float will be converted to double if necessary
-    union {
-        uint32_t i;
-        float f;
-    } uf;
-    uf.i = 0x7FC00000 | (payload & 0x003FFFFF);
-    return VTYPE(uf.f);
+    if constexpr (VTYPE::elementtype() == 16) {  // float
+        union {
+            uint32_t i;
+            float f;
+        } uf;
+        uf.i = 0x7FC00000 | (payload & 0x003FFFFF);
+        return VTYPE(uf.f);
+    }
+    /*  // defined in vectorfp16.h
+    if constexpr (VTYPE::elementtype() == 15) {  // _Float16
+        union {
+            uint16_t i;
+            _Float16 f;  // error if _Float16 not defined
+        } uf;
+        uf.i = 0x7C00 | (payload & 0x03FF);
+        return VTYPE(uf.f);
+    } */
 }
 
 
@@ -466,11 +496,10 @@ Rules for constexpr functions:
 
 > Do not make constexpr functions that return vector types. This requires type
   punning with a union, which is not allowed in constexpr functions under C++17.
-  It may be possible under C++20
 
 *****************************************************************************/
 
-// Define type for Encapsulated array to use as return type:
+// Define type for encapsulated array to use as return type:
 template <typename T, int N>
 struct EList {
     T a[N];
@@ -481,7 +510,7 @@ struct EList {
 // of vector class V with the value -1
 template <typename V>
 constexpr auto get_inttype() {
-    constexpr int elementsize = sizeof(V) / V::size();  // size of vector elements
+    constexpr int elementsize = int(sizeof(V) / V::size());  // size of vector elements
 
     if constexpr (elementsize >= 8) {
         return -int64_t(1);
@@ -609,7 +638,8 @@ const int perm_cross_lane       = 0x40;  // permutation crossing 128-bit lanes
 const int perm_same_pattern     = 0x80;  // same permute pattern in all 128-bit lanes
 const int perm_punpckh         = 0x100;  // permutation pattern fits punpckh instruction
 const int perm_punpckl         = 0x200;  // permutation pattern fits punpckl instruction
-const int perm_rotate          = 0x400;  // permutation pattern fits rotation within lanes. 4 bit count returned in bit perm_rot_count
+const int perm_rotate          = 0x400;  // permutation pattern fits 128-bit rotation within lanes. 4 bit byte count returned in bit perm_rot_count
+const int perm_swap            = 0x800;  // permutation pattern fits swap of adjacent vector elements
 const int perm_shright        = 0x1000;  // permutation pattern fits shift right within lanes. 4 bit count returned in bit perm_rot_count
 const int perm_shleft         = 0x2000;  // permutation pattern fits shift left within lanes. negative count returned in bit perm_rot_count
 const int perm_rotate_big     = 0x4000;  // permutation pattern fits rotation across lanes. 6 bit count returned in bit perm_rot_count
@@ -681,8 +711,8 @@ constexpr uint64_t perm_flags(int const (&a)[V::size()]) {
         }
         // check if same pattern in all lanes
         if (lane != 0 && ix >= 0) {                        // not first lane
-            int j1  = i - int(lane * lanesize);            // index into lanepattern
-            int jx = ix - int(lane * lanesize);            // pattern within lane
+            int j1 = int(i - int(lane * lanesize));        // index into lanepattern
+            int jx = int(ix - int(lane * lanesize));       // pattern within lane
             if (jx < 0 || jx >= (int)lanesize) r &= ~perm_same_pattern; // source is in another lane
             if (lanepattern[j1] < 0) {
                 lanepattern[j1] = jx;                      // pattern not known from previous lane
@@ -699,7 +729,7 @@ constexpr uint64_t perm_flags(int const (&a)[V::size()]) {
             // check if pattern fits compress (perm_compress)
             if (ix > compresslasti && ix - compresslasti >= (int)i - compresslastp) {
                 if ((int)i - compresslastp > 1) addz2 |= 2;// perm_compress may need additional zeroing
-                compresslasti = ix;  compresslastp = i;
+                compresslasti = ix;  compresslastp = int(i);
             }
             else {
                 patfail |= 2;                              // does not fit perm_compress
@@ -707,7 +737,7 @@ constexpr uint64_t perm_flags(int const (&a)[V::size()]) {
             // check if pattern fits expand (perm_expand)
             if (ix > expandlasti && ix - expandlasti <= (int)i - expandlastp) {
                 if (ix - expandlasti > 1) addz2 |= 4;      // perm_expand may need additional zeroing
-                expandlasti = ix;  expandlastp = i;
+                expandlasti = ix;  expandlastp = int(i);
             }
             else {
                 patfail |= 4;                              // does not fit perm_compress
@@ -744,7 +774,8 @@ constexpr uint64_t perm_flags(int const (&a)[V::size()]) {
 
     if (r & perm_same_pattern) {
         // same pattern in all lanes. check if it fits specific patterns
-        bool fit = true;
+        bool fit = true;                                   // fits perm_rotate
+        bool fitswap = true;                               // fits perm_swap
         // fit shift or rotate
         for (i = 0; i < lanesize; i++) {
             if (lanepattern[i] >= 0) {
@@ -755,9 +786,11 @@ constexpr uint64_t perm_flags(int const (&a)[V::size()]) {
                 else { // check if fit
                     if (rot != rot1) fit = false;
                 }
+                if ((uint32_t)lanepattern[i] != (i ^ 1)) fitswap = false;
             }
         }
-        rot &= lanesize-1;  // prevent out of range values
+        rot &= lanesize-1;                                 // prevent out of range values
+        if (fitswap) r |= perm_swap;
         if (fit) {   // fits rotate, and possibly shift
             uint64_t rot2 = (rot * elementsize) & 0xF;     // rotate right count in bytes
             r |= rot2 << perm_rot_count;                   // put shift/rotate count in output bit 16-19
@@ -802,17 +835,17 @@ constexpr uint64_t perm_flags(int const (&a)[V::size()]) {
         }
         if (fit) r |= perm_punpckl;
         // fit pshufd
-        if (elementsize >= 4) {
-            uint64_t p = 0;
+        if constexpr (elementsize >= 4) {
+            uint32_t p = 0;
             for (i = 0; i < lanesize; i++) {
-                if (lanesize == 4) {
+                if constexpr (lanesize == 4) {
                     p |= (lanepattern[i] & 3) << 2 * i;
                 }
                 else {  // lanesize = 2
                     p |= ((lanepattern[i] & 1) * 10 + 4) << 4 * i;
                 }
             }
-            r |= p << perm_ipattern;
+            r |= (uint64_t)p << perm_ipattern;
         }
     }
 #if INSTRSET >= 7
@@ -916,7 +949,7 @@ constexpr uint64_t perm16_flags(int const (&a)[V::size()]) {
         }
         else if (ix >= 0) {                                // not first lane
             uint32_t j = i - lane * lanesize;              // index into lanepattern
-            int jx = ix - lane * lanesize;                 // pattern within lane
+            int jx = int(ix - lane * lanesize);            // pattern within lane
             if (lanepattern[j] < 0) {
                 lanepattern[j] = jx;                       // pattern not known from previous lane
             }
@@ -964,7 +997,7 @@ constexpr auto pshufb_mask(int const (&A)[V::size()]) {
     // Parameter a is a reference to a constexpr array of permutation indexes
     // V is a vector class
     // oppos = 1 for data from the opposite 128-bit lane in 256-bit vectors
-    constexpr uint32_t N = V::size();                      // number of vector elements
+    constexpr uint32_t N = uint32_t(V::size());            // number of vector elements
     constexpr uint32_t elementsize = sizeof(V) / N;        // size of each vector element
     constexpr uint32_t nlanes = sizeof(V) / 16;            // number of 128 bit lanes in vector
     constexpr uint32_t elements_per_lane = N / nlanes;     // number of vector elements per lane
@@ -987,10 +1020,10 @@ constexpr auto pshufb_mask(int const (&A)[V::size()]) {
             }
             ix -= int(lane * elements_per_lane);           // index relative to lane
             if (ix >= 0 && ix < (int)elements_per_lane) {  // index points to desired lane
-                p = ix * elementsize;
+                p = int8_t(ix * elementsize);
             }
             for (j = 0; j < elementsize; j++) {            // loop through bytes in element
-                u.a[k++] = p < 0 ? -1 : p + j;             // store byte permutation index
+                u.a[k++] = int8_t(p < 0 ? -1 : p + j);     // store byte permutation index
             }
             m++;
         }
@@ -1076,12 +1109,12 @@ constexpr uint64_t blend_flags(int const (&a)[V::size()]) {
     uint32_t iu = 0;                                       // loop counter
     int32_t ii = 0;                                        // loop counter
     int ix = 0;                                            // index number i
-    const uint32_t nlanes = sizeof(V) / 16;                // number of 128-bit lanes
-    const uint32_t lanesize = N / nlanes;                  // elements per lane
+    constexpr uint32_t nlanes = sizeof(V) / 16;            // number of 128-bit lanes
+    constexpr uint32_t lanesize = N / nlanes;              // elements per lane
     uint32_t lane = 0;                                     // current lane
     uint32_t rot = 999;                                    // rotate left count
     int lanepattern[lanesize] = {0};                       // pattern in each lane
-    if (lanesize == 2 && N <= 8) {
+    if constexpr (lanesize == 2 && N <= 8) {
         r |= blend_shufab | blend_shufba;                  // check if it fits shufpd
     }
 
@@ -1127,7 +1160,7 @@ constexpr uint64_t blend_flags(int const (&a)[V::size()]) {
             if (lanei != lane) {
                 r |= blend_cross_lane;                     // crossing lane
             }
-            if (lanesize == 2) {   // check if it fits pshufd
+            if constexpr (lanesize == 2) {   // check if it fits pshufd
                 if (lanei != lane) r &= ~(blend_shufab | blend_shufba);
                 if ((((ix & N) != 0) ^ ii) & 1) r &= ~blend_shufab;
                 else r &= ~blend_shufba;
@@ -1167,7 +1200,7 @@ constexpr uint64_t blend_flags(int const (&a)[V::size()]) {
         for (iu = 0; iu < lanesize; iu++) {
             ix = lanepattern[iu];
             if (ix >= 0) {
-                uint32_t t = ix & ~N;
+                uint32_t t = uint32_t(ix & ~N);
                 if (ix & N) t += lanesize;
                 uint32_t tb = (t + 2*lanesize - iu) % (lanesize * 2);
                 if (rot == 999) {
@@ -1189,7 +1222,7 @@ constexpr uint64_t blend_flags(int const (&a)[V::size()]) {
             r |= uint64_t((rot & (lanesize - 1)) * elementsize) << blend_rotpattern;
         }
 #endif
-        if (lanesize == 4) {
+        if constexpr (lanesize == 4) {
             // check if it fits shufps
             r |= blend_shufab | blend_shufba;
             for (ii = 0; ii < 2; ii++) {
@@ -1215,12 +1248,12 @@ constexpr uint64_t blend_flags(int const (&a)[V::size()]) {
             }
         }
     }
-    else if  (nlanes > 1) {  // not same pattern in all lanes
+    else if constexpr (nlanes > 1) {  // not same pattern in all lanes
         rot = 999;                                         // check if it fits big rotate
         for (ii = 0; ii < N; ii++) {
             ix = a[ii];
             if (ix >= 0) {
-                uint32_t rot2 = (ix + 2 * N - ii) % (2 * N);// rotate count
+                uint32_t rot2 = uint32_t((ix + 2 * N - ii) % (2 * N));// rotate count
                 if (rot == 999) {
                     rot = rot2;                            // save rotate count
                 }
@@ -1256,7 +1289,7 @@ constexpr EList<int, 2*N> blend_perm_indexes(int const (&a)[N]) {
     for (j = 0; j < N; j++) {          // loop through indexes
         int ix = a[j];                 // current index
         if (ix < 0) {                  // zero or don't care
-            if (dozero == 2) {
+            if constexpr (dozero == 2) {
                 // list.a[j] = list.a[j + N] = ix;  // fails in gcc in complicated cases
                 list.a[j] = ix;
                 list.a[j + N] = ix;
diff --git a/LGhost/VCL2/instrset_detect.cpp b/LGhost/VCL2/instrset_detect.cpp
index 119661b..04c4425 100644
--- a/LGhost/VCL2/instrset_detect.cpp
+++ b/LGhost/VCL2/instrset_detect.cpp
@@ -1,13 +1,13 @@
 /**************************  instrset_detect.cpp   ****************************
 * Author:        Agner Fog
 * Date created:  2012-05-30
-* Last modified: 2019-08-01
-* Version:       2.00.00
+* Last modified: 2022-07-20
+* Version:       2.02.00
 * Project:       vector class library
 * Description:
 * Functions for checking which instruction sets are supported.
 *
-* (c) Copyright 2012-2019 Agner Fog.
+* (c) Copyright 2012-2022 Agner Fog.
 * Apache License version 2.0 or later.
 ******************************************************************************/
 
@@ -18,6 +18,7 @@ namespace VCL_NAMESPACE {
 #endif
 
 
+#ifdef __x86_64__
 // Define interface to xgetbv instruction
 static inline uint64_t xgetbv (int ctr) {
 #if (defined (_MSC_FULL_VER) && _MSC_FULL_VER >= 160040000) || (defined (__INTEL_COMPILER) && __INTEL_COMPILER >= 1200)
@@ -45,6 +46,7 @@ static inline uint64_t xgetbv (int ctr) {
 
 #endif
 }
+#endif
 
 /* find supported instruction set
     return value:
@@ -67,6 +69,11 @@ int instrset_detect(void) {
         return iset;                                       // called before
     }
     iset = 0;                                              // default value
+#if defined(__aarch64__) || defined(__arm__)
+    // Assume NEON support on ARM
+    iset = 6;  // Simulate support for SSE4.2 using NEON
+    return iset;
+#else
     int abcd[4] = {0,0,0,0};                               // cpuid results
     cpuid(abcd, 0);                                        // call cpuid function 0
     if (abcd[0] == 0) return iset;                         // no further cpuid function supported
@@ -103,9 +110,11 @@ int instrset_detect(void) {
     if ((abcd[1] & (1 << 31)) == 0) return iset;           // no AVX512VL
     if ((abcd[1] & 0x40020000) != 0x40020000) return iset; // no AVX512BW, AVX512DQ
     iset = 10;
+#endif
     return iset;
 }
 
+
 // detect if CPU supports the FMA3 instruction set
 bool hasFMA3(void) {
     if (instrset_detect() < 7) return false;               // must have AVX
@@ -130,14 +139,6 @@ bool hasXOP(void) {
     return ((abcd[2] & (1 << 11)) != 0);                   // ecx bit 11 indicates XOP
 }
 
-// detect if CPU supports the F16C instruction set
-bool hasF16C(void) {
-    if (instrset_detect() < 7) return false;               // must have AVX
-    int abcd[4];                                           // cpuid results
-    cpuid(abcd, 1);                                        // call cpuid function 1
-    return ((abcd[2] & (1 << 29)) != 0);                   // ecx bit 29 indicates F16C
-}
-
 // detect if CPU supports the AVX512ER instruction set
 bool hasAVX512ER(void) {
     if (instrset_detect() < 9) return false;               // must have AVX512F
@@ -162,6 +163,23 @@ bool hasAVX512VBMI2(void) {
     return ((abcd[2] & (1 << 6)) != 0);                    // ecx bit 6 indicates AVX512VBMI2
 }
 
+// detect if CPU supports the F16C instruction set
+bool hasF16C(void) {
+    if (instrset_detect() < 7) return false;               // must have AVX
+    int abcd[4];                                           // cpuid results
+    cpuid(abcd, 1);                                        // call cpuid function 1
+    return ((abcd[2] & (1 << 29)) != 0);                   // ecx bit 29 indicates F16C
+}
+
+// detect if CPU supports the AVX512_FP16 instruction set
+bool hasAVX512FP16(void) {
+    if (instrset_detect() < 10) return false;              // must have AVX512
+    int abcd[4];                                           // cpuid results
+    cpuid(abcd, 7);                                        // call cpuid function 1
+    return ((abcd[3] & (1 << 23)) != 0);                   // edx bit 23 indicates AVX512_FP16
+}
+
+
 #ifdef VCL_NAMESPACE
 }
 #endif
diff --git a/LGhost/VCL2/sse2neon.h b/LGhost/VCL2/sse2neon.h
new file mode 100644
index 0000000..a3ba954
--- /dev/null
+++ b/LGhost/VCL2/sse2neon.h
@@ -0,0 +1,9429 @@
+#ifndef SSE2NEON_H
+#define SSE2NEON_H
+
+/*
+ * sse2neon is freely redistributable under the MIT License.
+ *
+ * Copyright (c) 2015-2024 SSE2NEON Contributors.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+// This header file provides a simple API translation layer
+// between SSE intrinsics to their corresponding Arm/Aarch64 NEON versions
+//
+// Contributors to this work are:
+//   John W. Ratcliff <jratcliffscarab@gmail.com>
+//   Brandon Rowlett <browlett@nvidia.com>
+//   Ken Fast <kfast@gdeb.com>
+//   Eric van Beurden <evanbeurden@nvidia.com>
+//   Alexander Potylitsin <apotylitsin@nvidia.com>
+//   Hasindu Gamaarachchi <hasindu2008@gmail.com>
+//   Jim Huang <jserv@ccns.ncku.edu.tw>
+//   Mark Cheng <marktwtn@gmail.com>
+//   Malcolm James MacLeod <malcolm@gulden.com>
+//   Devin Hussey (easyaspi314) <husseydevin@gmail.com>
+//   Sebastian Pop <spop@amazon.com>
+//   Developer Ecosystem Engineering <DeveloperEcosystemEngineering@apple.com>
+//   Danila Kutenin <danilak@google.com>
+//   Fran√ßois Turban (JishinMaster) <francois.turban@gmail.com>
+//   Pei-Hsuan Hung <afcidk@gmail.com>
+//   Yang-Hao Yuan <yuanyanghau@gmail.com>
+//   Syoyo Fujita <syoyo@lighttransport.com>
+//   Brecht Van Lommel <brecht@blender.org>
+//   Jonathan Hue <jhue@adobe.com>
+//   Cuda Chen <clh960524@gmail.com>
+//   Aymen Qader <aymen.qader@arm.com>
+//   Anthony Roberts <anthony.roberts@linaro.org>
+
+/* Tunable configurations */
+
+/* Enable precise implementation of math operations
+ * This would slow down the computation a bit, but gives consistent result with
+ * x86 SSE. (e.g. would solve a hole or NaN pixel in the rendering result)
+ */
+/* _mm_min|max_ps|ss|pd|sd */
+#ifndef SSE2NEON_PRECISE_MINMAX
+#define SSE2NEON_PRECISE_MINMAX (1) // always use precise implementation
+#endif
+/* _mm_rcp_ps */
+#ifndef SSE2NEON_PRECISE_DIV
+#define SSE2NEON_PRECISE_DIV (1) // always use precise implementation
+#endif
+/* _mm_sqrt_ps and _mm_rsqrt_ps */
+#ifndef SSE2NEON_PRECISE_SQRT
+#define SSE2NEON_PRECISE_SQRT (1) // always use precise implementation
+#endif
+/* _mm_dp_pd */
+#ifndef SSE2NEON_PRECISE_DP
+#define SSE2NEON_PRECISE_DP (1) // always use precise implementation
+#endif
+
+/* Enable inclusion of windows.h on MSVC platforms
+ * This makes _mm_clflush functional on windows, as there is no builtin.
+ */
+#ifndef SSE2NEON_INCLUDE_WINDOWS_H
+#define SSE2NEON_INCLUDE_WINDOWS_H (0)
+#endif
+
+/* compiler specific definitions */
+#if defined(__GNUC__) || defined(__clang__)
+#pragma push_macro("FORCE_INLINE")
+#pragma push_macro("ALIGN_STRUCT")
+#define FORCE_INLINE static inline __attribute__((always_inline))
+#define ALIGN_STRUCT(x) __attribute__((aligned(x)))
+#define _sse2neon_likely(x) __builtin_expect(!!(x), 1)
+#define _sse2neon_unlikely(x) __builtin_expect(!!(x), 0)
+#elif defined(_MSC_VER)
+#if _MSVC_TRADITIONAL
+#error Using the traditional MSVC preprocessor is not supported! Use /Zc:preprocessor instead.
+#endif
+#ifndef FORCE_INLINE
+#define FORCE_INLINE static inline
+#endif
+#ifndef ALIGN_STRUCT
+#define ALIGN_STRUCT(x) __declspec(align(x))
+#endif
+#define _sse2neon_likely(x) (x)
+#define _sse2neon_unlikely(x) (x)
+#else
+#pragma message("Macro name collisions may happen with unsupported compilers.")
+#endif
+
+
+#if defined(__GNUC__) && !defined(__clang__)
+#pragma push_macro("FORCE_INLINE_OPTNONE")
+#define FORCE_INLINE_OPTNONE static inline __attribute__((optimize("O0")))
+#elif defined(__clang__)
+#pragma push_macro("FORCE_INLINE_OPTNONE")
+#define FORCE_INLINE_OPTNONE static inline __attribute__((optnone))
+#else
+#define FORCE_INLINE_OPTNONE FORCE_INLINE
+#endif
+
+#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ < 10
+#warning "GCC versions earlier than 10 are not supported."
+#endif
+
+/* C language does not allow initializing a variable with a function call. */
+#ifdef __cplusplus
+#define _sse2neon_const static const
+#else
+#define _sse2neon_const const
+#endif
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+FORCE_INLINE double sse2neon_recast_u64_f64(uint64_t u64)
+{
+    double f64;
+    memcpy(&f64, &u64, sizeof(uint64_t));
+    return f64;
+}
+FORCE_INLINE int64_t sse2neon_recast_f64_s64(double f64)
+{
+    int64_t i64;
+    memcpy(&i64, &f64, sizeof(uint64_t));
+    return i64;
+}
+
+#if defined(_WIN32)
+/* Definitions for _mm_{malloc,free} are provided by <malloc.h>
+ * from both MinGW-w64 and MSVC.
+ */
+#define SSE2NEON_ALLOC_DEFINED
+#endif
+
+/* If using MSVC */
+#ifdef _MSC_VER
+#include <intrin.h>
+#if SSE2NEON_INCLUDE_WINDOWS_H
+#include <processthreadsapi.h>
+#include <windows.h>
+#endif
+
+#if !defined(__cplusplus)
+#error SSE2NEON only supports C++ compilation with this compiler
+#endif
+
+#ifdef SSE2NEON_ALLOC_DEFINED
+#include <malloc.h>
+#endif
+
+#if (defined(_M_AMD64) || defined(__x86_64__)) || \
+    (defined(_M_ARM64) || defined(__arm64__))
+#define SSE2NEON_HAS_BITSCAN64
+#endif
+#endif
+
+#if defined(__GNUC__) || defined(__clang__)
+#define _sse2neon_define0(type, s, body) \
+    __extension__({                      \
+        type _a = (s);                   \
+        body                             \
+    })
+#define _sse2neon_define1(type, s, body) \
+    __extension__({                      \
+        type _a = (s);                   \
+        body                             \
+    })
+#define _sse2neon_define2(type, a, b, body) \
+    __extension__({                         \
+        type _a = (a), _b = (b);            \
+        body                                \
+    })
+#define _sse2neon_return(ret) (ret)
+#else
+#define _sse2neon_define0(type, a, body) [=](type _a) { body }(a)
+#define _sse2neon_define1(type, a, body) [](type _a) { body }(a)
+#define _sse2neon_define2(type, a, b, body) \
+    [](type _a, type _b) { body }((a), (b))
+#define _sse2neon_return(ret) return ret
+#endif
+
+#define _sse2neon_init(...) \
+    {                       \
+        __VA_ARGS__         \
+    }
+
+/* Compiler barrier */
+#if defined(_MSC_VER) && !defined(__clang__)
+#define SSE2NEON_BARRIER() _ReadWriteBarrier()
+#else
+#define SSE2NEON_BARRIER()                     \
+    do {                                       \
+        __asm__ __volatile__("" ::: "memory"); \
+        (void) 0;                              \
+    } while (0)
+#endif
+
+/* Memory barriers
+ * __atomic_thread_fence does not include a compiler barrier; instead,
+ * the barrier is part of __atomic_load/__atomic_store's "volatile-like"
+ * semantics.
+ */
+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)
+#include <stdatomic.h>
+#endif
+
+FORCE_INLINE void _sse2neon_smp_mb(void)
+{
+    SSE2NEON_BARRIER();
+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && \
+    !defined(__STDC_NO_ATOMICS__)
+    atomic_thread_fence(memory_order_seq_cst);
+#elif defined(__GNUC__) || defined(__clang__)
+    __atomic_thread_fence(__ATOMIC_SEQ_CST);
+#else /* MSVC */
+    __dmb(_ARM64_BARRIER_ISH);
+#endif
+}
+
+/* Architecture-specific build options */
+/* FIXME: #pragma GCC push_options is only available on GCC */
+#if defined(__GNUC__)
+#if defined(__arm__) && __ARM_ARCH == 7
+/* According to ARM C Language Extensions Architecture specification,
+ * __ARM_NEON is defined to a value indicating the Advanced SIMD (NEON)
+ * architecture supported.
+ */
+#if !defined(__ARM_NEON) || !defined(__ARM_NEON__)
+#error "You must enable NEON instructions (e.g. -mfpu=neon) to use SSE2NEON."
+#endif
+#if !defined(__clang__)
+#pragma GCC push_options
+#pragma GCC target("fpu=neon")
+#endif
+#elif defined(__aarch64__) || defined(_M_ARM64)
+#if !defined(__clang__) && !defined(_MSC_VER)
+#pragma GCC push_options
+#pragma GCC target("+simd")
+#endif
+#elif __ARM_ARCH == 8
+#if !defined(__ARM_NEON) || !defined(__ARM_NEON__)
+#error \
+    "You must enable NEON instructions (e.g. -mfpu=neon-fp-armv8) to use SSE2NEON."
+#endif
+#if !defined(__clang__) && !defined(_MSC_VER)
+#pragma GCC push_options
+#endif
+#else
+#error \
+    "Unsupported target. Must be either ARMv7-A+NEON or ARMv8-A \
+(you could try setting target explicitly with -march or -mcpu)"
+#endif
+#endif
+
+#include <arm_neon.h>
+#if (!defined(__aarch64__) && !defined(_M_ARM64)) && (__ARM_ARCH == 8)
+#if defined __has_include && __has_include(<arm_acle.h>)
+#include <arm_acle.h>
+#endif
+#endif
+
+/* Apple Silicon cache lines are double of what is commonly used by Intel, AMD
+ * and other Arm microarchitectures use.
+ * From sysctl -a on Apple M1:
+ * hw.cachelinesize: 128
+ */
+#if defined(__APPLE__) && (defined(__aarch64__) || defined(__arm64__))
+#define SSE2NEON_CACHELINE_SIZE 128
+#else
+#define SSE2NEON_CACHELINE_SIZE 64
+#endif
+
+/* Rounding functions require either Aarch64 instructions or libm fallback */
+#if !defined(__aarch64__) && !defined(_M_ARM64)
+#include <math.h>
+#endif
+
+/* On ARMv7, some registers, such as PMUSERENR and PMCCNTR, are read-only
+ * or even not accessible in user mode.
+ * To write or access to these registers in user mode,
+ * we have to perform syscall instead.
+ */
+#if (!defined(__aarch64__) && !defined(_M_ARM64))
+#include <sys/time.h>
+#endif
+
+/* "__has_builtin" can be used to query support for built-in functions
+ * provided by gcc/clang and other compilers that support it.
+ */
+#ifndef __has_builtin /* GCC prior to 10 or non-clang compilers */
+/* Compatibility with gcc <= 9 */
+#if defined(__GNUC__) && (__GNUC__ <= 9)
+#define __has_builtin(x) HAS##x
+#define HAS__builtin_popcount 1
+#define HAS__builtin_popcountll 1
+
+// __builtin_shuffle introduced in GCC 4.7.0
+#if (__GNUC__ >= 5) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7))
+#define HAS__builtin_shuffle 1
+#else
+#define HAS__builtin_shuffle 0
+#endif
+
+#define HAS__builtin_shufflevector 0
+#define HAS__builtin_nontemporal_store 0
+#else
+#define __has_builtin(x) 0
+#endif
+#endif
+
+/**
+ * MACRO for shuffle parameter for _mm_shuffle_ps().
+ * Argument fp3 is a digit[0123] that represents the fp from argument "b"
+ * of mm_shuffle_ps that will be placed in fp3 of result. fp2 is the same
+ * for fp2 in result. fp1 is a digit[0123] that represents the fp from
+ * argument "a" of mm_shuffle_ps that will be places in fp1 of result.
+ * fp0 is the same for fp0 of result.
+ */
+#define _MM_SHUFFLE(fp3, fp2, fp1, fp0) \
+    (((fp3) << 6) | ((fp2) << 4) | ((fp1) << 2) | ((fp0)))
+
+#if __has_builtin(__builtin_shufflevector)
+#define _sse2neon_shuffle(type, a, b, ...) \
+    __builtin_shufflevector(a, b, __VA_ARGS__)
+#elif __has_builtin(__builtin_shuffle)
+#define _sse2neon_shuffle(type, a, b, ...) \
+    __extension__({                        \
+        type tmp = {__VA_ARGS__};          \
+        __builtin_shuffle(a, b, tmp);      \
+    })
+#endif
+
+#ifdef _sse2neon_shuffle
+#define vshuffle_s16(a, b, ...) _sse2neon_shuffle(int16x4_t, a, b, __VA_ARGS__)
+#define vshuffleq_s16(a, b, ...) _sse2neon_shuffle(int16x8_t, a, b, __VA_ARGS__)
+#define vshuffle_s32(a, b, ...) _sse2neon_shuffle(int32x2_t, a, b, __VA_ARGS__)
+#define vshuffleq_s32(a, b, ...) _sse2neon_shuffle(int32x4_t, a, b, __VA_ARGS__)
+#define vshuffle_s64(a, b, ...) _sse2neon_shuffle(int64x1_t, a, b, __VA_ARGS__)
+#define vshuffleq_s64(a, b, ...) _sse2neon_shuffle(int64x2_t, a, b, __VA_ARGS__)
+#endif
+
+/* Rounding mode macros. */
+#define _MM_FROUND_TO_NEAREST_INT 0x00
+#define _MM_FROUND_TO_NEG_INF 0x01
+#define _MM_FROUND_TO_POS_INF 0x02
+#define _MM_FROUND_TO_ZERO 0x03
+#define _MM_FROUND_CUR_DIRECTION 0x04
+#define _MM_FROUND_NO_EXC 0x08
+#define _MM_FROUND_RAISE_EXC 0x00
+#define _MM_FROUND_NINT (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_RAISE_EXC)
+#define _MM_FROUND_FLOOR (_MM_FROUND_TO_NEG_INF | _MM_FROUND_RAISE_EXC)
+#define _MM_FROUND_CEIL (_MM_FROUND_TO_POS_INF | _MM_FROUND_RAISE_EXC)
+#define _MM_FROUND_TRUNC (_MM_FROUND_TO_ZERO | _MM_FROUND_RAISE_EXC)
+#define _MM_FROUND_RINT (_MM_FROUND_CUR_DIRECTION | _MM_FROUND_RAISE_EXC)
+#define _MM_FROUND_NEARBYINT (_MM_FROUND_CUR_DIRECTION | _MM_FROUND_NO_EXC)
+#define _MM_ROUND_NEAREST 0x0000
+#define _MM_ROUND_DOWN 0x2000
+#define _MM_ROUND_UP 0x4000
+#define _MM_ROUND_TOWARD_ZERO 0x6000
+/* Flush zero mode macros. */
+#define _MM_FLUSH_ZERO_MASK 0x8000
+#define _MM_FLUSH_ZERO_ON 0x8000
+#define _MM_FLUSH_ZERO_OFF 0x0000
+/* Denormals are zeros mode macros. */
+#define _MM_DENORMALS_ZERO_MASK 0x0040
+#define _MM_DENORMALS_ZERO_ON 0x0040
+#define _MM_DENORMALS_ZERO_OFF 0x0000
+
+/* indicate immediate constant argument in a given range */
+#define __constrange(a, b) const
+
+/* A few intrinsics accept traditional data types like ints or floats, but
+ * most operate on data types that are specific to SSE.
+ * If a vector type ends in d, it contains doubles, and if it does not have
+ * a suffix, it contains floats. An integer vector type can contain any type
+ * of integer, from chars to shorts to unsigned long longs.
+ */
+typedef int64x1_t __m64;
+typedef float32x4_t __m128; /* 128-bit vector containing 4 floats */
+// On ARM 32-bit architecture, the float64x2_t is not supported.
+// The data type __m128d should be represented in a different way for related
+// intrinsic conversion.
+#if defined(__aarch64__) || defined(_M_ARM64)
+typedef float64x2_t __m128d; /* 128-bit vector containing 2 doubles */
+#else
+typedef float32x4_t __m128d;
+#endif
+typedef int64x2_t __m128i; /* 128-bit vector containing integers */
+
+// Some intrinsics operate on unaligned data types.
+typedef int16_t ALIGN_STRUCT(1) unaligned_int16_t;
+typedef int32_t ALIGN_STRUCT(1) unaligned_int32_t;
+typedef int64_t ALIGN_STRUCT(1) unaligned_int64_t;
+
+// __int64 is defined in the Intrinsics Guide which maps to different datatype
+// in different data model
+#if !(defined(_WIN32) || defined(_WIN64) || defined(__int64))
+#if (defined(__x86_64__) || defined(__i386__))
+#define __int64 long long
+#else
+#define __int64 int64_t
+#endif
+#endif
+
+/* type-safe casting between types */
+
+#define vreinterpretq_m128_f16(x) vreinterpretq_f32_f16(x)
+#define vreinterpretq_m128_f32(x) (x)
+#define vreinterpretq_m128_f64(x) vreinterpretq_f32_f64(x)
+
+#define vreinterpretq_m128_u8(x) vreinterpretq_f32_u8(x)
+#define vreinterpretq_m128_u16(x) vreinterpretq_f32_u16(x)
+#define vreinterpretq_m128_u32(x) vreinterpretq_f32_u32(x)
+#define vreinterpretq_m128_u64(x) vreinterpretq_f32_u64(x)
+
+#define vreinterpretq_m128_s8(x) vreinterpretq_f32_s8(x)
+#define vreinterpretq_m128_s16(x) vreinterpretq_f32_s16(x)
+#define vreinterpretq_m128_s32(x) vreinterpretq_f32_s32(x)
+#define vreinterpretq_m128_s64(x) vreinterpretq_f32_s64(x)
+
+#define vreinterpretq_f16_m128(x) vreinterpretq_f16_f32(x)
+#define vreinterpretq_f32_m128(x) (x)
+#define vreinterpretq_f64_m128(x) vreinterpretq_f64_f32(x)
+
+#define vreinterpretq_u8_m128(x) vreinterpretq_u8_f32(x)
+#define vreinterpretq_u16_m128(x) vreinterpretq_u16_f32(x)
+#define vreinterpretq_u32_m128(x) vreinterpretq_u32_f32(x)
+#define vreinterpretq_u64_m128(x) vreinterpretq_u64_f32(x)
+
+#define vreinterpretq_s8_m128(x) vreinterpretq_s8_f32(x)
+#define vreinterpretq_s16_m128(x) vreinterpretq_s16_f32(x)
+#define vreinterpretq_s32_m128(x) vreinterpretq_s32_f32(x)
+#define vreinterpretq_s64_m128(x) vreinterpretq_s64_f32(x)
+
+#define vreinterpretq_m128i_s8(x) vreinterpretq_s64_s8(x)
+#define vreinterpretq_m128i_s16(x) vreinterpretq_s64_s16(x)
+#define vreinterpretq_m128i_s32(x) vreinterpretq_s64_s32(x)
+#define vreinterpretq_m128i_s64(x) (x)
+
+#define vreinterpretq_m128i_u8(x) vreinterpretq_s64_u8(x)
+#define vreinterpretq_m128i_u16(x) vreinterpretq_s64_u16(x)
+#define vreinterpretq_m128i_u32(x) vreinterpretq_s64_u32(x)
+#define vreinterpretq_m128i_u64(x) vreinterpretq_s64_u64(x)
+
+#define vreinterpretq_f32_m128i(x) vreinterpretq_f32_s64(x)
+#define vreinterpretq_f64_m128i(x) vreinterpretq_f64_s64(x)
+
+#define vreinterpretq_s8_m128i(x) vreinterpretq_s8_s64(x)
+#define vreinterpretq_s16_m128i(x) vreinterpretq_s16_s64(x)
+#define vreinterpretq_s32_m128i(x) vreinterpretq_s32_s64(x)
+#define vreinterpretq_s64_m128i(x) (x)
+
+#define vreinterpretq_u8_m128i(x) vreinterpretq_u8_s64(x)
+#define vreinterpretq_u16_m128i(x) vreinterpretq_u16_s64(x)
+#define vreinterpretq_u32_m128i(x) vreinterpretq_u32_s64(x)
+#define vreinterpretq_u64_m128i(x) vreinterpretq_u64_s64(x)
+
+#define vreinterpret_m64_s8(x) vreinterpret_s64_s8(x)
+#define vreinterpret_m64_s16(x) vreinterpret_s64_s16(x)
+#define vreinterpret_m64_s32(x) vreinterpret_s64_s32(x)
+#define vreinterpret_m64_s64(x) (x)
+
+#define vreinterpret_m64_u8(x) vreinterpret_s64_u8(x)
+#define vreinterpret_m64_u16(x) vreinterpret_s64_u16(x)
+#define vreinterpret_m64_u32(x) vreinterpret_s64_u32(x)
+#define vreinterpret_m64_u64(x) vreinterpret_s64_u64(x)
+
+#define vreinterpret_m64_f16(x) vreinterpret_s64_f16(x)
+#define vreinterpret_m64_f32(x) vreinterpret_s64_f32(x)
+#define vreinterpret_m64_f64(x) vreinterpret_s64_f64(x)
+
+#define vreinterpret_u8_m64(x) vreinterpret_u8_s64(x)
+#define vreinterpret_u16_m64(x) vreinterpret_u16_s64(x)
+#define vreinterpret_u32_m64(x) vreinterpret_u32_s64(x)
+#define vreinterpret_u64_m64(x) vreinterpret_u64_s64(x)
+
+#define vreinterpret_s8_m64(x) vreinterpret_s8_s64(x)
+#define vreinterpret_s16_m64(x) vreinterpret_s16_s64(x)
+#define vreinterpret_s32_m64(x) vreinterpret_s32_s64(x)
+#define vreinterpret_s64_m64(x) (x)
+
+#define vreinterpret_f32_m64(x) vreinterpret_f32_s64(x)
+
+#if defined(__aarch64__) || defined(_M_ARM64)
+#define vreinterpretq_m128d_s32(x) vreinterpretq_f64_s32(x)
+#define vreinterpretq_m128d_s64(x) vreinterpretq_f64_s64(x)
+
+#define vreinterpretq_m128d_u64(x) vreinterpretq_f64_u64(x)
+
+#define vreinterpretq_m128d_f32(x) vreinterpretq_f64_f32(x)
+#define vreinterpretq_m128d_f64(x) (x)
+
+#define vreinterpretq_s64_m128d(x) vreinterpretq_s64_f64(x)
+
+#define vreinterpretq_u32_m128d(x) vreinterpretq_u32_f64(x)
+#define vreinterpretq_u64_m128d(x) vreinterpretq_u64_f64(x)
+
+#define vreinterpretq_f64_m128d(x) (x)
+#define vreinterpretq_f32_m128d(x) vreinterpretq_f32_f64(x)
+#else
+#define vreinterpretq_m128d_s32(x) vreinterpretq_f32_s32(x)
+#define vreinterpretq_m128d_s64(x) vreinterpretq_f32_s64(x)
+
+#define vreinterpretq_m128d_u32(x) vreinterpretq_f32_u32(x)
+#define vreinterpretq_m128d_u64(x) vreinterpretq_f32_u64(x)
+
+#define vreinterpretq_m128d_f32(x) (x)
+
+#define vreinterpretq_s64_m128d(x) vreinterpretq_s64_f32(x)
+
+#define vreinterpretq_u32_m128d(x) vreinterpretq_u32_f32(x)
+#define vreinterpretq_u64_m128d(x) vreinterpretq_u64_f32(x)
+
+#define vreinterpretq_f32_m128d(x) (x)
+#endif
+
+// A struct is defined in this header file called 'SIMDVec' which can be used
+// by applications which attempt to access the contents of an __m128 struct
+// directly.  It is important to note that accessing the __m128 struct directly
+// is bad coding practice by Microsoft: @see:
+// https://learn.microsoft.com/en-us/cpp/cpp/m128
+//
+// However, some legacy source code may try to access the contents of an __m128
+// struct directly so the developer can use the SIMDVec as an alias for it.  Any
+// casting must be done manually by the developer, as you cannot cast or
+// otherwise alias the base NEON data type for intrinsic operations.
+//
+// union intended to allow direct access to an __m128 variable using the names
+// that the MSVC compiler provides.  This union should really only be used when
+// trying to access the members of the vector as integer values.  GCC/clang
+// allow native access to the float members through a simple array access
+// operator (in C since 4.6, in C++ since 4.8).
+//
+// Ideally direct accesses to SIMD vectors should not be used since it can cause
+// a performance hit.  If it really is needed however, the original __m128
+// variable can be aliased with a pointer to this union and used to access
+// individual components.  The use of this union should be hidden behind a macro
+// that is used throughout the codebase to access the members instead of always
+// declaring this type of variable.
+typedef union ALIGN_STRUCT(16) SIMDVec {
+    float m128_f32[4];     // as floats - DON'T USE. Added for convenience.
+    int8_t m128_i8[16];    // as signed 8-bit integers.
+    int16_t m128_i16[8];   // as signed 16-bit integers.
+    int32_t m128_i32[4];   // as signed 32-bit integers.
+    int64_t m128_i64[2];   // as signed 64-bit integers.
+    uint8_t m128_u8[16];   // as unsigned 8-bit integers.
+    uint16_t m128_u16[8];  // as unsigned 16-bit integers.
+    uint32_t m128_u32[4];  // as unsigned 32-bit integers.
+    uint64_t m128_u64[2];  // as unsigned 64-bit integers.
+} SIMDVec;
+
+// casting using SIMDVec
+#define vreinterpretq_nth_u64_m128i(x, n) (((SIMDVec *) &x)->m128_u64[n])
+#define vreinterpretq_nth_u32_m128i(x, n) (((SIMDVec *) &x)->m128_u32[n])
+#define vreinterpretq_nth_u8_m128i(x, n) (((SIMDVec *) &x)->m128_u8[n])
+
+/* SSE macros */
+#define _MM_GET_FLUSH_ZERO_MODE _sse2neon_mm_get_flush_zero_mode
+#define _MM_SET_FLUSH_ZERO_MODE _sse2neon_mm_set_flush_zero_mode
+#define _MM_GET_DENORMALS_ZERO_MODE _sse2neon_mm_get_denormals_zero_mode
+#define _MM_SET_DENORMALS_ZERO_MODE _sse2neon_mm_set_denormals_zero_mode
+
+// Function declaration
+// SSE
+FORCE_INLINE unsigned int _MM_GET_ROUNDING_MODE(void);
+FORCE_INLINE __m128 _mm_move_ss(__m128, __m128);
+FORCE_INLINE __m128 _mm_or_ps(__m128, __m128);
+FORCE_INLINE __m128 _mm_set_ps1(float);
+FORCE_INLINE __m128 _mm_setzero_ps(void);
+// SSE2
+FORCE_INLINE __m128i _mm_and_si128(__m128i, __m128i);
+FORCE_INLINE __m128i _mm_castps_si128(__m128);
+FORCE_INLINE __m128i _mm_cmpeq_epi32(__m128i, __m128i);
+FORCE_INLINE __m128i _mm_cvtps_epi32(__m128);
+FORCE_INLINE __m128d _mm_move_sd(__m128d, __m128d);
+FORCE_INLINE __m128i _mm_or_si128(__m128i, __m128i);
+FORCE_INLINE __m128i _mm_set_epi32(int, int, int, int);
+FORCE_INLINE __m128i _mm_set_epi64x(int64_t, int64_t);
+FORCE_INLINE __m128d _mm_set_pd(double, double);
+FORCE_INLINE __m128i _mm_set1_epi32(int);
+FORCE_INLINE __m128i _mm_setzero_si128(void);
+// SSE4.1
+FORCE_INLINE __m128d _mm_ceil_pd(__m128d);
+FORCE_INLINE __m128 _mm_ceil_ps(__m128);
+FORCE_INLINE __m128d _mm_floor_pd(__m128d);
+FORCE_INLINE __m128 _mm_floor_ps(__m128);
+FORCE_INLINE_OPTNONE __m128d _mm_round_pd(__m128d, int);
+FORCE_INLINE_OPTNONE __m128 _mm_round_ps(__m128, int);
+// SSE4.2
+FORCE_INLINE uint32_t _mm_crc32_u8(uint32_t, uint8_t);
+
+/* Backwards compatibility for compilers with lack of specific type support */
+
+// Older gcc does not define vld1q_u8_x4 type
+#if defined(__GNUC__) && !defined(__clang__) &&                        \
+    ((__GNUC__ <= 13 && defined(__arm__)) ||                           \
+     (__GNUC__ == 10 && __GNUC_MINOR__ < 3 && defined(__aarch64__)) || \
+     (__GNUC__ <= 9 && defined(__aarch64__)))
+FORCE_INLINE uint8x16x4_t _sse2neon_vld1q_u8_x4(const uint8_t *p)
+{
+    uint8x16x4_t ret;
+    ret.val[0] = vld1q_u8(p + 0);
+    ret.val[1] = vld1q_u8(p + 16);
+    ret.val[2] = vld1q_u8(p + 32);
+    ret.val[3] = vld1q_u8(p + 48);
+    return ret;
+}
+#else
+// Wraps vld1q_u8_x4
+FORCE_INLINE uint8x16x4_t _sse2neon_vld1q_u8_x4(const uint8_t *p)
+{
+    return vld1q_u8_x4(p);
+}
+#endif
+
+#if !defined(__aarch64__) && !defined(_M_ARM64)
+/* emulate vaddv u8 variant */
+FORCE_INLINE uint8_t _sse2neon_vaddv_u8(uint8x8_t v8)
+{
+    const uint64x1_t v1 = vpaddl_u32(vpaddl_u16(vpaddl_u8(v8)));
+    return vget_lane_u8(vreinterpret_u8_u64(v1), 0);
+}
+#else
+// Wraps vaddv_u8
+FORCE_INLINE uint8_t _sse2neon_vaddv_u8(uint8x8_t v8)
+{
+    return vaddv_u8(v8);
+}
+#endif
+
+#if !defined(__aarch64__) && !defined(_M_ARM64)
+/* emulate vaddvq u8 variant */
+FORCE_INLINE uint8_t _sse2neon_vaddvq_u8(uint8x16_t a)
+{
+    uint8x8_t tmp = vpadd_u8(vget_low_u8(a), vget_high_u8(a));
+    uint8_t res = 0;
+    for (int i = 0; i < 8; ++i)
+        res += tmp[i];
+    return res;
+}
+#else
+// Wraps vaddvq_u8
+FORCE_INLINE uint8_t _sse2neon_vaddvq_u8(uint8x16_t a)
+{
+    return vaddvq_u8(a);
+}
+#endif
+
+#if !defined(__aarch64__) && !defined(_M_ARM64)
+/* emulate vaddvq u16 variant */
+FORCE_INLINE uint16_t _sse2neon_vaddvq_u16(uint16x8_t a)
+{
+    uint32x4_t m = vpaddlq_u16(a);
+    uint64x2_t n = vpaddlq_u32(m);
+    uint64x1_t o = vget_low_u64(n) + vget_high_u64(n);
+
+    return vget_lane_u32((uint32x2_t) o, 0);
+}
+#else
+// Wraps vaddvq_u16
+FORCE_INLINE uint16_t _sse2neon_vaddvq_u16(uint16x8_t a)
+{
+    return vaddvq_u16(a);
+}
+#endif
+
+/* Function Naming Conventions
+ * The naming convention of SSE intrinsics is straightforward. A generic SSE
+ * intrinsic function is given as follows:
+ *   _mm_<name>_<data_type>
+ *
+ * The parts of this format are given as follows:
+ * 1. <name> describes the operation performed by the intrinsic
+ * 2. <data_type> identifies the data type of the function's primary arguments
+ *
+ * This last part, <data_type>, is a little complicated. It identifies the
+ * content of the input values, and can be set to any of the following values:
+ * + ps - vectors contain floats (ps stands for packed single-precision)
+ * + pd - vectors contain doubles (pd stands for packed double-precision)
+ * + epi8/epi16/epi32/epi64 - vectors contain 8-bit/16-bit/32-bit/64-bit
+ *                            signed integers
+ * + epu8/epu16/epu32/epu64 - vectors contain 8-bit/16-bit/32-bit/64-bit
+ *                            unsigned integers
+ * + si128 - unspecified 128-bit vector or 256-bit vector
+ * + m128/m128i/m128d - identifies input vector types when they are different
+ *                      than the type of the returned vector
+ *
+ * For example, _mm_setzero_ps. The _mm implies that the function returns
+ * a 128-bit vector. The _ps at the end implies that the argument vectors
+ * contain floats.
+ *
+ * A complete example: Byte Shuffle - pshufb (_mm_shuffle_epi8)
+ *   // Set packed 16-bit integers. 128 bits, 8 short, per 16 bits
+ *   __m128i v_in = _mm_setr_epi16(1, 2, 3, 4, 5, 6, 7, 8);
+ *   // Set packed 8-bit integers
+ *   // 128 bits, 16 chars, per 8 bits
+ *   __m128i v_perm = _mm_setr_epi8(1, 0,  2,  3, 8, 9, 10, 11,
+ *                                  4, 5, 12, 13, 6, 7, 14, 15);
+ *   // Shuffle packed 8-bit integers
+ *   __m128i v_out = _mm_shuffle_epi8(v_in, v_perm); // pshufb
+ */
+
+/* Constants for use with _mm_prefetch. */
+enum _mm_hint {
+    _MM_HINT_NTA = 0, /* load data to L1 and L2 cache, mark it as NTA */
+    _MM_HINT_T0 = 1,  /* load data to L1 and L2 cache */
+    _MM_HINT_T1 = 2,  /* load data to L2 cache only */
+    _MM_HINT_T2 = 3,  /* load data to L2 cache only, mark it as NTA */
+};
+
+// The bit field mapping to the FPCR(floating-point control register)
+typedef struct {
+    uint16_t res0;
+    uint8_t res1 : 6;
+    uint8_t bit22 : 1;
+    uint8_t bit23 : 1;
+    uint8_t bit24 : 1;
+    uint8_t res2 : 7;
+#if defined(__aarch64__) || defined(_M_ARM64)
+    uint32_t res3;
+#endif
+} fpcr_bitfield;
+
+// Takes the upper 64 bits of a and places it in the low end of the result
+// Takes the lower 64 bits of b and places it into the high end of the result.
+FORCE_INLINE __m128 _mm_shuffle_ps_1032(__m128 a, __m128 b)
+{
+    float32x2_t a32 = vget_high_f32(vreinterpretq_f32_m128(a));
+    float32x2_t b10 = vget_low_f32(vreinterpretq_f32_m128(b));
+    return vreinterpretq_m128_f32(vcombine_f32(a32, b10));
+}
+
+// takes the lower two 32-bit values from a and swaps them and places in high
+// end of result takes the higher two 32 bit values from b and swaps them and
+// places in low end of result.
+FORCE_INLINE __m128 _mm_shuffle_ps_2301(__m128 a, __m128 b)
+{
+    float32x2_t a01 = vrev64_f32(vget_low_f32(vreinterpretq_f32_m128(a)));
+    float32x2_t b23 = vrev64_f32(vget_high_f32(vreinterpretq_f32_m128(b)));
+    return vreinterpretq_m128_f32(vcombine_f32(a01, b23));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_0321(__m128 a, __m128 b)
+{
+    float32x2_t a21 = vget_high_f32(
+        vextq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(a), 3));
+    float32x2_t b03 = vget_low_f32(
+        vextq_f32(vreinterpretq_f32_m128(b), vreinterpretq_f32_m128(b), 3));
+    return vreinterpretq_m128_f32(vcombine_f32(a21, b03));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_2103(__m128 a, __m128 b)
+{
+    float32x2_t a03 = vget_low_f32(
+        vextq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(a), 3));
+    float32x2_t b21 = vget_high_f32(
+        vextq_f32(vreinterpretq_f32_m128(b), vreinterpretq_f32_m128(b), 3));
+    return vreinterpretq_m128_f32(vcombine_f32(a03, b21));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_1010(__m128 a, __m128 b)
+{
+    float32x2_t a10 = vget_low_f32(vreinterpretq_f32_m128(a));
+    float32x2_t b10 = vget_low_f32(vreinterpretq_f32_m128(b));
+    return vreinterpretq_m128_f32(vcombine_f32(a10, b10));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_1001(__m128 a, __m128 b)
+{
+    float32x2_t a01 = vrev64_f32(vget_low_f32(vreinterpretq_f32_m128(a)));
+    float32x2_t b10 = vget_low_f32(vreinterpretq_f32_m128(b));
+    return vreinterpretq_m128_f32(vcombine_f32(a01, b10));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_0101(__m128 a, __m128 b)
+{
+    float32x2_t a01 = vrev64_f32(vget_low_f32(vreinterpretq_f32_m128(a)));
+    float32x2_t b01 = vrev64_f32(vget_low_f32(vreinterpretq_f32_m128(b)));
+    return vreinterpretq_m128_f32(vcombine_f32(a01, b01));
+}
+
+// keeps the low 64 bits of b in the low and puts the high 64 bits of a in the
+// high
+FORCE_INLINE __m128 _mm_shuffle_ps_3210(__m128 a, __m128 b)
+{
+    float32x2_t a10 = vget_low_f32(vreinterpretq_f32_m128(a));
+    float32x2_t b32 = vget_high_f32(vreinterpretq_f32_m128(b));
+    return vreinterpretq_m128_f32(vcombine_f32(a10, b32));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_0011(__m128 a, __m128 b)
+{
+    float32x2_t a11 = vdup_lane_f32(vget_low_f32(vreinterpretq_f32_m128(a)), 1);
+    float32x2_t b00 = vdup_lane_f32(vget_low_f32(vreinterpretq_f32_m128(b)), 0);
+    return vreinterpretq_m128_f32(vcombine_f32(a11, b00));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_0022(__m128 a, __m128 b)
+{
+    float32x2_t a22 =
+        vdup_lane_f32(vget_high_f32(vreinterpretq_f32_m128(a)), 0);
+    float32x2_t b00 = vdup_lane_f32(vget_low_f32(vreinterpretq_f32_m128(b)), 0);
+    return vreinterpretq_m128_f32(vcombine_f32(a22, b00));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_2200(__m128 a, __m128 b)
+{
+    float32x2_t a00 = vdup_lane_f32(vget_low_f32(vreinterpretq_f32_m128(a)), 0);
+    float32x2_t b22 =
+        vdup_lane_f32(vget_high_f32(vreinterpretq_f32_m128(b)), 0);
+    return vreinterpretq_m128_f32(vcombine_f32(a00, b22));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_3202(__m128 a, __m128 b)
+{
+    float32_t a0 = vgetq_lane_f32(vreinterpretq_f32_m128(a), 0);
+    float32x2_t a22 =
+        vdup_lane_f32(vget_high_f32(vreinterpretq_f32_m128(a)), 0);
+    float32x2_t a02 = vset_lane_f32(a0, a22, 1); /* TODO: use vzip ?*/
+    float32x2_t b32 = vget_high_f32(vreinterpretq_f32_m128(b));
+    return vreinterpretq_m128_f32(vcombine_f32(a02, b32));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_1133(__m128 a, __m128 b)
+{
+    float32x2_t a33 =
+        vdup_lane_f32(vget_high_f32(vreinterpretq_f32_m128(a)), 1);
+    float32x2_t b11 = vdup_lane_f32(vget_low_f32(vreinterpretq_f32_m128(b)), 1);
+    return vreinterpretq_m128_f32(vcombine_f32(a33, b11));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_2010(__m128 a, __m128 b)
+{
+    float32x2_t a10 = vget_low_f32(vreinterpretq_f32_m128(a));
+    float32_t b2 = vgetq_lane_f32(vreinterpretq_f32_m128(b), 2);
+    float32x2_t b00 = vdup_lane_f32(vget_low_f32(vreinterpretq_f32_m128(b)), 0);
+    float32x2_t b20 = vset_lane_f32(b2, b00, 1);
+    return vreinterpretq_m128_f32(vcombine_f32(a10, b20));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_2001(__m128 a, __m128 b)
+{
+    float32x2_t a01 = vrev64_f32(vget_low_f32(vreinterpretq_f32_m128(a)));
+    float32_t b2 = vgetq_lane_f32(b, 2);
+    float32x2_t b00 = vdup_lane_f32(vget_low_f32(vreinterpretq_f32_m128(b)), 0);
+    float32x2_t b20 = vset_lane_f32(b2, b00, 1);
+    return vreinterpretq_m128_f32(vcombine_f32(a01, b20));
+}
+
+FORCE_INLINE __m128 _mm_shuffle_ps_2032(__m128 a, __m128 b)
+{
+    float32x2_t a32 = vget_high_f32(vreinterpretq_f32_m128(a));
+    float32_t b2 = vgetq_lane_f32(b, 2);
+    float32x2_t b00 = vdup_lane_f32(vget_low_f32(vreinterpretq_f32_m128(b)), 0);
+    float32x2_t b20 = vset_lane_f32(b2, b00, 1);
+    return vreinterpretq_m128_f32(vcombine_f32(a32, b20));
+}
+
+// For MSVC, we check only if it is ARM64, as every single ARM64 processor
+// supported by WoA has crypto extensions. If this changes in the future,
+// this can be verified via the runtime-only method of:
+// IsProcessorFeaturePresent(PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE)
+#if (defined(_M_ARM64) && !defined(__clang__)) || \
+    (defined(__ARM_FEATURE_CRYPTO) &&             \
+     (defined(__aarch64__) || __has_builtin(__builtin_arm_crypto_vmullp64)))
+// Wraps vmull_p64
+FORCE_INLINE uint64x2_t _sse2neon_vmull_p64(uint64x1_t _a, uint64x1_t _b)
+{
+    poly64_t a = vget_lane_p64(vreinterpret_p64_u64(_a), 0);
+    poly64_t b = vget_lane_p64(vreinterpret_p64_u64(_b), 0);
+#if defined(_MSC_VER) && !defined(__clang__)
+    __n64 a1 = {a}, b1 = {b};
+    return vreinterpretq_u64_p128(vmull_p64(a1, b1));
+#else
+    return vreinterpretq_u64_p128(vmull_p64(a, b));
+#endif
+}
+#else  // ARMv7 polyfill
+// ARMv7/some A64 lacks vmull_p64, but it has vmull_p8.
+//
+// vmull_p8 calculates 8 8-bit->16-bit polynomial multiplies, but we need a
+// 64-bit->128-bit polynomial multiply.
+//
+// It needs some work and is somewhat slow, but it is still faster than all
+// known scalar methods.
+//
+// Algorithm adapted to C from
+// https://www.workofard.com/2017/07/ghash-for-low-end-cores/, which is adapted
+// from "Fast Software Polynomial Multiplication on ARM Processors Using the
+// NEON Engine" by Danilo Camara, Conrado Gouvea, Julio Lopez and Ricardo Dahab
+// (https://hal.inria.fr/hal-01506572)
+static uint64x2_t _sse2neon_vmull_p64(uint64x1_t _a, uint64x1_t _b)
+{
+    poly8x8_t a = vreinterpret_p8_u64(_a);
+    poly8x8_t b = vreinterpret_p8_u64(_b);
+
+    // Masks
+    uint8x16_t k48_32 = vcombine_u8(vcreate_u8(0x0000ffffffffffff),
+                                    vcreate_u8(0x00000000ffffffff));
+    uint8x16_t k16_00 = vcombine_u8(vcreate_u8(0x000000000000ffff),
+                                    vcreate_u8(0x0000000000000000));
+
+    // Do the multiplies, rotating with vext to get all combinations
+    uint8x16_t d = vreinterpretq_u8_p16(vmull_p8(a, b));  // D = A0 * B0
+    uint8x16_t e =
+        vreinterpretq_u8_p16(vmull_p8(a, vext_p8(b, b, 1)));  // E = A0 * B1
+    uint8x16_t f =
+        vreinterpretq_u8_p16(vmull_p8(vext_p8(a, a, 1), b));  // F = A1 * B0
+    uint8x16_t g =
+        vreinterpretq_u8_p16(vmull_p8(a, vext_p8(b, b, 2)));  // G = A0 * B2
+    uint8x16_t h =
+        vreinterpretq_u8_p16(vmull_p8(vext_p8(a, a, 2), b));  // H = A2 * B0
+    uint8x16_t i =
+        vreinterpretq_u8_p16(vmull_p8(a, vext_p8(b, b, 3)));  // I = A0 * B3
+    uint8x16_t j =
+        vreinterpretq_u8_p16(vmull_p8(vext_p8(a, a, 3), b));  // J = A3 * B0
+    uint8x16_t k =
+        vreinterpretq_u8_p16(vmull_p8(a, vext_p8(b, b, 4)));  // L = A0 * B4
+
+    // Add cross products
+    uint8x16_t l = veorq_u8(e, f);  // L = E + F
+    uint8x16_t m = veorq_u8(g, h);  // M = G + H
+    uint8x16_t n = veorq_u8(i, j);  // N = I + J
+
+    // Interleave. Using vzip1 and vzip2 prevents Clang from emitting TBL
+    // instructions.
+#if defined(__aarch64__)
+    uint8x16_t lm_p0 = vreinterpretq_u8_u64(
+        vzip1q_u64(vreinterpretq_u64_u8(l), vreinterpretq_u64_u8(m)));
+    uint8x16_t lm_p1 = vreinterpretq_u8_u64(
+        vzip2q_u64(vreinterpretq_u64_u8(l), vreinterpretq_u64_u8(m)));
+    uint8x16_t nk_p0 = vreinterpretq_u8_u64(
+        vzip1q_u64(vreinterpretq_u64_u8(n), vreinterpretq_u64_u8(k)));
+    uint8x16_t nk_p1 = vreinterpretq_u8_u64(
+        vzip2q_u64(vreinterpretq_u64_u8(n), vreinterpretq_u64_u8(k)));
+#else
+    uint8x16_t lm_p0 = vcombine_u8(vget_low_u8(l), vget_low_u8(m));
+    uint8x16_t lm_p1 = vcombine_u8(vget_high_u8(l), vget_high_u8(m));
+    uint8x16_t nk_p0 = vcombine_u8(vget_low_u8(n), vget_low_u8(k));
+    uint8x16_t nk_p1 = vcombine_u8(vget_high_u8(n), vget_high_u8(k));
+#endif
+    // t0 = (L) (P0 + P1) << 8
+    // t1 = (M) (P2 + P3) << 16
+    uint8x16_t t0t1_tmp = veorq_u8(lm_p0, lm_p1);
+    uint8x16_t t0t1_h = vandq_u8(lm_p1, k48_32);
+    uint8x16_t t0t1_l = veorq_u8(t0t1_tmp, t0t1_h);
+
+    // t2 = (N) (P4 + P5) << 24
+    // t3 = (K) (P6 + P7) << 32
+    uint8x16_t t2t3_tmp = veorq_u8(nk_p0, nk_p1);
+    uint8x16_t t2t3_h = vandq_u8(nk_p1, k16_00);
+    uint8x16_t t2t3_l = veorq_u8(t2t3_tmp, t2t3_h);
+
+    // De-interleave
+#if defined(__aarch64__)
+    uint8x16_t t0 = vreinterpretq_u8_u64(
+        vuzp1q_u64(vreinterpretq_u64_u8(t0t1_l), vreinterpretq_u64_u8(t0t1_h)));
+    uint8x16_t t1 = vreinterpretq_u8_u64(
+        vuzp2q_u64(vreinterpretq_u64_u8(t0t1_l), vreinterpretq_u64_u8(t0t1_h)));
+    uint8x16_t t2 = vreinterpretq_u8_u64(
+        vuzp1q_u64(vreinterpretq_u64_u8(t2t3_l), vreinterpretq_u64_u8(t2t3_h)));
+    uint8x16_t t3 = vreinterpretq_u8_u64(
+        vuzp2q_u64(vreinterpretq_u64_u8(t2t3_l), vreinterpretq_u64_u8(t2t3_h)));
+#else
+    uint8x16_t t1 = vcombine_u8(vget_high_u8(t0t1_l), vget_high_u8(t0t1_h));
+    uint8x16_t t0 = vcombine_u8(vget_low_u8(t0t1_l), vget_low_u8(t0t1_h));
+    uint8x16_t t3 = vcombine_u8(vget_high_u8(t2t3_l), vget_high_u8(t2t3_h));
+    uint8x16_t t2 = vcombine_u8(vget_low_u8(t2t3_l), vget_low_u8(t2t3_h));
+#endif
+    // Shift the cross products
+    uint8x16_t t0_shift = vextq_u8(t0, t0, 15);  // t0 << 8
+    uint8x16_t t1_shift = vextq_u8(t1, t1, 14);  // t1 << 16
+    uint8x16_t t2_shift = vextq_u8(t2, t2, 13);  // t2 << 24
+    uint8x16_t t3_shift = vextq_u8(t3, t3, 12);  // t3 << 32
+
+    // Accumulate the products
+    uint8x16_t cross1 = veorq_u8(t0_shift, t1_shift);
+    uint8x16_t cross2 = veorq_u8(t2_shift, t3_shift);
+    uint8x16_t mix = veorq_u8(d, cross1);
+    uint8x16_t r = veorq_u8(mix, cross2);
+    return vreinterpretq_u64_u8(r);
+}
+#endif  // ARMv7 polyfill
+
+// C equivalent:
+//   __m128i _mm_shuffle_epi32_default(__m128i a,
+//                                     __constrange(0, 255) int imm) {
+//       __m128i ret;
+//       ret[0] = a[imm        & 0x3];   ret[1] = a[(imm >> 2) & 0x3];
+//       ret[2] = a[(imm >> 4) & 0x03];  ret[3] = a[(imm >> 6) & 0x03];
+//       return ret;
+//   }
+#define _mm_shuffle_epi32_default(a, imm)                                   \
+    vreinterpretq_m128i_s32(vsetq_lane_s32(                                 \
+        vgetq_lane_s32(vreinterpretq_s32_m128i(a), ((imm) >> 6) & 0x3),     \
+        vsetq_lane_s32(                                                     \
+            vgetq_lane_s32(vreinterpretq_s32_m128i(a), ((imm) >> 4) & 0x3), \
+            vsetq_lane_s32(vgetq_lane_s32(vreinterpretq_s32_m128i(a),       \
+                                          ((imm) >> 2) & 0x3),              \
+                           vmovq_n_s32(vgetq_lane_s32(                      \
+                               vreinterpretq_s32_m128i(a), (imm) & (0x3))), \
+                           1),                                              \
+            2),                                                             \
+        3))
+
+// Takes the upper 64 bits of a and places it in the low end of the result
+// Takes the lower 64 bits of a and places it into the high end of the result.
+FORCE_INLINE __m128i _mm_shuffle_epi_1032(__m128i a)
+{
+    int32x2_t a32 = vget_high_s32(vreinterpretq_s32_m128i(a));
+    int32x2_t a10 = vget_low_s32(vreinterpretq_s32_m128i(a));
+    return vreinterpretq_m128i_s32(vcombine_s32(a32, a10));
+}
+
+// takes the lower two 32-bit values from a and swaps them and places in low end
+// of result takes the higher two 32 bit values from a and swaps them and places
+// in high end of result.
+FORCE_INLINE __m128i _mm_shuffle_epi_2301(__m128i a)
+{
+    int32x2_t a01 = vrev64_s32(vget_low_s32(vreinterpretq_s32_m128i(a)));
+    int32x2_t a23 = vrev64_s32(vget_high_s32(vreinterpretq_s32_m128i(a)));
+    return vreinterpretq_m128i_s32(vcombine_s32(a01, a23));
+}
+
+// rotates the least significant 32 bits into the most significant 32 bits, and
+// shifts the rest down
+FORCE_INLINE __m128i _mm_shuffle_epi_0321(__m128i a)
+{
+    return vreinterpretq_m128i_s32(
+        vextq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(a), 1));
+}
+
+// rotates the most significant 32 bits into the least significant 32 bits, and
+// shifts the rest up
+FORCE_INLINE __m128i _mm_shuffle_epi_2103(__m128i a)
+{
+    return vreinterpretq_m128i_s32(
+        vextq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(a), 3));
+}
+
+// gets the lower 64 bits of a, and places it in the upper 64 bits
+// gets the lower 64 bits of a and places it in the lower 64 bits
+FORCE_INLINE __m128i _mm_shuffle_epi_1010(__m128i a)
+{
+    int32x2_t a10 = vget_low_s32(vreinterpretq_s32_m128i(a));
+    return vreinterpretq_m128i_s32(vcombine_s32(a10, a10));
+}
+
+// gets the lower 64 bits of a, swaps the 0 and 1 elements, and places it in the
+// lower 64 bits gets the lower 64 bits of a, and places it in the upper 64 bits
+FORCE_INLINE __m128i _mm_shuffle_epi_1001(__m128i a)
+{
+    int32x2_t a01 = vrev64_s32(vget_low_s32(vreinterpretq_s32_m128i(a)));
+    int32x2_t a10 = vget_low_s32(vreinterpretq_s32_m128i(a));
+    return vreinterpretq_m128i_s32(vcombine_s32(a01, a10));
+}
+
+// gets the lower 64 bits of a, swaps the 0 and 1 elements and places it in the
+// upper 64 bits gets the lower 64 bits of a, swaps the 0 and 1 elements, and
+// places it in the lower 64 bits
+FORCE_INLINE __m128i _mm_shuffle_epi_0101(__m128i a)
+{
+    int32x2_t a01 = vrev64_s32(vget_low_s32(vreinterpretq_s32_m128i(a)));
+    return vreinterpretq_m128i_s32(vcombine_s32(a01, a01));
+}
+
+FORCE_INLINE __m128i _mm_shuffle_epi_2211(__m128i a)
+{
+    int32x2_t a11 = vdup_lane_s32(vget_low_s32(vreinterpretq_s32_m128i(a)), 1);
+    int32x2_t a22 = vdup_lane_s32(vget_high_s32(vreinterpretq_s32_m128i(a)), 0);
+    return vreinterpretq_m128i_s32(vcombine_s32(a11, a22));
+}
+
+FORCE_INLINE __m128i _mm_shuffle_epi_0122(__m128i a)
+{
+    int32x2_t a22 = vdup_lane_s32(vget_high_s32(vreinterpretq_s32_m128i(a)), 0);
+    int32x2_t a01 = vrev64_s32(vget_low_s32(vreinterpretq_s32_m128i(a)));
+    return vreinterpretq_m128i_s32(vcombine_s32(a22, a01));
+}
+
+FORCE_INLINE __m128i _mm_shuffle_epi_3332(__m128i a)
+{
+    int32x2_t a32 = vget_high_s32(vreinterpretq_s32_m128i(a));
+    int32x2_t a33 = vdup_lane_s32(vget_high_s32(vreinterpretq_s32_m128i(a)), 1);
+    return vreinterpretq_m128i_s32(vcombine_s32(a32, a33));
+}
+
+#if defined(__aarch64__) || defined(_M_ARM64)
+#define _mm_shuffle_epi32_splat(a, imm) \
+    vreinterpretq_m128i_s32(vdupq_laneq_s32(vreinterpretq_s32_m128i(a), (imm)))
+#else
+#define _mm_shuffle_epi32_splat(a, imm) \
+    vreinterpretq_m128i_s32(            \
+        vdupq_n_s32(vgetq_lane_s32(vreinterpretq_s32_m128i(a), (imm))))
+#endif
+
+// NEON does not support a general purpose permute intrinsic.
+// Shuffle single-precision (32-bit) floating-point elements in a using the
+// control in imm8, and store the results in dst.
+//
+// C equivalent:
+//   __m128 _mm_shuffle_ps_default(__m128 a, __m128 b,
+//                                 __constrange(0, 255) int imm) {
+//       __m128 ret;
+//       ret[0] = a[imm        & 0x3];   ret[1] = a[(imm >> 2) & 0x3];
+//       ret[2] = b[(imm >> 4) & 0x03];  ret[3] = b[(imm >> 6) & 0x03];
+//       return ret;
+//   }
+//
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_shuffle_ps
+#define _mm_shuffle_ps_default(a, b, imm)                                      \
+    vreinterpretq_m128_f32(vsetq_lane_f32(                                     \
+        vgetq_lane_f32(vreinterpretq_f32_m128(b), ((imm) >> 6) & 0x3),         \
+        vsetq_lane_f32(                                                        \
+            vgetq_lane_f32(vreinterpretq_f32_m128(b), ((imm) >> 4) & 0x3),     \
+            vsetq_lane_f32(                                                    \
+                vgetq_lane_f32(vreinterpretq_f32_m128(a), ((imm) >> 2) & 0x3), \
+                vmovq_n_f32(                                                   \
+                    vgetq_lane_f32(vreinterpretq_f32_m128(a), (imm) & (0x3))), \
+                1),                                                            \
+            2),                                                                \
+        3))
+
+// Shuffle 16-bit integers in the low 64 bits of a using the control in imm8.
+// Store the results in the low 64 bits of dst, with the high 64 bits being
+// copied from a to dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_shufflelo_epi16
+#define _mm_shufflelo_epi16_function(a, imm)                                  \
+    _sse2neon_define1(                                                        \
+        __m128i, a, int16x8_t ret = vreinterpretq_s16_m128i(_a);              \
+        int16x4_t lowBits = vget_low_s16(ret);                                \
+        ret = vsetq_lane_s16(vget_lane_s16(lowBits, (imm) & (0x3)), ret, 0);  \
+        ret = vsetq_lane_s16(vget_lane_s16(lowBits, ((imm) >> 2) & 0x3), ret, \
+                             1);                                              \
+        ret = vsetq_lane_s16(vget_lane_s16(lowBits, ((imm) >> 4) & 0x3), ret, \
+                             2);                                              \
+        ret = vsetq_lane_s16(vget_lane_s16(lowBits, ((imm) >> 6) & 0x3), ret, \
+                             3);                                              \
+        _sse2neon_return(vreinterpretq_m128i_s16(ret));)
+
+// Shuffle 16-bit integers in the high 64 bits of a using the control in imm8.
+// Store the results in the high 64 bits of dst, with the low 64 bits being
+// copied from a to dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_shufflehi_epi16
+#define _mm_shufflehi_epi16_function(a, imm)                                   \
+    _sse2neon_define1(                                                         \
+        __m128i, a, int16x8_t ret = vreinterpretq_s16_m128i(_a);               \
+        int16x4_t highBits = vget_high_s16(ret);                               \
+        ret = vsetq_lane_s16(vget_lane_s16(highBits, (imm) & (0x3)), ret, 4);  \
+        ret = vsetq_lane_s16(vget_lane_s16(highBits, ((imm) >> 2) & 0x3), ret, \
+                             5);                                               \
+        ret = vsetq_lane_s16(vget_lane_s16(highBits, ((imm) >> 4) & 0x3), ret, \
+                             6);                                               \
+        ret = vsetq_lane_s16(vget_lane_s16(highBits, ((imm) >> 6) & 0x3), ret, \
+                             7);                                               \
+        _sse2neon_return(vreinterpretq_m128i_s16(ret));)
+
+/* MMX */
+
+//_mm_empty is a no-op on arm
+FORCE_INLINE void _mm_empty(void) {}
+
+/* SSE */
+
+// Add packed single-precision (32-bit) floating-point elements in a and b, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_add_ps
+FORCE_INLINE __m128 _mm_add_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_f32(
+        vaddq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+}
+
+// Add the lower single-precision (32-bit) floating-point element in a and b,
+// store the result in the lower element of dst, and copy the upper 3 packed
+// elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_add_ss
+FORCE_INLINE __m128 _mm_add_ss(__m128 a, __m128 b)
+{
+    float32_t b0 = vgetq_lane_f32(vreinterpretq_f32_m128(b), 0);
+    float32x4_t value = vsetq_lane_f32(b0, vdupq_n_f32(0), 0);
+    // the upper values in the result must be the remnants of <a>.
+    return vreinterpretq_m128_f32(vaddq_f32(a, value));
+}
+
+// Compute the bitwise AND of packed single-precision (32-bit) floating-point
+// elements in a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_and_ps
+FORCE_INLINE __m128 _mm_and_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_s32(
+        vandq_s32(vreinterpretq_s32_m128(a), vreinterpretq_s32_m128(b)));
+}
+
+// Compute the bitwise NOT of packed single-precision (32-bit) floating-point
+// elements in a and then AND with b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_andnot_ps
+FORCE_INLINE __m128 _mm_andnot_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_s32(
+        vbicq_s32(vreinterpretq_s32_m128(b),
+                  vreinterpretq_s32_m128(a)));  // *NOTE* argument swap
+}
+
+// Average packed unsigned 16-bit integers in a and b, and store the results in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_avg_pu16
+FORCE_INLINE __m64 _mm_avg_pu16(__m64 a, __m64 b)
+{
+    return vreinterpret_m64_u16(
+        vrhadd_u16(vreinterpret_u16_m64(a), vreinterpret_u16_m64(b)));
+}
+
+// Average packed unsigned 8-bit integers in a and b, and store the results in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_avg_pu8
+FORCE_INLINE __m64 _mm_avg_pu8(__m64 a, __m64 b)
+{
+    return vreinterpret_m64_u8(
+        vrhadd_u8(vreinterpret_u8_m64(a), vreinterpret_u8_m64(b)));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b
+// for equality, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpeq_ps
+FORCE_INLINE __m128 _mm_cmpeq_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_u32(
+        vceqq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b for equality, store the result in the lower element of dst, and copy the
+// upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpeq_ss
+FORCE_INLINE __m128 _mm_cmpeq_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_cmpeq_ps(a, b));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b
+// for greater-than-or-equal, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpge_ps
+FORCE_INLINE __m128 _mm_cmpge_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_u32(
+        vcgeq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b for greater-than-or-equal, store the result in the lower element of dst,
+// and copy the upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpge_ss
+FORCE_INLINE __m128 _mm_cmpge_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_cmpge_ps(a, b));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b
+// for greater-than, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpgt_ps
+FORCE_INLINE __m128 _mm_cmpgt_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_u32(
+        vcgtq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b for greater-than, store the result in the lower element of dst, and copy
+// the upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpgt_ss
+FORCE_INLINE __m128 _mm_cmpgt_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_cmpgt_ps(a, b));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b
+// for less-than-or-equal, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmple_ps
+FORCE_INLINE __m128 _mm_cmple_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_u32(
+        vcleq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b for less-than-or-equal, store the result in the lower element of dst, and
+// copy the upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmple_ss
+FORCE_INLINE __m128 _mm_cmple_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_cmple_ps(a, b));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b
+// for less-than, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmplt_ps
+FORCE_INLINE __m128 _mm_cmplt_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_u32(
+        vcltq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b for less-than, store the result in the lower element of dst, and copy the
+// upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmplt_ss
+FORCE_INLINE __m128 _mm_cmplt_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_cmplt_ps(a, b));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b
+// for not-equal, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpneq_ps
+FORCE_INLINE __m128 _mm_cmpneq_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_u32(vmvnq_u32(
+        vceqq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b))));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b for not-equal, store the result in the lower element of dst, and copy the
+// upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpneq_ss
+FORCE_INLINE __m128 _mm_cmpneq_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_cmpneq_ps(a, b));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b
+// for not-greater-than-or-equal, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpnge_ps
+FORCE_INLINE __m128 _mm_cmpnge_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_u32(vmvnq_u32(
+        vcgeq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b))));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b for not-greater-than-or-equal, store the result in the lower element of
+// dst, and copy the upper 3 packed elements from a to the upper elements of
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpnge_ss
+FORCE_INLINE __m128 _mm_cmpnge_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_cmpnge_ps(a, b));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b
+// for not-greater-than, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpngt_ps
+FORCE_INLINE __m128 _mm_cmpngt_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_u32(vmvnq_u32(
+        vcgtq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b))));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b for not-greater-than, store the result in the lower element of dst, and
+// copy the upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpngt_ss
+FORCE_INLINE __m128 _mm_cmpngt_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_cmpngt_ps(a, b));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b
+// for not-less-than-or-equal, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpnle_ps
+FORCE_INLINE __m128 _mm_cmpnle_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_u32(vmvnq_u32(
+        vcleq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b))));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b for not-less-than-or-equal, store the result in the lower element of dst,
+// and copy the upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpnle_ss
+FORCE_INLINE __m128 _mm_cmpnle_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_cmpnle_ps(a, b));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b
+// for not-less-than, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpnlt_ps
+FORCE_INLINE __m128 _mm_cmpnlt_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_u32(vmvnq_u32(
+        vcltq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b))));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b for not-less-than, store the result in the lower element of dst, and copy
+// the upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpnlt_ss
+FORCE_INLINE __m128 _mm_cmpnlt_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_cmpnlt_ps(a, b));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b
+// to see if neither is NaN, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpord_ps
+//
+// See also:
+// http://stackoverflow.com/questions/8627331/what-does-ordered-unordered-comparison-mean
+// http://stackoverflow.com/questions/29349621/neon-isnanval-intrinsics
+FORCE_INLINE __m128 _mm_cmpord_ps(__m128 a, __m128 b)
+{
+    // Note: NEON does not have ordered compare builtin
+    // Need to compare a eq a and b eq b to check for NaN
+    // Do AND of results to get final
+    uint32x4_t ceqaa =
+        vceqq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(a));
+    uint32x4_t ceqbb =
+        vceqq_f32(vreinterpretq_f32_m128(b), vreinterpretq_f32_m128(b));
+    return vreinterpretq_m128_u32(vandq_u32(ceqaa, ceqbb));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b to see if neither is NaN, store the result in the lower element of dst, and
+// copy the upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpord_ss
+FORCE_INLINE __m128 _mm_cmpord_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_cmpord_ps(a, b));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b
+// to see if either is NaN, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpunord_ps
+FORCE_INLINE __m128 _mm_cmpunord_ps(__m128 a, __m128 b)
+{
+    uint32x4_t f32a =
+        vceqq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(a));
+    uint32x4_t f32b =
+        vceqq_f32(vreinterpretq_f32_m128(b), vreinterpretq_f32_m128(b));
+    return vreinterpretq_m128_u32(vmvnq_u32(vandq_u32(f32a, f32b)));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b to see if either is NaN, store the result in the lower element of dst, and
+// copy the upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpunord_ss
+FORCE_INLINE __m128 _mm_cmpunord_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_cmpunord_ps(a, b));
+}
+
+// Compare the lower single-precision (32-bit) floating-point element in a and b
+// for equality, and return the boolean result (0 or 1).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_comieq_ss
+FORCE_INLINE int _mm_comieq_ss(__m128 a, __m128 b)
+{
+    uint32x4_t a_eq_b =
+        vceqq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b));
+    return vgetq_lane_u32(a_eq_b, 0) & 0x1;
+}
+
+// Compare the lower single-precision (32-bit) floating-point element in a and b
+// for greater-than-or-equal, and return the boolean result (0 or 1).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_comige_ss
+FORCE_INLINE int _mm_comige_ss(__m128 a, __m128 b)
+{
+    uint32x4_t a_ge_b =
+        vcgeq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b));
+    return vgetq_lane_u32(a_ge_b, 0) & 0x1;
+}
+
+// Compare the lower single-precision (32-bit) floating-point element in a and b
+// for greater-than, and return the boolean result (0 or 1).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_comigt_ss
+FORCE_INLINE int _mm_comigt_ss(__m128 a, __m128 b)
+{
+    uint32x4_t a_gt_b =
+        vcgtq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b));
+    return vgetq_lane_u32(a_gt_b, 0) & 0x1;
+}
+
+// Compare the lower single-precision (32-bit) floating-point element in a and b
+// for less-than-or-equal, and return the boolean result (0 or 1).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_comile_ss
+FORCE_INLINE int _mm_comile_ss(__m128 a, __m128 b)
+{
+    uint32x4_t a_le_b =
+        vcleq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b));
+    return vgetq_lane_u32(a_le_b, 0) & 0x1;
+}
+
+// Compare the lower single-precision (32-bit) floating-point element in a and b
+// for less-than, and return the boolean result (0 or 1).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_comilt_ss
+FORCE_INLINE int _mm_comilt_ss(__m128 a, __m128 b)
+{
+    uint32x4_t a_lt_b =
+        vcltq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b));
+    return vgetq_lane_u32(a_lt_b, 0) & 0x1;
+}
+
+// Compare the lower single-precision (32-bit) floating-point element in a and b
+// for not-equal, and return the boolean result (0 or 1).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_comineq_ss
+FORCE_INLINE int _mm_comineq_ss(__m128 a, __m128 b)
+{
+    return !_mm_comieq_ss(a, b);
+}
+
+// Convert packed signed 32-bit integers in b to packed single-precision
+// (32-bit) floating-point elements, store the results in the lower 2 elements
+// of dst, and copy the upper 2 packed elements from a to the upper elements of
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvt_pi2ps
+FORCE_INLINE __m128 _mm_cvt_pi2ps(__m128 a, __m64 b)
+{
+    return vreinterpretq_m128_f32(
+        vcombine_f32(vcvt_f32_s32(vreinterpret_s32_m64(b)),
+                     vget_high_f32(vreinterpretq_f32_m128(a))));
+}
+
+// Convert packed single-precision (32-bit) floating-point elements in a to
+// packed 32-bit integers, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvt_ps2pi
+FORCE_INLINE __m64 _mm_cvt_ps2pi(__m128 a)
+{
+#if (defined(__aarch64__) || defined(_M_ARM64)) || \
+    defined(__ARM_FEATURE_DIRECTED_ROUNDING)
+    return vreinterpret_m64_s32(
+        vget_low_s32(vcvtnq_s32_f32(vrndiq_f32(vreinterpretq_f32_m128(a)))));
+#else
+    return vreinterpret_m64_s32(vcvt_s32_f32(vget_low_f32(
+        vreinterpretq_f32_m128(_mm_round_ps(a, _MM_FROUND_CUR_DIRECTION)))));
+#endif
+}
+
+// Convert the signed 32-bit integer b to a single-precision (32-bit)
+// floating-point element, store the result in the lower element of dst, and
+// copy the upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvt_si2ss
+FORCE_INLINE __m128 _mm_cvt_si2ss(__m128 a, int b)
+{
+    return vreinterpretq_m128_f32(
+        vsetq_lane_f32((float) b, vreinterpretq_f32_m128(a), 0));
+}
+
+// Convert the lower single-precision (32-bit) floating-point element in a to a
+// 32-bit integer, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvt_ss2si
+FORCE_INLINE int _mm_cvt_ss2si(__m128 a)
+{
+#if (defined(__aarch64__) || defined(_M_ARM64)) || \
+    defined(__ARM_FEATURE_DIRECTED_ROUNDING)
+    return vgetq_lane_s32(vcvtnq_s32_f32(vrndiq_f32(vreinterpretq_f32_m128(a))),
+                          0);
+#else
+    float32_t data = vgetq_lane_f32(
+        vreinterpretq_f32_m128(_mm_round_ps(a, _MM_FROUND_CUR_DIRECTION)), 0);
+    return (int32_t) data;
+#endif
+}
+
+// Convert packed 16-bit integers in a to packed single-precision (32-bit)
+// floating-point elements, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtpi16_ps
+FORCE_INLINE __m128 _mm_cvtpi16_ps(__m64 a)
+{
+    return vreinterpretq_m128_f32(
+        vcvtq_f32_s32(vmovl_s16(vreinterpret_s16_m64(a))));
+}
+
+// Convert packed 32-bit integers in b to packed single-precision (32-bit)
+// floating-point elements, store the results in the lower 2 elements of dst,
+// and copy the upper 2 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtpi32_ps
+FORCE_INLINE __m128 _mm_cvtpi32_ps(__m128 a, __m64 b)
+{
+    return vreinterpretq_m128_f32(
+        vcombine_f32(vcvt_f32_s32(vreinterpret_s32_m64(b)),
+                     vget_high_f32(vreinterpretq_f32_m128(a))));
+}
+
+// Convert packed signed 32-bit integers in a to packed single-precision
+// (32-bit) floating-point elements, store the results in the lower 2 elements
+// of dst, then convert the packed signed 32-bit integers in b to
+// single-precision (32-bit) floating-point element, and store the results in
+// the upper 2 elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtpi32x2_ps
+FORCE_INLINE __m128 _mm_cvtpi32x2_ps(__m64 a, __m64 b)
+{
+    return vreinterpretq_m128_f32(vcvtq_f32_s32(
+        vcombine_s32(vreinterpret_s32_m64(a), vreinterpret_s32_m64(b))));
+}
+
+// Convert the lower packed 8-bit integers in a to packed single-precision
+// (32-bit) floating-point elements, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtpi8_ps
+FORCE_INLINE __m128 _mm_cvtpi8_ps(__m64 a)
+{
+    return vreinterpretq_m128_f32(vcvtq_f32_s32(
+        vmovl_s16(vget_low_s16(vmovl_s8(vreinterpret_s8_m64(a))))));
+}
+
+// Convert packed single-precision (32-bit) floating-point elements in a to
+// packed 16-bit integers, and store the results in dst. Note: this intrinsic
+// will generate 0x7FFF, rather than 0x8000, for input values between 0x7FFF and
+// 0x7FFFFFFF.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtps_pi16
+FORCE_INLINE __m64 _mm_cvtps_pi16(__m128 a)
+{
+    return vreinterpret_m64_s16(
+        vqmovn_s32(vreinterpretq_s32_m128i(_mm_cvtps_epi32(a))));
+}
+
+// Convert packed single-precision (32-bit) floating-point elements in a to
+// packed 32-bit integers, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtps_pi32
+#define _mm_cvtps_pi32(a) _mm_cvt_ps2pi(a)
+
+// Convert packed single-precision (32-bit) floating-point elements in a to
+// packed 8-bit integers, and store the results in lower 4 elements of dst.
+// Note: this intrinsic will generate 0x7F, rather than 0x80, for input values
+// between 0x7F and 0x7FFFFFFF.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtps_pi8
+FORCE_INLINE __m64 _mm_cvtps_pi8(__m128 a)
+{
+    return vreinterpret_m64_s8(vqmovn_s16(
+        vcombine_s16(vreinterpret_s16_m64(_mm_cvtps_pi16(a)), vdup_n_s16(0))));
+}
+
+// Convert packed unsigned 16-bit integers in a to packed single-precision
+// (32-bit) floating-point elements, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtpu16_ps
+FORCE_INLINE __m128 _mm_cvtpu16_ps(__m64 a)
+{
+    return vreinterpretq_m128_f32(
+        vcvtq_f32_u32(vmovl_u16(vreinterpret_u16_m64(a))));
+}
+
+// Convert the lower packed unsigned 8-bit integers in a to packed
+// single-precision (32-bit) floating-point elements, and store the results in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtpu8_ps
+FORCE_INLINE __m128 _mm_cvtpu8_ps(__m64 a)
+{
+    return vreinterpretq_m128_f32(vcvtq_f32_u32(
+        vmovl_u16(vget_low_u16(vmovl_u8(vreinterpret_u8_m64(a))))));
+}
+
+// Convert the signed 32-bit integer b to a single-precision (32-bit)
+// floating-point element, store the result in the lower element of dst, and
+// copy the upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsi32_ss
+#define _mm_cvtsi32_ss(a, b) _mm_cvt_si2ss(a, b)
+
+// Convert the signed 64-bit integer b to a single-precision (32-bit)
+// floating-point element, store the result in the lower element of dst, and
+// copy the upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsi64_ss
+FORCE_INLINE __m128 _mm_cvtsi64_ss(__m128 a, int64_t b)
+{
+    return vreinterpretq_m128_f32(
+        vsetq_lane_f32((float) b, vreinterpretq_f32_m128(a), 0));
+}
+
+// Copy the lower single-precision (32-bit) floating-point element of a to dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtss_f32
+FORCE_INLINE float _mm_cvtss_f32(__m128 a)
+{
+    return vgetq_lane_f32(vreinterpretq_f32_m128(a), 0);
+}
+
+// Convert the lower single-precision (32-bit) floating-point element in a to a
+// 32-bit integer, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtss_si32
+#define _mm_cvtss_si32(a) _mm_cvt_ss2si(a)
+
+// Convert the lower single-precision (32-bit) floating-point element in a to a
+// 64-bit integer, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtss_si64
+FORCE_INLINE int64_t _mm_cvtss_si64(__m128 a)
+{
+#if (defined(__aarch64__) || defined(_M_ARM64)) || \
+    defined(__ARM_FEATURE_DIRECTED_ROUNDING)
+    return (int64_t) vgetq_lane_f32(vrndiq_f32(vreinterpretq_f32_m128(a)), 0);
+#else
+    float32_t data = vgetq_lane_f32(
+        vreinterpretq_f32_m128(_mm_round_ps(a, _MM_FROUND_CUR_DIRECTION)), 0);
+    return (int64_t) data;
+#endif
+}
+
+// Convert packed single-precision (32-bit) floating-point elements in a to
+// packed 32-bit integers with truncation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtt_ps2pi
+FORCE_INLINE __m64 _mm_cvtt_ps2pi(__m128 a)
+{
+    return vreinterpret_m64_s32(
+        vget_low_s32(vcvtq_s32_f32(vreinterpretq_f32_m128(a))));
+}
+
+// Convert the lower single-precision (32-bit) floating-point element in a to a
+// 32-bit integer with truncation, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtt_ss2si
+FORCE_INLINE int _mm_cvtt_ss2si(__m128 a)
+{
+    return vgetq_lane_s32(vcvtq_s32_f32(vreinterpretq_f32_m128(a)), 0);
+}
+
+// Convert packed single-precision (32-bit) floating-point elements in a to
+// packed 32-bit integers with truncation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvttps_pi32
+#define _mm_cvttps_pi32(a) _mm_cvtt_ps2pi(a)
+
+// Convert the lower single-precision (32-bit) floating-point element in a to a
+// 32-bit integer with truncation, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvttss_si32
+#define _mm_cvttss_si32(a) _mm_cvtt_ss2si(a)
+
+// Convert the lower single-precision (32-bit) floating-point element in a to a
+// 64-bit integer with truncation, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvttss_si64
+FORCE_INLINE int64_t _mm_cvttss_si64(__m128 a)
+{
+    return (int64_t) vgetq_lane_f32(vreinterpretq_f32_m128(a), 0);
+}
+
+// Divide packed single-precision (32-bit) floating-point elements in a by
+// packed elements in b, and store the results in dst.
+// Due to ARMv7-A NEON's lack of a precise division intrinsic, we implement
+// division by multiplying a by b's reciprocal before using the Newton-Raphson
+// method to approximate the results.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_div_ps
+FORCE_INLINE __m128 _mm_div_ps(__m128 a, __m128 b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128_f32(
+        vdivq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+#else
+    float32x4_t recip = vrecpeq_f32(vreinterpretq_f32_m128(b));
+    recip = vmulq_f32(recip, vrecpsq_f32(recip, vreinterpretq_f32_m128(b)));
+    // Additional Netwon-Raphson iteration for accuracy
+    recip = vmulq_f32(recip, vrecpsq_f32(recip, vreinterpretq_f32_m128(b)));
+    return vreinterpretq_m128_f32(vmulq_f32(vreinterpretq_f32_m128(a), recip));
+#endif
+}
+
+// Divide the lower single-precision (32-bit) floating-point element in a by the
+// lower single-precision (32-bit) floating-point element in b, store the result
+// in the lower element of dst, and copy the upper 3 packed elements from a to
+// the upper elements of dst.
+// Warning: ARMv7-A does not produce the same result compared to Intel and not
+// IEEE-compliant.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_div_ss
+FORCE_INLINE __m128 _mm_div_ss(__m128 a, __m128 b)
+{
+    float32_t value =
+        vgetq_lane_f32(vreinterpretq_f32_m128(_mm_div_ps(a, b)), 0);
+    return vreinterpretq_m128_f32(
+        vsetq_lane_f32(value, vreinterpretq_f32_m128(a), 0));
+}
+
+// Extract a 16-bit integer from a, selected with imm8, and store the result in
+// the lower element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_extract_pi16
+#define _mm_extract_pi16(a, imm) \
+    (int32_t) vget_lane_u16(vreinterpret_u16_m64(a), (imm))
+
+// Free aligned memory that was allocated with _mm_malloc.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_free
+#if !defined(SSE2NEON_ALLOC_DEFINED)
+FORCE_INLINE void _mm_free(void *addr)
+{
+    free(addr);
+}
+#endif
+
+FORCE_INLINE uint64_t _sse2neon_get_fpcr(void)
+{
+    uint64_t value;
+#if defined(_MSC_VER) && !defined(__clang__)
+    value = _ReadStatusReg(ARM64_FPCR);
+#else
+    __asm__ __volatile__("mrs %0, FPCR" : "=r"(value)); /* read */
+#endif
+    return value;
+}
+
+FORCE_INLINE void _sse2neon_set_fpcr(uint64_t value)
+{
+#if defined(_MSC_VER) && !defined(__clang__)
+    _WriteStatusReg(ARM64_FPCR, value);
+#else
+    __asm__ __volatile__("msr FPCR, %0" ::"r"(value));  /* write */
+#endif
+}
+
+// Macro: Get the flush zero bits from the MXCSR control and status register.
+// The flush zero may contain any of the following flags: _MM_FLUSH_ZERO_ON or
+// _MM_FLUSH_ZERO_OFF
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_MM_GET_FLUSH_ZERO_MODE
+FORCE_INLINE unsigned int _sse2neon_mm_get_flush_zero_mode(void)
+{
+    union {
+        fpcr_bitfield field;
+#if defined(__aarch64__) || defined(_M_ARM64)
+        uint64_t value;
+#else
+        uint32_t value;
+#endif
+    } r;
+
+#if defined(__aarch64__) || defined(_M_ARM64)
+    r.value = _sse2neon_get_fpcr();
+#else
+    __asm__ __volatile__("vmrs %0, FPSCR" : "=r"(r.value)); /* read */
+#endif
+
+    return r.field.bit24 ? _MM_FLUSH_ZERO_ON : _MM_FLUSH_ZERO_OFF;
+}
+
+// Macro: Get the rounding mode bits from the MXCSR control and status register.
+// The rounding mode may contain any of the following flags: _MM_ROUND_NEAREST,
+// _MM_ROUND_DOWN, _MM_ROUND_UP, _MM_ROUND_TOWARD_ZERO
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_MM_GET_ROUNDING_MODE
+FORCE_INLINE unsigned int _MM_GET_ROUNDING_MODE(void)
+{
+    union {
+        fpcr_bitfield field;
+#if defined(__aarch64__) || defined(_M_ARM64)
+        uint64_t value;
+#else
+        uint32_t value;
+#endif
+    } r;
+
+#if defined(__aarch64__) || defined(_M_ARM64)
+    r.value = _sse2neon_get_fpcr();
+#else
+    __asm__ __volatile__("vmrs %0, FPSCR" : "=r"(r.value)); /* read */
+#endif
+
+    if (r.field.bit22) {
+        return r.field.bit23 ? _MM_ROUND_TOWARD_ZERO : _MM_ROUND_UP;
+    } else {
+        return r.field.bit23 ? _MM_ROUND_DOWN : _MM_ROUND_NEAREST;
+    }
+}
+
+// Copy a to dst, and insert the 16-bit integer i into dst at the location
+// specified by imm8.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_insert_pi16
+#define _mm_insert_pi16(a, b, imm) \
+    vreinterpret_m64_s16(vset_lane_s16((b), vreinterpret_s16_m64(a), (imm)))
+
+// Load 128-bits (composed of 4 packed single-precision (32-bit) floating-point
+// elements) from memory into dst. mem_addr must be aligned on a 16-byte
+// boundary or a general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_load_ps
+FORCE_INLINE __m128 _mm_load_ps(const float *p)
+{
+    return vreinterpretq_m128_f32(vld1q_f32(p));
+}
+
+// Load a single-precision (32-bit) floating-point element from memory into all
+// elements of dst.
+//
+//   dst[31:0] := MEM[mem_addr+31:mem_addr]
+//   dst[63:32] := MEM[mem_addr+31:mem_addr]
+//   dst[95:64] := MEM[mem_addr+31:mem_addr]
+//   dst[127:96] := MEM[mem_addr+31:mem_addr]
+//
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_load_ps1
+#define _mm_load_ps1 _mm_load1_ps
+
+// Load a single-precision (32-bit) floating-point element from memory into the
+// lower of dst, and zero the upper 3 elements. mem_addr does not need to be
+// aligned on any particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_load_ss
+FORCE_INLINE __m128 _mm_load_ss(const float *p)
+{
+    return vreinterpretq_m128_f32(vsetq_lane_f32(*p, vdupq_n_f32(0), 0));
+}
+
+// Load a single-precision (32-bit) floating-point element from memory into all
+// elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_load1_ps
+FORCE_INLINE __m128 _mm_load1_ps(const float *p)
+{
+    return vreinterpretq_m128_f32(vld1q_dup_f32(p));
+}
+
+// Load 2 single-precision (32-bit) floating-point elements from memory into the
+// upper 2 elements of dst, and copy the lower 2 elements from a to dst.
+// mem_addr does not need to be aligned on any particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadh_pi
+FORCE_INLINE __m128 _mm_loadh_pi(__m128 a, __m64 const *p)
+{
+    return vreinterpretq_m128_f32(
+        vcombine_f32(vget_low_f32(a), vld1_f32((const float32_t *) p)));
+}
+
+// Load 2 single-precision (32-bit) floating-point elements from memory into the
+// lower 2 elements of dst, and copy the upper 2 elements from a to dst.
+// mem_addr does not need to be aligned on any particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadl_pi
+FORCE_INLINE __m128 _mm_loadl_pi(__m128 a, __m64 const *p)
+{
+    return vreinterpretq_m128_f32(
+        vcombine_f32(vld1_f32((const float32_t *) p), vget_high_f32(a)));
+}
+
+// Load 4 single-precision (32-bit) floating-point elements from memory into dst
+// in reverse order. mem_addr must be aligned on a 16-byte boundary or a
+// general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadr_ps
+FORCE_INLINE __m128 _mm_loadr_ps(const float *p)
+{
+    float32x4_t v = vrev64q_f32(vld1q_f32(p));
+    return vreinterpretq_m128_f32(vextq_f32(v, v, 2));
+}
+
+// Load 128-bits (composed of 4 packed single-precision (32-bit) floating-point
+// elements) from memory into dst. mem_addr does not need to be aligned on any
+// particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadu_ps
+FORCE_INLINE __m128 _mm_loadu_ps(const float *p)
+{
+    // for neon, alignment doesn't matter, so _mm_load_ps and _mm_loadu_ps are
+    // equivalent for neon
+    return vreinterpretq_m128_f32(vld1q_f32(p));
+}
+
+// Load unaligned 16-bit integer from memory into the first element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadu_si16
+FORCE_INLINE __m128i _mm_loadu_si16(const void *p)
+{
+    return vreinterpretq_m128i_s16(
+        vsetq_lane_s16(*(const unaligned_int16_t *) p, vdupq_n_s16(0), 0));
+}
+
+// Load unaligned 64-bit integer from memory into the first element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadu_si64
+FORCE_INLINE __m128i _mm_loadu_si64(const void *p)
+{
+    return vreinterpretq_m128i_s64(
+        vsetq_lane_s64(*(const unaligned_int64_t *) p, vdupq_n_s64(0), 0));
+}
+
+// Allocate size bytes of memory, aligned to the alignment specified in align,
+// and return a pointer to the allocated memory. _mm_free should be used to free
+// memory that is allocated with _mm_malloc.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_malloc
+#if !defined(SSE2NEON_ALLOC_DEFINED)
+FORCE_INLINE void *_mm_malloc(size_t size, size_t align)
+{
+    void *ptr;
+    if (align == 1)
+        return malloc(size);
+    if (align == 2 || (sizeof(void *) == 8 && align == 4))
+        align = sizeof(void *);
+    if (!posix_memalign(&ptr, align, size))
+        return ptr;
+    return NULL;
+}
+#endif
+
+// Conditionally store 8-bit integer elements from a into memory using mask
+// (elements are not stored when the highest bit is not set in the corresponding
+// element) and a non-temporal memory hint.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_maskmove_si64
+FORCE_INLINE void _mm_maskmove_si64(__m64 a, __m64 mask, char *mem_addr)
+{
+    int8x8_t shr_mask = vshr_n_s8(vreinterpret_s8_m64(mask), 7);
+    __m128 b = _mm_load_ps((const float *) mem_addr);
+    int8x8_t masked =
+        vbsl_s8(vreinterpret_u8_s8(shr_mask), vreinterpret_s8_m64(a),
+                vreinterpret_s8_u64(vget_low_u64(vreinterpretq_u64_m128(b))));
+    vst1_s8((int8_t *) mem_addr, masked);
+}
+
+// Conditionally store 8-bit integer elements from a into memory using mask
+// (elements are not stored when the highest bit is not set in the corresponding
+// element) and a non-temporal memory hint.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_m_maskmovq
+#define _m_maskmovq(a, mask, mem_addr) _mm_maskmove_si64(a, mask, mem_addr)
+
+// Compare packed signed 16-bit integers in a and b, and store packed maximum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_pi16
+FORCE_INLINE __m64 _mm_max_pi16(__m64 a, __m64 b)
+{
+    return vreinterpret_m64_s16(
+        vmax_s16(vreinterpret_s16_m64(a), vreinterpret_s16_m64(b)));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b,
+// and store packed maximum values in dst. dst does not follow the IEEE Standard
+// for Floating-Point Arithmetic (IEEE 754) maximum value when inputs are NaN or
+// signed-zero values.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_ps
+FORCE_INLINE __m128 _mm_max_ps(__m128 a, __m128 b)
+{
+#if SSE2NEON_PRECISE_MINMAX
+    float32x4_t _a = vreinterpretq_f32_m128(a);
+    float32x4_t _b = vreinterpretq_f32_m128(b);
+    return vreinterpretq_m128_f32(vbslq_f32(vcgtq_f32(_a, _b), _a, _b));
+#else
+    return vreinterpretq_m128_f32(
+        vmaxq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+#endif
+}
+
+// Compare packed unsigned 8-bit integers in a and b, and store packed maximum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_pu8
+FORCE_INLINE __m64 _mm_max_pu8(__m64 a, __m64 b)
+{
+    return vreinterpret_m64_u8(
+        vmax_u8(vreinterpret_u8_m64(a), vreinterpret_u8_m64(b)));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b, store the maximum value in the lower element of dst, and copy the upper 3
+// packed elements from a to the upper element of dst. dst does not follow the
+// IEEE Standard for Floating-Point Arithmetic (IEEE 754) maximum value when
+// inputs are NaN or signed-zero values.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_ss
+FORCE_INLINE __m128 _mm_max_ss(__m128 a, __m128 b)
+{
+    float32_t value = vgetq_lane_f32(_mm_max_ps(a, b), 0);
+    return vreinterpretq_m128_f32(
+        vsetq_lane_f32(value, vreinterpretq_f32_m128(a), 0));
+}
+
+// Compare packed signed 16-bit integers in a and b, and store packed minimum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_min_pi16
+FORCE_INLINE __m64 _mm_min_pi16(__m64 a, __m64 b)
+{
+    return vreinterpret_m64_s16(
+        vmin_s16(vreinterpret_s16_m64(a), vreinterpret_s16_m64(b)));
+}
+
+// Compare packed single-precision (32-bit) floating-point elements in a and b,
+// and store packed minimum values in dst. dst does not follow the IEEE Standard
+// for Floating-Point Arithmetic (IEEE 754) minimum value when inputs are NaN or
+// signed-zero values.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_min_ps
+FORCE_INLINE __m128 _mm_min_ps(__m128 a, __m128 b)
+{
+#if SSE2NEON_PRECISE_MINMAX
+    float32x4_t _a = vreinterpretq_f32_m128(a);
+    float32x4_t _b = vreinterpretq_f32_m128(b);
+    return vreinterpretq_m128_f32(vbslq_f32(vcltq_f32(_a, _b), _a, _b));
+#else
+    return vreinterpretq_m128_f32(
+        vminq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+#endif
+}
+
+// Compare packed unsigned 8-bit integers in a and b, and store packed minimum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_min_pu8
+FORCE_INLINE __m64 _mm_min_pu8(__m64 a, __m64 b)
+{
+    return vreinterpret_m64_u8(
+        vmin_u8(vreinterpret_u8_m64(a), vreinterpret_u8_m64(b)));
+}
+
+// Compare the lower single-precision (32-bit) floating-point elements in a and
+// b, store the minimum value in the lower element of dst, and copy the upper 3
+// packed elements from a to the upper element of dst. dst does not follow the
+// IEEE Standard for Floating-Point Arithmetic (IEEE 754) minimum value when
+// inputs are NaN or signed-zero values.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_min_ss
+FORCE_INLINE __m128 _mm_min_ss(__m128 a, __m128 b)
+{
+    float32_t value = vgetq_lane_f32(_mm_min_ps(a, b), 0);
+    return vreinterpretq_m128_f32(
+        vsetq_lane_f32(value, vreinterpretq_f32_m128(a), 0));
+}
+
+// Move the lower single-precision (32-bit) floating-point element from b to the
+// lower element of dst, and copy the upper 3 packed elements from a to the
+// upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_move_ss
+FORCE_INLINE __m128 _mm_move_ss(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_f32(
+        vsetq_lane_f32(vgetq_lane_f32(vreinterpretq_f32_m128(b), 0),
+                       vreinterpretq_f32_m128(a), 0));
+}
+
+// Move the upper 2 single-precision (32-bit) floating-point elements from b to
+// the lower 2 elements of dst, and copy the upper 2 elements from a to the
+// upper 2 elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_movehl_ps
+FORCE_INLINE __m128 _mm_movehl_ps(__m128 a, __m128 b)
+{
+#if defined(aarch64__)
+    return vreinterpretq_m128_u64(
+        vzip2q_u64(vreinterpretq_u64_m128(b), vreinterpretq_u64_m128(a)));
+#else
+    float32x2_t a32 = vget_high_f32(vreinterpretq_f32_m128(a));
+    float32x2_t b32 = vget_high_f32(vreinterpretq_f32_m128(b));
+    return vreinterpretq_m128_f32(vcombine_f32(b32, a32));
+#endif
+}
+
+// Move the lower 2 single-precision (32-bit) floating-point elements from b to
+// the upper 2 elements of dst, and copy the lower 2 elements from a to the
+// lower 2 elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_movelh_ps
+FORCE_INLINE __m128 _mm_movelh_ps(__m128 __A, __m128 __B)
+{
+    float32x2_t a10 = vget_low_f32(vreinterpretq_f32_m128(__A));
+    float32x2_t b10 = vget_low_f32(vreinterpretq_f32_m128(__B));
+    return vreinterpretq_m128_f32(vcombine_f32(a10, b10));
+}
+
+// Create mask from the most significant bit of each 8-bit element in a, and
+// store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_movemask_pi8
+FORCE_INLINE int _mm_movemask_pi8(__m64 a)
+{
+    uint8x8_t input = vreinterpret_u8_m64(a);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    static const int8_t shift[8] = {0, 1, 2, 3, 4, 5, 6, 7};
+    uint8x8_t tmp = vshr_n_u8(input, 7);
+    return vaddv_u8(vshl_u8(tmp, vld1_s8(shift)));
+#else
+    // Refer the implementation of `_mm_movemask_epi8`
+    uint16x4_t high_bits = vreinterpret_u16_u8(vshr_n_u8(input, 7));
+    uint32x2_t paired16 =
+        vreinterpret_u32_u16(vsra_n_u16(high_bits, high_bits, 7));
+    uint8x8_t paired32 =
+        vreinterpret_u8_u32(vsra_n_u32(paired16, paired16, 14));
+    return vget_lane_u8(paired32, 0) | ((int) vget_lane_u8(paired32, 4) << 4);
+#endif
+}
+
+// Set each bit of mask dst based on the most significant bit of the
+// corresponding packed single-precision (32-bit) floating-point element in a.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_movemask_ps
+FORCE_INLINE int _mm_movemask_ps(__m128 a)
+{
+    uint32x4_t input = vreinterpretq_u32_m128(a);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    static const int32_t shift[4] = {0, 1, 2, 3};
+    uint32x4_t tmp = vshrq_n_u32(input, 31);
+    return vaddvq_u32(vshlq_u32(tmp, vld1q_s32(shift)));
+#else
+    // Uses the exact same method as _mm_movemask_epi8, see that for details.
+    // Shift out everything but the sign bits with a 32-bit unsigned shift
+    // right.
+    uint64x2_t high_bits = vreinterpretq_u64_u32(vshrq_n_u32(input, 31));
+    // Merge the two pairs together with a 64-bit unsigned shift right + add.
+    uint8x16_t paired =
+        vreinterpretq_u8_u64(vsraq_n_u64(high_bits, high_bits, 31));
+    // Extract the result.
+    return vgetq_lane_u8(paired, 0) | (vgetq_lane_u8(paired, 8) << 2);
+#endif
+}
+
+// Multiply packed single-precision (32-bit) floating-point elements in a and b,
+// and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mul_ps
+FORCE_INLINE __m128 _mm_mul_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_f32(
+        vmulq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+}
+
+// Multiply the lower single-precision (32-bit) floating-point element in a and
+// b, store the result in the lower element of dst, and copy the upper 3 packed
+// elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mul_ss
+FORCE_INLINE __m128 _mm_mul_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_mul_ps(a, b));
+}
+
+// Multiply the packed unsigned 16-bit integers in a and b, producing
+// intermediate 32-bit integers, and store the high 16 bits of the intermediate
+// integers in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mulhi_pu16
+FORCE_INLINE __m64 _mm_mulhi_pu16(__m64 a, __m64 b)
+{
+    return vreinterpret_m64_u16(vshrn_n_u32(
+        vmull_u16(vreinterpret_u16_m64(a), vreinterpret_u16_m64(b)), 16));
+}
+
+// Compute the bitwise OR of packed single-precision (32-bit) floating-point
+// elements in a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_or_ps
+FORCE_INLINE __m128 _mm_or_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_s32(
+        vorrq_s32(vreinterpretq_s32_m128(a), vreinterpretq_s32_m128(b)));
+}
+
+// Average packed unsigned 8-bit integers in a and b, and store the results in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_m_pavgb
+#define _m_pavgb(a, b) _mm_avg_pu8(a, b)
+
+// Average packed unsigned 16-bit integers in a and b, and store the results in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_m_pavgw
+#define _m_pavgw(a, b) _mm_avg_pu16(a, b)
+
+// Extract a 16-bit integer from a, selected with imm8, and store the result in
+// the lower element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_m_pextrw
+#define _m_pextrw(a, imm) _mm_extract_pi16(a, imm)
+
+// Copy a to dst, and insert the 16-bit integer i into dst at the location
+// specified by imm8.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=m_pinsrw
+#define _m_pinsrw(a, i, imm) _mm_insert_pi16(a, i, imm)
+
+// Compare packed signed 16-bit integers in a and b, and store packed maximum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_m_pmaxsw
+#define _m_pmaxsw(a, b) _mm_max_pi16(a, b)
+
+// Compare packed unsigned 8-bit integers in a and b, and store packed maximum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_m_pmaxub
+#define _m_pmaxub(a, b) _mm_max_pu8(a, b)
+
+// Compare packed signed 16-bit integers in a and b, and store packed minimum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_m_pminsw
+#define _m_pminsw(a, b) _mm_min_pi16(a, b)
+
+// Compare packed unsigned 8-bit integers in a and b, and store packed minimum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_m_pminub
+#define _m_pminub(a, b) _mm_min_pu8(a, b)
+
+// Create mask from the most significant bit of each 8-bit element in a, and
+// store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_m_pmovmskb
+#define _m_pmovmskb(a) _mm_movemask_pi8(a)
+
+// Multiply the packed unsigned 16-bit integers in a and b, producing
+// intermediate 32-bit integers, and store the high 16 bits of the intermediate
+// integers in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_m_pmulhuw
+#define _m_pmulhuw(a, b) _mm_mulhi_pu16(a, b)
+
+// Fetch the line of data from memory that contains address p to a location in
+// the cache hierarchy specified by the locality hint i.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_prefetch
+FORCE_INLINE void _mm_prefetch(char const *p, int i)
+{
+    (void) i;
+#if defined(_MSC_VER) && !defined(__clang__)
+    switch (i) {
+    case _MM_HINT_NTA:
+        __prefetch2(p, 1);
+        break;
+    case _MM_HINT_T0:
+        __prefetch2(p, 0);
+        break;
+    case _MM_HINT_T1:
+        __prefetch2(p, 2);
+        break;
+    case _MM_HINT_T2:
+        __prefetch2(p, 4);
+        break;
+    }
+#else
+    switch (i) {
+    case _MM_HINT_NTA:
+        __builtin_prefetch(p, 0, 0);
+        break;
+    case _MM_HINT_T0:
+        __builtin_prefetch(p, 0, 3);
+        break;
+    case _MM_HINT_T1:
+        __builtin_prefetch(p, 0, 2);
+        break;
+    case _MM_HINT_T2:
+        __builtin_prefetch(p, 0, 1);
+        break;
+    }
+#endif
+}
+
+// Compute the absolute differences of packed unsigned 8-bit integers in a and
+// b, then horizontally sum each consecutive 8 differences to produce four
+// unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low
+// 16 bits of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=m_psadbw
+#define _m_psadbw(a, b) _mm_sad_pu8(a, b)
+
+// Shuffle 16-bit integers in a using the control in imm8, and store the results
+// in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_m_pshufw
+#define _m_pshufw(a, imm) _mm_shuffle_pi16(a, imm)
+
+// Compute the approximate reciprocal of packed single-precision (32-bit)
+// floating-point elements in a, and store the results in dst. The maximum
+// relative error for this approximation is less than 1.5*2^-12.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_rcp_ps
+FORCE_INLINE __m128 _mm_rcp_ps(__m128 in)
+{
+    float32x4_t recip = vrecpeq_f32(vreinterpretq_f32_m128(in));
+    recip = vmulq_f32(recip, vrecpsq_f32(recip, vreinterpretq_f32_m128(in)));
+#if SSE2NEON_PRECISE_DIV
+    // Additional Netwon-Raphson iteration for accuracy
+    recip = vmulq_f32(recip, vrecpsq_f32(recip, vreinterpretq_f32_m128(in)));
+#endif
+    return vreinterpretq_m128_f32(recip);
+}
+
+// Compute the approximate reciprocal of the lower single-precision (32-bit)
+// floating-point element in a, store the result in the lower element of dst,
+// and copy the upper 3 packed elements from a to the upper elements of dst. The
+// maximum relative error for this approximation is less than 1.5*2^-12.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_rcp_ss
+FORCE_INLINE __m128 _mm_rcp_ss(__m128 a)
+{
+    return _mm_move_ss(a, _mm_rcp_ps(a));
+}
+
+// Compute the approximate reciprocal square root of packed single-precision
+// (32-bit) floating-point elements in a, and store the results in dst. The
+// maximum relative error for this approximation is less than 1.5*2^-12.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_rsqrt_ps
+FORCE_INLINE __m128 _mm_rsqrt_ps(__m128 in)
+{
+    float32x4_t out = vrsqrteq_f32(vreinterpretq_f32_m128(in));
+
+    // Generate masks for detecting whether input has any 0.0f/-0.0f
+    // (which becomes positive/negative infinity by IEEE-754 arithmetic rules).
+    const uint32x4_t pos_inf = vdupq_n_u32(0x7F800000);
+    const uint32x4_t neg_inf = vdupq_n_u32(0xFF800000);
+    const uint32x4_t has_pos_zero =
+        vceqq_u32(pos_inf, vreinterpretq_u32_f32(out));
+    const uint32x4_t has_neg_zero =
+        vceqq_u32(neg_inf, vreinterpretq_u32_f32(out));
+
+    out = vmulq_f32(
+        out, vrsqrtsq_f32(vmulq_f32(vreinterpretq_f32_m128(in), out), out));
+#if SSE2NEON_PRECISE_SQRT
+    // Additional Netwon-Raphson iteration for accuracy
+    out = vmulq_f32(
+        out, vrsqrtsq_f32(vmulq_f32(vreinterpretq_f32_m128(in), out), out));
+#endif
+
+    // Set output vector element to infinity/negative-infinity if
+    // the corresponding input vector element is 0.0f/-0.0f.
+    out = vbslq_f32(has_pos_zero, (float32x4_t) pos_inf, out);
+    out = vbslq_f32(has_neg_zero, (float32x4_t) neg_inf, out);
+
+    return vreinterpretq_m128_f32(out);
+}
+
+// Compute the approximate reciprocal square root of the lower single-precision
+// (32-bit) floating-point element in a, store the result in the lower element
+// of dst, and copy the upper 3 packed elements from a to the upper elements of
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_rsqrt_ss
+FORCE_INLINE __m128 _mm_rsqrt_ss(__m128 in)
+{
+    return vsetq_lane_f32(vgetq_lane_f32(_mm_rsqrt_ps(in), 0), in, 0);
+}
+
+// Compute the absolute differences of packed unsigned 8-bit integers in a and
+// b, then horizontally sum each consecutive 8 differences to produce four
+// unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low
+// 16 bits of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sad_pu8
+FORCE_INLINE __m64 _mm_sad_pu8(__m64 a, __m64 b)
+{
+    uint64x1_t t = vpaddl_u32(vpaddl_u16(
+        vpaddl_u8(vabd_u8(vreinterpret_u8_m64(a), vreinterpret_u8_m64(b)))));
+    return vreinterpret_m64_u16(
+        vset_lane_u16((int) vget_lane_u64(t, 0), vdup_n_u16(0), 0));
+}
+
+// Macro: Set the flush zero bits of the MXCSR control and status register to
+// the value in unsigned 32-bit integer a. The flush zero may contain any of the
+// following flags: _MM_FLUSH_ZERO_ON or _MM_FLUSH_ZERO_OFF
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_MM_SET_FLUSH_ZERO_MODE
+FORCE_INLINE void _sse2neon_mm_set_flush_zero_mode(unsigned int flag)
+{
+    // AArch32 Advanced SIMD arithmetic always uses the Flush-to-zero setting,
+    // regardless of the value of the FZ bit.
+    union {
+        fpcr_bitfield field;
+#if defined(__aarch64__) || defined(_M_ARM64)
+        uint64_t value;
+#else
+        uint32_t value;
+#endif
+    } r;
+
+#if defined(__aarch64__) || defined(_M_ARM64)
+    r.value = _sse2neon_get_fpcr();
+#else
+    __asm__ __volatile__("vmrs %0, FPSCR" : "=r"(r.value)); /* read */
+#endif
+
+    r.field.bit24 = (flag & _MM_FLUSH_ZERO_MASK) == _MM_FLUSH_ZERO_ON;
+
+#if defined(__aarch64__) || defined(_M_ARM64)
+    _sse2neon_set_fpcr(r.value);
+#else
+    __asm__ __volatile__("vmsr FPSCR, %0" ::"r"(r));        /* write */
+#endif
+}
+
+// Set packed single-precision (32-bit) floating-point elements in dst with the
+// supplied values.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set_ps
+FORCE_INLINE __m128 _mm_set_ps(float w, float z, float y, float x)
+{
+    float ALIGN_STRUCT(16) data[4] = {x, y, z, w};
+    return vreinterpretq_m128_f32(vld1q_f32(data));
+}
+
+// Broadcast single-precision (32-bit) floating-point value a to all elements of
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set_ps1
+FORCE_INLINE __m128 _mm_set_ps1(float _w)
+{
+    return vreinterpretq_m128_f32(vdupq_n_f32(_w));
+}
+
+// Macro: Set the rounding mode bits of the MXCSR control and status register to
+// the value in unsigned 32-bit integer a. The rounding mode may contain any of
+// the following flags: _MM_ROUND_NEAREST, _MM_ROUND_DOWN, _MM_ROUND_UP,
+// _MM_ROUND_TOWARD_ZERO
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_MM_SET_ROUNDING_MODE
+FORCE_INLINE_OPTNONE void _MM_SET_ROUNDING_MODE(int rounding)
+{
+    union {
+        fpcr_bitfield field;
+#if defined(__aarch64__) || defined(_M_ARM64)
+        uint64_t value;
+#else
+        uint32_t value;
+#endif
+    } r;
+
+#if defined(__aarch64__) || defined(_M_ARM64)
+    r.value = _sse2neon_get_fpcr();
+#else
+    __asm__ __volatile__("vmrs %0, FPSCR" : "=r"(r.value)); /* read */
+#endif
+
+    switch (rounding) {
+    case _MM_ROUND_TOWARD_ZERO:
+        r.field.bit22 = 1;
+        r.field.bit23 = 1;
+        break;
+    case _MM_ROUND_DOWN:
+        r.field.bit22 = 0;
+        r.field.bit23 = 1;
+        break;
+    case _MM_ROUND_UP:
+        r.field.bit22 = 1;
+        r.field.bit23 = 0;
+        break;
+    default:  //_MM_ROUND_NEAREST
+        r.field.bit22 = 0;
+        r.field.bit23 = 0;
+    }
+
+#if defined(__aarch64__) || defined(_M_ARM64)
+    _sse2neon_set_fpcr(r.value);
+#else
+    __asm__ __volatile__("vmsr FPSCR, %0" ::"r"(r));        /* write */
+#endif
+}
+
+// Copy single-precision (32-bit) floating-point element a to the lower element
+// of dst, and zero the upper 3 elements.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set_ss
+FORCE_INLINE __m128 _mm_set_ss(float a)
+{
+    return vreinterpretq_m128_f32(vsetq_lane_f32(a, vdupq_n_f32(0), 0));
+}
+
+// Broadcast single-precision (32-bit) floating-point value a to all elements of
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set1_ps
+FORCE_INLINE __m128 _mm_set1_ps(float _w)
+{
+    return vreinterpretq_m128_f32(vdupq_n_f32(_w));
+}
+
+// Set the MXCSR control and status register with the value in unsigned 32-bit
+// integer a.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_setcsr
+// FIXME: _mm_setcsr() implementation supports changing the rounding mode only.
+FORCE_INLINE void _mm_setcsr(unsigned int a)
+{
+    _MM_SET_ROUNDING_MODE(a);
+}
+
+// Get the unsigned 32-bit value of the MXCSR control and status register.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_getcsr
+// FIXME: _mm_getcsr() implementation supports reading the rounding mode only.
+FORCE_INLINE unsigned int _mm_getcsr(void)
+{
+    return _MM_GET_ROUNDING_MODE();
+}
+
+// Set packed single-precision (32-bit) floating-point elements in dst with the
+// supplied values in reverse order.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_setr_ps
+FORCE_INLINE __m128 _mm_setr_ps(float w, float z, float y, float x)
+{
+    float ALIGN_STRUCT(16) data[4] = {w, z, y, x};
+    return vreinterpretq_m128_f32(vld1q_f32(data));
+}
+
+// Return vector of type __m128 with all elements set to zero.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_setzero_ps
+FORCE_INLINE __m128 _mm_setzero_ps(void)
+{
+    return vreinterpretq_m128_f32(vdupq_n_f32(0));
+}
+
+// Shuffle 16-bit integers in a using the control in imm8, and store the results
+// in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_shuffle_pi16
+#ifdef _sse2neon_shuffle
+#define _mm_shuffle_pi16(a, imm)                                       \
+    vreinterpret_m64_s16(vshuffle_s16(                                 \
+        vreinterpret_s16_m64(a), vreinterpret_s16_m64(a), (imm & 0x3), \
+        ((imm >> 2) & 0x3), ((imm >> 4) & 0x3), ((imm >> 6) & 0x3)))
+#else
+#define _mm_shuffle_pi16(a, imm)                                              \
+    _sse2neon_define1(                                                        \
+        __m64, a, int16x4_t ret;                                              \
+        ret = vmov_n_s16(                                                     \
+            vget_lane_s16(vreinterpret_s16_m64(_a), (imm) & (0x3)));          \
+        ret = vset_lane_s16(                                                  \
+            vget_lane_s16(vreinterpret_s16_m64(_a), ((imm) >> 2) & 0x3), ret, \
+            1);                                                               \
+        ret = vset_lane_s16(                                                  \
+            vget_lane_s16(vreinterpret_s16_m64(_a), ((imm) >> 4) & 0x3), ret, \
+            2);                                                               \
+        ret = vset_lane_s16(                                                  \
+            vget_lane_s16(vreinterpret_s16_m64(_a), ((imm) >> 6) & 0x3), ret, \
+            3);                                                               \
+        _sse2neon_return(vreinterpret_m64_s16(ret));)
+#endif
+
+// Perform a serializing operation on all store-to-memory instructions that were
+// issued prior to this instruction. Guarantees that every store instruction
+// that precedes, in program order, is globally visible before any store
+// instruction which follows the fence in program order.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sfence
+FORCE_INLINE void _mm_sfence(void)
+{
+    _sse2neon_smp_mb();
+}
+
+// Perform a serializing operation on all load-from-memory and store-to-memory
+// instructions that were issued prior to this instruction. Guarantees that
+// every memory access that precedes, in program order, the memory fence
+// instruction is globally visible before any memory instruction which follows
+// the fence in program order.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mfence
+FORCE_INLINE void _mm_mfence(void)
+{
+    _sse2neon_smp_mb();
+}
+
+// Perform a serializing operation on all load-from-memory instructions that
+// were issued prior to this instruction. Guarantees that every load instruction
+// that precedes, in program order, is globally visible before any load
+// instruction which follows the fence in program order.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_lfence
+FORCE_INLINE void _mm_lfence(void)
+{
+    _sse2neon_smp_mb();
+}
+
+// FORCE_INLINE __m128 _mm_shuffle_ps(__m128 a, __m128 b, __constrange(0,255)
+// int imm)
+#ifdef _sse2neon_shuffle
+#define _mm_shuffle_ps(a, b, imm)                                              \
+    __extension__({                                                            \
+        float32x4_t _input1 = vreinterpretq_f32_m128(a);                       \
+        float32x4_t _input2 = vreinterpretq_f32_m128(b);                       \
+        float32x4_t _shuf =                                                    \
+            vshuffleq_s32(_input1, _input2, (imm) & (0x3), ((imm) >> 2) & 0x3, \
+                          (((imm) >> 4) & 0x3) + 4, (((imm) >> 6) & 0x3) + 4); \
+        vreinterpretq_m128_f32(_shuf);                                         \
+    })
+#else  // generic
+#define _mm_shuffle_ps(a, b, imm)                            \
+    _sse2neon_define2(                                       \
+        __m128, a, b, __m128 ret; switch (imm) {             \
+            case _MM_SHUFFLE(1, 0, 3, 2):                    \
+                ret = _mm_shuffle_ps_1032(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(2, 3, 0, 1):                    \
+                ret = _mm_shuffle_ps_2301(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(0, 3, 2, 1):                    \
+                ret = _mm_shuffle_ps_0321(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(2, 1, 0, 3):                    \
+                ret = _mm_shuffle_ps_2103(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(1, 0, 1, 0):                    \
+                ret = _mm_movelh_ps(_a, _b);                 \
+                break;                                       \
+            case _MM_SHUFFLE(1, 0, 0, 1):                    \
+                ret = _mm_shuffle_ps_1001(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(0, 1, 0, 1):                    \
+                ret = _mm_shuffle_ps_0101(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(3, 2, 1, 0):                    \
+                ret = _mm_shuffle_ps_3210(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(0, 0, 1, 1):                    \
+                ret = _mm_shuffle_ps_0011(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(0, 0, 2, 2):                    \
+                ret = _mm_shuffle_ps_0022(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(2, 2, 0, 0):                    \
+                ret = _mm_shuffle_ps_2200(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(3, 2, 0, 2):                    \
+                ret = _mm_shuffle_ps_3202(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(3, 2, 3, 2):                    \
+                ret = _mm_movehl_ps(_b, _a);                 \
+                break;                                       \
+            case _MM_SHUFFLE(1, 1, 3, 3):                    \
+                ret = _mm_shuffle_ps_1133(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(2, 0, 1, 0):                    \
+                ret = _mm_shuffle_ps_2010(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(2, 0, 0, 1):                    \
+                ret = _mm_shuffle_ps_2001(_a, _b);           \
+                break;                                       \
+            case _MM_SHUFFLE(2, 0, 3, 2):                    \
+                ret = _mm_shuffle_ps_2032(_a, _b);           \
+                break;                                       \
+            default:                                         \
+                ret = _mm_shuffle_ps_default(_a, _b, (imm)); \
+                break;                                       \
+        } _sse2neon_return(ret);)
+#endif
+
+// Compute the square root of packed single-precision (32-bit) floating-point
+// elements in a, and store the results in dst.
+// Due to ARMv7-A NEON's lack of a precise square root intrinsic, we implement
+// square root by multiplying input in with its reciprocal square root before
+// using the Newton-Raphson method to approximate the results.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sqrt_ps
+FORCE_INLINE __m128 _mm_sqrt_ps(__m128 in)
+{
+#if (defined(__aarch64__) || defined(_M_ARM64)) && !SSE2NEON_PRECISE_SQRT
+    return vreinterpretq_m128_f32(vsqrtq_f32(vreinterpretq_f32_m128(in)));
+#else
+    float32x4_t recip = vrsqrteq_f32(vreinterpretq_f32_m128(in));
+
+    // Test for vrsqrteq_f32(0) -> positive infinity case.
+    // Change to zero, so that s * 1/sqrt(s) result is zero too.
+    const uint32x4_t pos_inf = vdupq_n_u32(0x7F800000);
+    const uint32x4_t div_by_zero =
+        vceqq_u32(pos_inf, vreinterpretq_u32_f32(recip));
+    recip = vreinterpretq_f32_u32(
+        vandq_u32(vmvnq_u32(div_by_zero), vreinterpretq_u32_f32(recip)));
+
+    recip = vmulq_f32(
+        vrsqrtsq_f32(vmulq_f32(recip, recip), vreinterpretq_f32_m128(in)),
+        recip);
+    // Additional Netwon-Raphson iteration for accuracy
+    recip = vmulq_f32(
+        vrsqrtsq_f32(vmulq_f32(recip, recip), vreinterpretq_f32_m128(in)),
+        recip);
+
+    // sqrt(s) = s * 1/sqrt(s)
+    return vreinterpretq_m128_f32(vmulq_f32(vreinterpretq_f32_m128(in), recip));
+#endif
+}
+
+// Compute the square root of the lower single-precision (32-bit) floating-point
+// element in a, store the result in the lower element of dst, and copy the
+// upper 3 packed elements from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sqrt_ss
+FORCE_INLINE __m128 _mm_sqrt_ss(__m128 in)
+{
+    float32_t value =
+        vgetq_lane_f32(vreinterpretq_f32_m128(_mm_sqrt_ps(in)), 0);
+    return vreinterpretq_m128_f32(
+        vsetq_lane_f32(value, vreinterpretq_f32_m128(in), 0));
+}
+
+// Store 128-bits (composed of 4 packed single-precision (32-bit) floating-point
+// elements) from a into memory. mem_addr must be aligned on a 16-byte boundary
+// or a general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_store_ps
+FORCE_INLINE void _mm_store_ps(float *p, __m128 a)
+{
+    vst1q_f32(p, vreinterpretq_f32_m128(a));
+}
+
+// Store the lower single-precision (32-bit) floating-point element from a into
+// 4 contiguous elements in memory. mem_addr must be aligned on a 16-byte
+// boundary or a general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_store_ps1
+FORCE_INLINE void _mm_store_ps1(float *p, __m128 a)
+{
+    float32_t a0 = vgetq_lane_f32(vreinterpretq_f32_m128(a), 0);
+    vst1q_f32(p, vdupq_n_f32(a0));
+}
+
+// Store the lower single-precision (32-bit) floating-point element from a into
+// memory. mem_addr does not need to be aligned on any particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_store_ss
+FORCE_INLINE void _mm_store_ss(float *p, __m128 a)
+{
+    vst1q_lane_f32(p, vreinterpretq_f32_m128(a), 0);
+}
+
+// Store the lower single-precision (32-bit) floating-point element from a into
+// 4 contiguous elements in memory. mem_addr must be aligned on a 16-byte
+// boundary or a general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_store1_ps
+#define _mm_store1_ps _mm_store_ps1
+
+// Store the upper 2 single-precision (32-bit) floating-point elements from a
+// into memory.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storeh_pi
+FORCE_INLINE void _mm_storeh_pi(__m64 *p, __m128 a)
+{
+    *p = vreinterpret_m64_f32(vget_high_f32(a));
+}
+
+// Store the lower 2 single-precision (32-bit) floating-point elements from a
+// into memory.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storel_pi
+FORCE_INLINE void _mm_storel_pi(__m64 *p, __m128 a)
+{
+    *p = vreinterpret_m64_f32(vget_low_f32(a));
+}
+
+// Store 4 single-precision (32-bit) floating-point elements from a into memory
+// in reverse order. mem_addr must be aligned on a 16-byte boundary or a
+// general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storer_ps
+FORCE_INLINE void _mm_storer_ps(float *p, __m128 a)
+{
+    float32x4_t tmp = vrev64q_f32(vreinterpretq_f32_m128(a));
+    float32x4_t rev = vextq_f32(tmp, tmp, 2);
+    vst1q_f32(p, rev);
+}
+
+// Store 128-bits (composed of 4 packed single-precision (32-bit) floating-point
+// elements) from a into memory. mem_addr does not need to be aligned on any
+// particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storeu_ps
+FORCE_INLINE void _mm_storeu_ps(float *p, __m128 a)
+{
+    vst1q_f32(p, vreinterpretq_f32_m128(a));
+}
+
+// Stores 16-bits of integer data a at the address p.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storeu_si16
+FORCE_INLINE void _mm_storeu_si16(void *p, __m128i a)
+{
+    vst1q_lane_s16((int16_t *) p, vreinterpretq_s16_m128i(a), 0);
+}
+
+// Stores 64-bits of integer data a at the address p.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storeu_si64
+FORCE_INLINE void _mm_storeu_si64(void *p, __m128i a)
+{
+    vst1q_lane_s64((int64_t *) p, vreinterpretq_s64_m128i(a), 0);
+}
+
+// Store 64-bits of integer data from a into memory using a non-temporal memory
+// hint.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_stream_pi
+FORCE_INLINE void _mm_stream_pi(__m64 *p, __m64 a)
+{
+    vst1_s64((int64_t *) p, vreinterpret_s64_m64(a));
+}
+
+// Store 128-bits (composed of 4 packed single-precision (32-bit) floating-
+// point elements) from a into memory using a non-temporal memory hint.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_stream_ps
+FORCE_INLINE void _mm_stream_ps(float *p, __m128 a)
+{
+#if __has_builtin(__builtin_nontemporal_store)
+    __builtin_nontemporal_store(a, (float32x4_t *) p);
+#else
+    vst1q_f32(p, vreinterpretq_f32_m128(a));
+#endif
+}
+
+// Subtract packed single-precision (32-bit) floating-point elements in b from
+// packed single-precision (32-bit) floating-point elements in a, and store the
+// results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sub_ps
+FORCE_INLINE __m128 _mm_sub_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_f32(
+        vsubq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+}
+
+// Subtract the lower single-precision (32-bit) floating-point element in b from
+// the lower single-precision (32-bit) floating-point element in a, store the
+// result in the lower element of dst, and copy the upper 3 packed elements from
+// a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sub_ss
+FORCE_INLINE __m128 _mm_sub_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_sub_ps(a, b));
+}
+
+// Macro: Transpose the 4x4 matrix formed by the 4 rows of single-precision
+// (32-bit) floating-point elements in row0, row1, row2, and row3, and store the
+// transposed matrix in these vectors (row0 now contains column 0, etc.).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=MM_TRANSPOSE4_PS
+#define _MM_TRANSPOSE4_PS(row0, row1, row2, row3)         \
+    do {                                                  \
+        float32x4x2_t ROW01 = vtrnq_f32(row0, row1);      \
+        float32x4x2_t ROW23 = vtrnq_f32(row2, row3);      \
+        row0 = vcombine_f32(vget_low_f32(ROW01.val[0]),   \
+                            vget_low_f32(ROW23.val[0]));  \
+        row1 = vcombine_f32(vget_low_f32(ROW01.val[1]),   \
+                            vget_low_f32(ROW23.val[1]));  \
+        row2 = vcombine_f32(vget_high_f32(ROW01.val[0]),  \
+                            vget_high_f32(ROW23.val[0])); \
+        row3 = vcombine_f32(vget_high_f32(ROW01.val[1]),  \
+                            vget_high_f32(ROW23.val[1])); \
+    } while (0)
+
+// according to the documentation, these intrinsics behave the same as the
+// non-'u' versions.  We'll just alias them here.
+#define _mm_ucomieq_ss _mm_comieq_ss
+#define _mm_ucomige_ss _mm_comige_ss
+#define _mm_ucomigt_ss _mm_comigt_ss
+#define _mm_ucomile_ss _mm_comile_ss
+#define _mm_ucomilt_ss _mm_comilt_ss
+#define _mm_ucomineq_ss _mm_comineq_ss
+
+// Return vector of type __m128i with undefined elements.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=mm_undefined_si128
+FORCE_INLINE __m128i _mm_undefined_si128(void)
+{
+#if defined(__GNUC__) || defined(__clang__)
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wuninitialized"
+#endif
+    __m128i a;
+#if defined(_MSC_VER)
+    a = _mm_setzero_si128();
+#endif
+    return a;
+#if defined(__GNUC__) || defined(__clang__)
+#pragma GCC diagnostic pop
+#endif
+}
+
+// Return vector of type __m128 with undefined elements.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_undefined_ps
+FORCE_INLINE __m128 _mm_undefined_ps(void)
+{
+#if defined(__GNUC__) || defined(__clang__)
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wuninitialized"
+#endif
+    __m128 a;
+#if defined(_MSC_VER)
+    a = _mm_setzero_ps();
+#endif
+    return a;
+#if defined(__GNUC__) || defined(__clang__)
+#pragma GCC diagnostic pop
+#endif
+}
+
+// Unpack and interleave single-precision (32-bit) floating-point elements from
+// the high half a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_unpackhi_ps
+FORCE_INLINE __m128 _mm_unpackhi_ps(__m128 a, __m128 b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128_f32(
+        vzip2q_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+#else
+    float32x2_t a1 = vget_high_f32(vreinterpretq_f32_m128(a));
+    float32x2_t b1 = vget_high_f32(vreinterpretq_f32_m128(b));
+    float32x2x2_t result = vzip_f32(a1, b1);
+    return vreinterpretq_m128_f32(vcombine_f32(result.val[0], result.val[1]));
+#endif
+}
+
+// Unpack and interleave single-precision (32-bit) floating-point elements from
+// the low half of a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_unpacklo_ps
+FORCE_INLINE __m128 _mm_unpacklo_ps(__m128 a, __m128 b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128_f32(
+        vzip1q_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+#else
+    float32x2_t a1 = vget_low_f32(vreinterpretq_f32_m128(a));
+    float32x2_t b1 = vget_low_f32(vreinterpretq_f32_m128(b));
+    float32x2x2_t result = vzip_f32(a1, b1);
+    return vreinterpretq_m128_f32(vcombine_f32(result.val[0], result.val[1]));
+#endif
+}
+
+// Compute the bitwise XOR of packed single-precision (32-bit) floating-point
+// elements in a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_xor_ps
+FORCE_INLINE __m128 _mm_xor_ps(__m128 a, __m128 b)
+{
+    return vreinterpretq_m128_s32(
+        veorq_s32(vreinterpretq_s32_m128(a), vreinterpretq_s32_m128(b)));
+}
+
+/* SSE2 */
+
+// Add packed 16-bit integers in a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_add_epi16
+FORCE_INLINE __m128i _mm_add_epi16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s16(
+        vaddq_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b)));
+}
+
+// Add packed 32-bit integers in a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_add_epi32
+FORCE_INLINE __m128i _mm_add_epi32(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s32(
+        vaddq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+}
+
+// Add packed 64-bit integers in a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_add_epi64
+FORCE_INLINE __m128i _mm_add_epi64(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s64(
+        vaddq_s64(vreinterpretq_s64_m128i(a), vreinterpretq_s64_m128i(b)));
+}
+
+// Add packed 8-bit integers in a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_add_epi8
+FORCE_INLINE __m128i _mm_add_epi8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s8(
+        vaddq_s8(vreinterpretq_s8_m128i(a), vreinterpretq_s8_m128i(b)));
+}
+
+// Add packed double-precision (64-bit) floating-point elements in a and b, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_add_pd
+FORCE_INLINE __m128d _mm_add_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vaddq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    double c[2];
+    c[0] = a0 + b0;
+    c[1] = a1 + b1;
+    return vld1q_f32((float32_t *) c);
+#endif
+}
+
+// Add the lower double-precision (64-bit) floating-point element in a and b,
+// store the result in the lower element of dst, and copy the upper element from
+// a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_add_sd
+FORCE_INLINE __m128d _mm_add_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return _mm_move_sd(a, _mm_add_pd(a, b));
+#else
+    double a0, a1, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    a1 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double c[2];
+    c[0] = a0 + b0;
+    c[1] = a1;
+    return vld1q_f32((float32_t *) c);
+#endif
+}
+
+// Add 64-bit integers a and b, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_add_si64
+FORCE_INLINE __m64 _mm_add_si64(__m64 a, __m64 b)
+{
+    return vreinterpret_m64_s64(
+        vadd_s64(vreinterpret_s64_m64(a), vreinterpret_s64_m64(b)));
+}
+
+// Add packed signed 16-bit integers in a and b using saturation, and store the
+// results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_adds_epi16
+FORCE_INLINE __m128i _mm_adds_epi16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s16(
+        vqaddq_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b)));
+}
+
+// Add packed signed 8-bit integers in a and b using saturation, and store the
+// results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_adds_epi8
+FORCE_INLINE __m128i _mm_adds_epi8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s8(
+        vqaddq_s8(vreinterpretq_s8_m128i(a), vreinterpretq_s8_m128i(b)));
+}
+
+// Add packed unsigned 16-bit integers in a and b using saturation, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_adds_epu16
+FORCE_INLINE __m128i _mm_adds_epu16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u16(
+        vqaddq_u16(vreinterpretq_u16_m128i(a), vreinterpretq_u16_m128i(b)));
+}
+
+// Add packed unsigned 8-bit integers in a and b using saturation, and store the
+// results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_adds_epu8
+FORCE_INLINE __m128i _mm_adds_epu8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u8(
+        vqaddq_u8(vreinterpretq_u8_m128i(a), vreinterpretq_u8_m128i(b)));
+}
+
+// Compute the bitwise AND of packed double-precision (64-bit) floating-point
+// elements in a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_and_pd
+FORCE_INLINE __m128d _mm_and_pd(__m128d a, __m128d b)
+{
+    return vreinterpretq_m128d_s64(
+        vandq_s64(vreinterpretq_s64_m128d(a), vreinterpretq_s64_m128d(b)));
+}
+
+// Compute the bitwise AND of 128 bits (representing integer data) in a and b,
+// and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_and_si128
+FORCE_INLINE __m128i _mm_and_si128(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s32(
+        vandq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+}
+
+// Compute the bitwise NOT of packed double-precision (64-bit) floating-point
+// elements in a and then AND with b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_andnot_pd
+FORCE_INLINE __m128d _mm_andnot_pd(__m128d a, __m128d b)
+{
+    // *NOTE* argument swap
+    return vreinterpretq_m128d_s64(
+        vbicq_s64(vreinterpretq_s64_m128d(b), vreinterpretq_s64_m128d(a)));
+}
+
+// Compute the bitwise NOT of 128 bits (representing integer data) in a and then
+// AND with b, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_andnot_si128
+FORCE_INLINE __m128i _mm_andnot_si128(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s32(
+        vbicq_s32(vreinterpretq_s32_m128i(b),
+                  vreinterpretq_s32_m128i(a)));  // *NOTE* argument swap
+}
+
+// Average packed unsigned 16-bit integers in a and b, and store the results in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_avg_epu16
+FORCE_INLINE __m128i _mm_avg_epu16(__m128i a, __m128i b)
+{
+    return (__m128i) vrhaddq_u16(vreinterpretq_u16_m128i(a),
+                                 vreinterpretq_u16_m128i(b));
+}
+
+// Average packed unsigned 8-bit integers in a and b, and store the results in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_avg_epu8
+FORCE_INLINE __m128i _mm_avg_epu8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u8(
+        vrhaddq_u8(vreinterpretq_u8_m128i(a), vreinterpretq_u8_m128i(b)));
+}
+
+// Shift a left by imm8 bytes while shifting in zeros, and store the results in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_bslli_si128
+#define _mm_bslli_si128(a, imm) _mm_slli_si128(a, imm)
+
+// Shift a right by imm8 bytes while shifting in zeros, and store the results in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_bsrli_si128
+#define _mm_bsrli_si128(a, imm) _mm_srli_si128(a, imm)
+
+// Cast vector of type __m128d to type __m128. This intrinsic is only used for
+// compilation and does not generate any instructions, thus it has zero latency.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_castpd_ps
+FORCE_INLINE __m128 _mm_castpd_ps(__m128d a)
+{
+    return vreinterpretq_m128_s64(vreinterpretq_s64_m128d(a));
+}
+
+// Cast vector of type __m128d to type __m128i. This intrinsic is only used for
+// compilation and does not generate any instructions, thus it has zero latency.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_castpd_si128
+FORCE_INLINE __m128i _mm_castpd_si128(__m128d a)
+{
+    return vreinterpretq_m128i_s64(vreinterpretq_s64_m128d(a));
+}
+
+// Cast vector of type __m128 to type __m128d. This intrinsic is only used for
+// compilation and does not generate any instructions, thus it has zero latency.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_castps_pd
+FORCE_INLINE __m128d _mm_castps_pd(__m128 a)
+{
+    return vreinterpretq_m128d_s32(vreinterpretq_s32_m128(a));
+}
+
+// Cast vector of type __m128 to type __m128i. This intrinsic is only used for
+// compilation and does not generate any instructions, thus it has zero latency.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_castps_si128
+FORCE_INLINE __m128i _mm_castps_si128(__m128 a)
+{
+    return vreinterpretq_m128i_s32(vreinterpretq_s32_m128(a));
+}
+
+// Cast vector of type __m128i to type __m128d. This intrinsic is only used for
+// compilation and does not generate any instructions, thus it has zero latency.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_castsi128_pd
+FORCE_INLINE __m128d _mm_castsi128_pd(__m128i a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(vreinterpretq_f64_m128i(a));
+#else
+    return vreinterpretq_m128d_f32(vreinterpretq_f32_m128i(a));
+#endif
+}
+
+// Cast vector of type __m128i to type __m128. This intrinsic is only used for
+// compilation and does not generate any instructions, thus it has zero latency.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_castsi128_ps
+FORCE_INLINE __m128 _mm_castsi128_ps(__m128i a)
+{
+    return vreinterpretq_m128_s32(vreinterpretq_s32_m128i(a));
+}
+
+// Invalidate and flush the cache line that contains p from all levels of the
+// cache hierarchy.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_clflush
+#if defined(__APPLE__)
+#include <libkern/OSCacheControl.h>
+#endif
+FORCE_INLINE void _mm_clflush(void const *p)
+{
+    (void) p;
+
+    /* sys_icache_invalidate is supported since macOS 10.5.
+     * However, it does not work on non-jailbroken iOS devices, although the
+     * compilation is successful.
+     */
+#if defined(__APPLE__)
+    sys_icache_invalidate((void *) (uintptr_t) p, SSE2NEON_CACHELINE_SIZE);
+#elif defined(__GNUC__) || defined(__clang__)
+    uintptr_t ptr = (uintptr_t) p;
+    __builtin___clear_cache((char *) ptr,
+                            (char *) ptr + SSE2NEON_CACHELINE_SIZE);
+#elif (_MSC_VER) && SSE2NEON_INCLUDE_WINDOWS_H
+    FlushInstructionCache(GetCurrentProcess(), p, SSE2NEON_CACHELINE_SIZE);
+#endif
+}
+
+// Compare packed 16-bit integers in a and b for equality, and store the results
+// in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpeq_epi16
+FORCE_INLINE __m128i _mm_cmpeq_epi16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u16(
+        vceqq_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b)));
+}
+
+// Compare packed 32-bit integers in a and b for equality, and store the results
+// in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpeq_epi32
+FORCE_INLINE __m128i _mm_cmpeq_epi32(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u32(
+        vceqq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+}
+
+// Compare packed 8-bit integers in a and b for equality, and store the results
+// in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpeq_epi8
+FORCE_INLINE __m128i _mm_cmpeq_epi8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u8(
+        vceqq_s8(vreinterpretq_s8_m128i(a), vreinterpretq_s8_m128i(b)));
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b
+// for equality, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpeq_pd
+FORCE_INLINE __m128d _mm_cmpeq_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_u64(
+        vceqq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#else
+    // (a == b) -> (a_lo == b_lo) && (a_hi == b_hi)
+    uint32x4_t cmp =
+        vceqq_u32(vreinterpretq_u32_m128d(a), vreinterpretq_u32_m128d(b));
+    uint32x4_t swapped = vrev64q_u32(cmp);
+    return vreinterpretq_m128d_u32(vandq_u32(cmp, swapped));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b for equality, store the result in the lower element of dst, and copy the
+// upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpeq_sd
+FORCE_INLINE __m128d _mm_cmpeq_sd(__m128d a, __m128d b)
+{
+    return _mm_move_sd(a, _mm_cmpeq_pd(a, b));
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b
+// for greater-than-or-equal, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpge_pd
+FORCE_INLINE __m128d _mm_cmpge_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_u64(
+        vcgeq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    uint64_t d[2];
+    d[0] = a0 >= b0 ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = a1 >= b1 ? ~UINT64_C(0) : UINT64_C(0);
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b for greater-than-or-equal, store the result in the lower element of dst,
+// and copy the upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpge_sd
+FORCE_INLINE __m128d _mm_cmpge_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return _mm_move_sd(a, _mm_cmpge_pd(a, b));
+#else
+    // expand "_mm_cmpge_pd()" to reduce unnecessary operations
+    double a0, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    uint64_t a1 = vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1);
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    uint64_t d[2];
+    d[0] = a0 >= b0 ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = a1;
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare packed signed 16-bit integers in a and b for greater-than, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpgt_epi16
+FORCE_INLINE __m128i _mm_cmpgt_epi16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u16(
+        vcgtq_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b)));
+}
+
+// Compare packed signed 32-bit integers in a and b for greater-than, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpgt_epi32
+FORCE_INLINE __m128i _mm_cmpgt_epi32(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u32(
+        vcgtq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+}
+
+// Compare packed signed 8-bit integers in a and b for greater-than, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpgt_epi8
+FORCE_INLINE __m128i _mm_cmpgt_epi8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u8(
+        vcgtq_s8(vreinterpretq_s8_m128i(a), vreinterpretq_s8_m128i(b)));
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b
+// for greater-than, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpgt_pd
+FORCE_INLINE __m128d _mm_cmpgt_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_u64(
+        vcgtq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    uint64_t d[2];
+    d[0] = a0 > b0 ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = a1 > b1 ? ~UINT64_C(0) : UINT64_C(0);
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b for greater-than, store the result in the lower element of dst, and copy
+// the upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpgt_sd
+FORCE_INLINE __m128d _mm_cmpgt_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return _mm_move_sd(a, _mm_cmpgt_pd(a, b));
+#else
+    // expand "_mm_cmpge_pd()" to reduce unnecessary operations
+    double a0, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    uint64_t a1 = vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1);
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    uint64_t d[2];
+    d[0] = a0 > b0 ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = a1;
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b
+// for less-than-or-equal, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmple_pd
+FORCE_INLINE __m128d _mm_cmple_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_u64(
+        vcleq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    uint64_t d[2];
+    d[0] = a0 <= b0 ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = a1 <= b1 ? ~UINT64_C(0) : UINT64_C(0);
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b for less-than-or-equal, store the result in the lower element of dst, and
+// copy the upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmple_sd
+FORCE_INLINE __m128d _mm_cmple_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return _mm_move_sd(a, _mm_cmple_pd(a, b));
+#else
+    // expand "_mm_cmpge_pd()" to reduce unnecessary operations
+    double a0, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    uint64_t a1 = vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1);
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    uint64_t d[2];
+    d[0] = a0 <= b0 ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = a1;
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare packed signed 16-bit integers in a and b for less-than, and store the
+// results in dst. Note: This intrinsic emits the pcmpgtw instruction with the
+// order of the operands switched.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmplt_epi16
+FORCE_INLINE __m128i _mm_cmplt_epi16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u16(
+        vcltq_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b)));
+}
+
+// Compare packed signed 32-bit integers in a and b for less-than, and store the
+// results in dst. Note: This intrinsic emits the pcmpgtd instruction with the
+// order of the operands switched.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmplt_epi32
+FORCE_INLINE __m128i _mm_cmplt_epi32(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u32(
+        vcltq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+}
+
+// Compare packed signed 8-bit integers in a and b for less-than, and store the
+// results in dst. Note: This intrinsic emits the pcmpgtb instruction with the
+// order of the operands switched.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmplt_epi8
+FORCE_INLINE __m128i _mm_cmplt_epi8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u8(
+        vcltq_s8(vreinterpretq_s8_m128i(a), vreinterpretq_s8_m128i(b)));
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b
+// for less-than, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmplt_pd
+FORCE_INLINE __m128d _mm_cmplt_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_u64(
+        vcltq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    uint64_t d[2];
+    d[0] = a0 < b0 ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = a1 < b1 ? ~UINT64_C(0) : UINT64_C(0);
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b for less-than, store the result in the lower element of dst, and copy the
+// upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmplt_sd
+FORCE_INLINE __m128d _mm_cmplt_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return _mm_move_sd(a, _mm_cmplt_pd(a, b));
+#else
+    double a0, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    uint64_t a1 = vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1);
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    uint64_t d[2];
+    d[0] = a0 < b0 ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = a1;
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b
+// for not-equal, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpneq_pd
+FORCE_INLINE __m128d _mm_cmpneq_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_s32(vmvnq_s32(vreinterpretq_s32_u64(
+        vceqq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)))));
+#else
+    // (a == b) -> (a_lo == b_lo) && (a_hi == b_hi)
+    uint32x4_t cmp =
+        vceqq_u32(vreinterpretq_u32_m128d(a), vreinterpretq_u32_m128d(b));
+    uint32x4_t swapped = vrev64q_u32(cmp);
+    return vreinterpretq_m128d_u32(vmvnq_u32(vandq_u32(cmp, swapped)));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b for not-equal, store the result in the lower element of dst, and copy the
+// upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpneq_sd
+FORCE_INLINE __m128d _mm_cmpneq_sd(__m128d a, __m128d b)
+{
+    return _mm_move_sd(a, _mm_cmpneq_pd(a, b));
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b
+// for not-greater-than-or-equal, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpnge_pd
+FORCE_INLINE __m128d _mm_cmpnge_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_u64(veorq_u64(
+        vcgeq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)),
+        vdupq_n_u64(UINT64_MAX)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    uint64_t d[2];
+    d[0] = !(a0 >= b0) ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = !(a1 >= b1) ? ~UINT64_C(0) : UINT64_C(0);
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b for not-greater-than-or-equal, store the result in the lower element of
+// dst, and copy the upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpnge_sd
+FORCE_INLINE __m128d _mm_cmpnge_sd(__m128d a, __m128d b)
+{
+    return _mm_move_sd(a, _mm_cmpnge_pd(a, b));
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b
+// for not-greater-than, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_cmpngt_pd
+FORCE_INLINE __m128d _mm_cmpngt_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_u64(veorq_u64(
+        vcgtq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)),
+        vdupq_n_u64(UINT64_MAX)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    uint64_t d[2];
+    d[0] = !(a0 > b0) ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = !(a1 > b1) ? ~UINT64_C(0) : UINT64_C(0);
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b for not-greater-than, store the result in the lower element of dst, and
+// copy the upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpngt_sd
+FORCE_INLINE __m128d _mm_cmpngt_sd(__m128d a, __m128d b)
+{
+    return _mm_move_sd(a, _mm_cmpngt_pd(a, b));
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b
+// for not-less-than-or-equal, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpnle_pd
+FORCE_INLINE __m128d _mm_cmpnle_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_u64(veorq_u64(
+        vcleq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)),
+        vdupq_n_u64(UINT64_MAX)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    uint64_t d[2];
+    d[0] = !(a0 <= b0) ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = !(a1 <= b1) ? ~UINT64_C(0) : UINT64_C(0);
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b for not-less-than-or-equal, store the result in the lower element of dst,
+// and copy the upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpnle_sd
+FORCE_INLINE __m128d _mm_cmpnle_sd(__m128d a, __m128d b)
+{
+    return _mm_move_sd(a, _mm_cmpnle_pd(a, b));
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b
+// for not-less-than, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpnlt_pd
+FORCE_INLINE __m128d _mm_cmpnlt_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_u64(veorq_u64(
+        vcltq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)),
+        vdupq_n_u64(UINT64_MAX)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    uint64_t d[2];
+    d[0] = !(a0 < b0) ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = !(a1 < b1) ? ~UINT64_C(0) : UINT64_C(0);
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b for not-less-than, store the result in the lower element of dst, and copy
+// the upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpnlt_sd
+FORCE_INLINE __m128d _mm_cmpnlt_sd(__m128d a, __m128d b)
+{
+    return _mm_move_sd(a, _mm_cmpnlt_pd(a, b));
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b
+// to see if neither is NaN, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpord_pd
+FORCE_INLINE __m128d _mm_cmpord_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    // Excluding NaNs, any two floating point numbers can be compared.
+    uint64x2_t not_nan_a =
+        vceqq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(a));
+    uint64x2_t not_nan_b =
+        vceqq_f64(vreinterpretq_f64_m128d(b), vreinterpretq_f64_m128d(b));
+    return vreinterpretq_m128d_u64(vandq_u64(not_nan_a, not_nan_b));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    uint64_t d[2];
+    d[0] = (a0 == a0 && b0 == b0) ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = (a1 == a1 && b1 == b1) ? ~UINT64_C(0) : UINT64_C(0);
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b to see if neither is NaN, store the result in the lower element of dst, and
+// copy the upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpord_sd
+FORCE_INLINE __m128d _mm_cmpord_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return _mm_move_sd(a, _mm_cmpord_pd(a, b));
+#else
+    double a0, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    uint64_t a1 = vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1);
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    uint64_t d[2];
+    d[0] = (a0 == a0 && b0 == b0) ? ~UINT64_C(0) : UINT64_C(0);
+    d[1] = a1;
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b
+// to see if either is NaN, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpunord_pd
+FORCE_INLINE __m128d _mm_cmpunord_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    // Two NaNs are not equal in comparison operation.
+    uint64x2_t not_nan_a =
+        vceqq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(a));
+    uint64x2_t not_nan_b =
+        vceqq_f64(vreinterpretq_f64_m128d(b), vreinterpretq_f64_m128d(b));
+    return vreinterpretq_m128d_s32(
+        vmvnq_s32(vreinterpretq_s32_u64(vandq_u64(not_nan_a, not_nan_b))));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    uint64_t d[2];
+    d[0] = (a0 == a0 && b0 == b0) ? UINT64_C(0) : ~UINT64_C(0);
+    d[1] = (a1 == a1 && b1 == b1) ? UINT64_C(0) : ~UINT64_C(0);
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b to see if either is NaN, store the result in the lower element of dst, and
+// copy the upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpunord_sd
+FORCE_INLINE __m128d _mm_cmpunord_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return _mm_move_sd(a, _mm_cmpunord_pd(a, b));
+#else
+    double a0, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    uint64_t a1 = vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1);
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    uint64_t d[2];
+    d[0] = (a0 == a0 && b0 == b0) ? UINT64_C(0) : ~UINT64_C(0);
+    d[1] = a1;
+
+    return vreinterpretq_m128d_u64(vld1q_u64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point element in a and b
+// for greater-than-or-equal, and return the boolean result (0 or 1).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_comige_sd
+FORCE_INLINE int _mm_comige_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vgetq_lane_u64(vcgeq_f64(a, b), 0) & 0x1;
+#else
+    double a0, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    return a0 >= b0;
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point element in a and b
+// for greater-than, and return the boolean result (0 or 1).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_comigt_sd
+FORCE_INLINE int _mm_comigt_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vgetq_lane_u64(vcgtq_f64(a, b), 0) & 0x1;
+#else
+    double a0, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+
+    return a0 > b0;
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point element in a and b
+// for less-than-or-equal, and return the boolean result (0 or 1).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_comile_sd
+FORCE_INLINE int _mm_comile_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vgetq_lane_u64(vcleq_f64(a, b), 0) & 0x1;
+#else
+    double a0, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+
+    return a0 <= b0;
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point element in a and b
+// for less-than, and return the boolean result (0 or 1).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_comilt_sd
+FORCE_INLINE int _mm_comilt_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vgetq_lane_u64(vcltq_f64(a, b), 0) & 0x1;
+#else
+    double a0, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+
+    return a0 < b0;
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point element in a and b
+// for equality, and return the boolean result (0 or 1).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_comieq_sd
+FORCE_INLINE int _mm_comieq_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vgetq_lane_u64(vceqq_f64(a, b), 0) & 0x1;
+#else
+    uint32x4_t a_not_nan =
+        vceqq_u32(vreinterpretq_u32_m128d(a), vreinterpretq_u32_m128d(a));
+    uint32x4_t b_not_nan =
+        vceqq_u32(vreinterpretq_u32_m128d(b), vreinterpretq_u32_m128d(b));
+    uint32x4_t a_and_b_not_nan = vandq_u32(a_not_nan, b_not_nan);
+    uint32x4_t a_eq_b =
+        vceqq_u32(vreinterpretq_u32_m128d(a), vreinterpretq_u32_m128d(b));
+    uint64x2_t and_results = vandq_u64(vreinterpretq_u64_u32(a_and_b_not_nan),
+                                       vreinterpretq_u64_u32(a_eq_b));
+    return vgetq_lane_u64(and_results, 0) & 0x1;
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point element in a and b
+// for not-equal, and return the boolean result (0 or 1).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_comineq_sd
+FORCE_INLINE int _mm_comineq_sd(__m128d a, __m128d b)
+{
+    return !_mm_comieq_sd(a, b);
+}
+
+// Convert packed signed 32-bit integers in a to packed double-precision
+// (64-bit) floating-point elements, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepi32_pd
+FORCE_INLINE __m128d _mm_cvtepi32_pd(__m128i a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vcvtq_f64_s64(vmovl_s32(vget_low_s32(vreinterpretq_s32_m128i(a)))));
+#else
+    double a0 = (double) vgetq_lane_s32(vreinterpretq_s32_m128i(a), 0);
+    double a1 = (double) vgetq_lane_s32(vreinterpretq_s32_m128i(a), 1);
+    return _mm_set_pd(a1, a0);
+#endif
+}
+
+// Convert packed signed 32-bit integers in a to packed single-precision
+// (32-bit) floating-point elements, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepi32_ps
+FORCE_INLINE __m128 _mm_cvtepi32_ps(__m128i a)
+{
+    return vreinterpretq_m128_f32(vcvtq_f32_s32(vreinterpretq_s32_m128i(a)));
+}
+
+// Convert packed double-precision (64-bit) floating-point elements in a to
+// packed 32-bit integers, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtpd_epi32
+FORCE_INLINE_OPTNONE __m128i _mm_cvtpd_epi32(__m128d a)
+{
+// vrnd32xq_f64 not supported on clang
+#if defined(__ARM_FEATURE_FRINT) && !defined(__clang__)
+    float64x2_t rounded = vrnd32xq_f64(vreinterpretq_f64_m128d(a));
+    int64x2_t integers = vcvtq_s64_f64(rounded);
+    return vreinterpretq_m128i_s32(
+        vcombine_s32(vmovn_s64(integers), vdup_n_s32(0)));
+#else
+    __m128d rnd = _mm_round_pd(a, _MM_FROUND_CUR_DIRECTION);
+    double d0, d1;
+    d0 = sse2neon_recast_u64_f64(
+        vgetq_lane_u64(vreinterpretq_u64_m128d(rnd), 0));
+    d1 = sse2neon_recast_u64_f64(
+        vgetq_lane_u64(vreinterpretq_u64_m128d(rnd), 1));
+    return _mm_set_epi32(0, 0, (int32_t) d1, (int32_t) d0);
+#endif
+}
+
+// Convert packed double-precision (64-bit) floating-point elements in a to
+// packed 32-bit integers, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtpd_pi32
+FORCE_INLINE_OPTNONE __m64 _mm_cvtpd_pi32(__m128d a)
+{
+    __m128d rnd = _mm_round_pd(a, _MM_FROUND_CUR_DIRECTION);
+    double d0, d1;
+    d0 = sse2neon_recast_u64_f64(
+        vgetq_lane_u64(vreinterpretq_u64_m128d(rnd), 0));
+    d1 = sse2neon_recast_u64_f64(
+        vgetq_lane_u64(vreinterpretq_u64_m128d(rnd), 1));
+    int32_t ALIGN_STRUCT(16) data[2] = {(int32_t) d0, (int32_t) d1};
+    return vreinterpret_m64_s32(vld1_s32(data));
+}
+
+// Convert packed double-precision (64-bit) floating-point elements in a to
+// packed single-precision (32-bit) floating-point elements, and store the
+// results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtpd_ps
+FORCE_INLINE __m128 _mm_cvtpd_ps(__m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    float32x2_t tmp = vcvt_f32_f64(vreinterpretq_f64_m128d(a));
+    return vreinterpretq_m128_f32(vcombine_f32(tmp, vdup_n_f32(0)));
+#else
+    double a0, a1;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    a1 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    return _mm_set_ps(0, 0, (float) a1, (float) a0);
+#endif
+}
+
+// Convert packed signed 32-bit integers in a to packed double-precision
+// (64-bit) floating-point elements, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtpi32_pd
+FORCE_INLINE __m128d _mm_cvtpi32_pd(__m64 a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vcvtq_f64_s64(vmovl_s32(vreinterpret_s32_m64(a))));
+#else
+    double a0 = (double) vget_lane_s32(vreinterpret_s32_m64(a), 0);
+    double a1 = (double) vget_lane_s32(vreinterpret_s32_m64(a), 1);
+    return _mm_set_pd(a1, a0);
+#endif
+}
+
+// Convert packed single-precision (32-bit) floating-point elements in a to
+// packed 32-bit integers, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtps_epi32
+// *NOTE*. The default rounding mode on SSE is 'round to even', which ARMv7-A
+// does not support! It is supported on ARMv8-A however.
+FORCE_INLINE __m128i _mm_cvtps_epi32(__m128 a)
+{
+#if defined(__ARM_FEATURE_FRINT)
+    return vreinterpretq_m128i_s32(vcvtq_s32_f32(vrnd32xq_f32(a)));
+#elif (defined(__aarch64__) || defined(_M_ARM64)) || \
+    defined(__ARM_FEATURE_DIRECTED_ROUNDING)
+    switch (_MM_GET_ROUNDING_MODE()) {
+    case _MM_ROUND_NEAREST:
+        return vreinterpretq_m128i_s32(vcvtnq_s32_f32(a));
+    case _MM_ROUND_DOWN:
+        return vreinterpretq_m128i_s32(vcvtmq_s32_f32(a));
+    case _MM_ROUND_UP:
+        return vreinterpretq_m128i_s32(vcvtpq_s32_f32(a));
+    default:  // _MM_ROUND_TOWARD_ZERO
+        return vreinterpretq_m128i_s32(vcvtq_s32_f32(a));
+    }
+#else
+    float *f = (float *) &a;
+    switch (_MM_GET_ROUNDING_MODE()) {
+    case _MM_ROUND_NEAREST: {
+        uint32x4_t signmask = vdupq_n_u32(0x80000000);
+        float32x4_t half = vbslq_f32(signmask, vreinterpretq_f32_m128(a),
+                                     vdupq_n_f32(0.5f)); /* +/- 0.5 */
+        int32x4_t r_normal = vcvtq_s32_f32(vaddq_f32(
+            vreinterpretq_f32_m128(a), half)); /* round to integer: [a + 0.5]*/
+        int32x4_t r_trunc = vcvtq_s32_f32(
+            vreinterpretq_f32_m128(a)); /* truncate to integer: [a] */
+        int32x4_t plusone = vreinterpretq_s32_u32(vshrq_n_u32(
+            vreinterpretq_u32_s32(vnegq_s32(r_trunc)), 31)); /* 1 or 0 */
+        int32x4_t r_even = vbicq_s32(vaddq_s32(r_trunc, plusone),
+                                     vdupq_n_s32(1)); /* ([a] + {0,1}) & ~1 */
+        float32x4_t delta = vsubq_f32(
+            vreinterpretq_f32_m128(a),
+            vcvtq_f32_s32(r_trunc)); /* compute delta: delta = (a - [a]) */
+        uint32x4_t is_delta_half =
+            vceqq_f32(delta, half); /* delta == +/- 0.5 */
+        return vreinterpretq_m128i_s32(
+            vbslq_s32(is_delta_half, r_even, r_normal));
+    }
+    case _MM_ROUND_DOWN:
+        return _mm_set_epi32(floorf(f[3]), floorf(f[2]), floorf(f[1]),
+                             floorf(f[0]));
+    case _MM_ROUND_UP:
+        return _mm_set_epi32(ceilf(f[3]), ceilf(f[2]), ceilf(f[1]),
+                             ceilf(f[0]));
+    default:  // _MM_ROUND_TOWARD_ZERO
+        return _mm_set_epi32((int32_t) f[3], (int32_t) f[2], (int32_t) f[1],
+                             (int32_t) f[0]);
+    }
+#endif
+}
+
+// Convert packed single-precision (32-bit) floating-point elements in a to
+// packed double-precision (64-bit) floating-point elements, and store the
+// results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtps_pd
+FORCE_INLINE __m128d _mm_cvtps_pd(__m128 a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vcvt_f64_f32(vget_low_f32(vreinterpretq_f32_m128(a))));
+#else
+    double a0 = (double) vgetq_lane_f32(vreinterpretq_f32_m128(a), 0);
+    double a1 = (double) vgetq_lane_f32(vreinterpretq_f32_m128(a), 1);
+    return _mm_set_pd(a1, a0);
+#endif
+}
+
+// Copy the lower double-precision (64-bit) floating-point element of a to dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsd_f64
+FORCE_INLINE double _mm_cvtsd_f64(__m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return (double) vgetq_lane_f64(vreinterpretq_f64_m128d(a), 0);
+#else
+    double _a =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    return _a;
+#endif
+}
+
+// Convert the lower double-precision (64-bit) floating-point element in a to a
+// 32-bit integer, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsd_si32
+FORCE_INLINE int32_t _mm_cvtsd_si32(__m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return (int32_t) vgetq_lane_f64(vrndiq_f64(vreinterpretq_f64_m128d(a)), 0);
+#else
+    __m128d rnd = _mm_round_pd(a, _MM_FROUND_CUR_DIRECTION);
+    double ret = sse2neon_recast_u64_f64(
+        vgetq_lane_u64(vreinterpretq_u64_m128d(rnd), 0));
+    return (int32_t) ret;
+#endif
+}
+
+// Convert the lower double-precision (64-bit) floating-point element in a to a
+// 64-bit integer, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsd_si64
+FORCE_INLINE int64_t _mm_cvtsd_si64(__m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return (int64_t) vgetq_lane_f64(vrndiq_f64(vreinterpretq_f64_m128d(a)), 0);
+#else
+    __m128d rnd = _mm_round_pd(a, _MM_FROUND_CUR_DIRECTION);
+    double ret = sse2neon_recast_u64_f64(
+        vgetq_lane_u64(vreinterpretq_u64_m128d(rnd), 0));
+    return (int64_t) ret;
+#endif
+}
+
+// Convert the lower double-precision (64-bit) floating-point element in a to a
+// 64-bit integer, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsd_si64x
+#define _mm_cvtsd_si64x _mm_cvtsd_si64
+
+// Convert the lower double-precision (64-bit) floating-point element in b to a
+// single-precision (32-bit) floating-point element, store the result in the
+// lower element of dst, and copy the upper 3 packed elements from a to the
+// upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsd_ss
+FORCE_INLINE __m128 _mm_cvtsd_ss(__m128 a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128_f32(vsetq_lane_f32(
+        vget_lane_f32(vcvt_f32_f64(vreinterpretq_f64_m128d(b)), 0),
+        vreinterpretq_f32_m128(a), 0));
+#else
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    return vreinterpretq_m128_f32(
+        vsetq_lane_f32((float) b0, vreinterpretq_f32_m128(a), 0));
+#endif
+}
+
+// Copy the lower 32-bit integer in a to dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsi128_si32
+FORCE_INLINE int _mm_cvtsi128_si32(__m128i a)
+{
+    return vgetq_lane_s32(vreinterpretq_s32_m128i(a), 0);
+}
+
+// Copy the lower 64-bit integer in a to dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsi128_si64
+FORCE_INLINE int64_t _mm_cvtsi128_si64(__m128i a)
+{
+    return vgetq_lane_s64(vreinterpretq_s64_m128i(a), 0);
+}
+
+// Copy the lower 64-bit integer in a to dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsi128_si64x
+#define _mm_cvtsi128_si64x(a) _mm_cvtsi128_si64(a)
+
+// Convert the signed 32-bit integer b to a double-precision (64-bit)
+// floating-point element, store the result in the lower element of dst, and
+// copy the upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsi32_sd
+FORCE_INLINE __m128d _mm_cvtsi32_sd(__m128d a, int32_t b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vsetq_lane_f64((double) b, vreinterpretq_f64_m128d(a), 0));
+#else
+    int64_t _b = sse2neon_recast_f64_s64((double) b);
+    return vreinterpretq_m128d_s64(
+        vsetq_lane_s64(_b, vreinterpretq_s64_m128d(a), 0));
+#endif
+}
+
+// Copy the lower 64-bit integer in a to dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsi128_si64x
+#define _mm_cvtsi128_si64x(a) _mm_cvtsi128_si64(a)
+
+// Copy 32-bit integer a to the lower elements of dst, and zero the upper
+// elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsi32_si128
+FORCE_INLINE __m128i _mm_cvtsi32_si128(int a)
+{
+    return vreinterpretq_m128i_s32(vsetq_lane_s32(a, vdupq_n_s32(0), 0));
+}
+
+// Convert the signed 64-bit integer b to a double-precision (64-bit)
+// floating-point element, store the result in the lower element of dst, and
+// copy the upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsi64_sd
+FORCE_INLINE __m128d _mm_cvtsi64_sd(__m128d a, int64_t b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vsetq_lane_f64((double) b, vreinterpretq_f64_m128d(a), 0));
+#else
+    int64_t _b = sse2neon_recast_f64_s64((double) b);
+    return vreinterpretq_m128d_s64(
+        vsetq_lane_s64(_b, vreinterpretq_s64_m128d(a), 0));
+#endif
+}
+
+// Copy 64-bit integer a to the lower element of dst, and zero the upper
+// element.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsi64_si128
+FORCE_INLINE __m128i _mm_cvtsi64_si128(int64_t a)
+{
+    return vreinterpretq_m128i_s64(vsetq_lane_s64(a, vdupq_n_s64(0), 0));
+}
+
+// Copy 64-bit integer a to the lower element of dst, and zero the upper
+// element.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsi64x_si128
+#define _mm_cvtsi64x_si128(a) _mm_cvtsi64_si128(a)
+
+// Convert the signed 64-bit integer b to a double-precision (64-bit)
+// floating-point element, store the result in the lower element of dst, and
+// copy the upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtsi64x_sd
+#define _mm_cvtsi64x_sd(a, b) _mm_cvtsi64_sd(a, b)
+
+// Convert the lower single-precision (32-bit) floating-point element in b to a
+// double-precision (64-bit) floating-point element, store the result in the
+// lower element of dst, and copy the upper element from a to the upper element
+// of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtss_sd
+FORCE_INLINE __m128d _mm_cvtss_sd(__m128d a, __m128 b)
+{
+    double d = (double) vgetq_lane_f32(vreinterpretq_f32_m128(b), 0);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vsetq_lane_f64(d, vreinterpretq_f64_m128d(a), 0));
+#else
+    return vreinterpretq_m128d_s64(vsetq_lane_s64(
+        sse2neon_recast_f64_s64(d), vreinterpretq_s64_m128d(a), 0));
+#endif
+}
+
+// Convert packed double-precision (64-bit) floating-point elements in a to
+// packed 32-bit integers with truncation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvttpd_epi32
+FORCE_INLINE __m128i _mm_cvttpd_epi32(__m128d a)
+{
+    double a0, a1;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    a1 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    return _mm_set_epi32(0, 0, (int32_t) a1, (int32_t) a0);
+}
+
+// Convert packed double-precision (64-bit) floating-point elements in a to
+// packed 32-bit integers with truncation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvttpd_pi32
+FORCE_INLINE_OPTNONE __m64 _mm_cvttpd_pi32(__m128d a)
+{
+    double a0, a1;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    a1 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    int32_t ALIGN_STRUCT(16) data[2] = {(int32_t) a0, (int32_t) a1};
+    return vreinterpret_m64_s32(vld1_s32(data));
+}
+
+// Convert packed single-precision (32-bit) floating-point elements in a to
+// packed 32-bit integers with truncation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvttps_epi32
+FORCE_INLINE __m128i _mm_cvttps_epi32(__m128 a)
+{
+    return vreinterpretq_m128i_s32(vcvtq_s32_f32(vreinterpretq_f32_m128(a)));
+}
+
+// Convert the lower double-precision (64-bit) floating-point element in a to a
+// 32-bit integer with truncation, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvttsd_si32
+FORCE_INLINE int32_t _mm_cvttsd_si32(__m128d a)
+{
+    double _a =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    return (int32_t) _a;
+}
+
+// Convert the lower double-precision (64-bit) floating-point element in a to a
+// 64-bit integer with truncation, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvttsd_si64
+FORCE_INLINE int64_t _mm_cvttsd_si64(__m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vgetq_lane_s64(vcvtq_s64_f64(vreinterpretq_f64_m128d(a)), 0);
+#else
+    double _a =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    return (int64_t) _a;
+#endif
+}
+
+// Convert the lower double-precision (64-bit) floating-point element in a to a
+// 64-bit integer with truncation, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvttsd_si64x
+#define _mm_cvttsd_si64x(a) _mm_cvttsd_si64(a)
+
+// Divide packed double-precision (64-bit) floating-point elements in a by
+// packed elements in b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_div_pd
+FORCE_INLINE __m128d _mm_div_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vdivq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    double c[2];
+    c[0] = a0 / b0;
+    c[1] = a1 / b1;
+    return vld1q_f32((float32_t *) c);
+#endif
+}
+
+// Divide the lower double-precision (64-bit) floating-point element in a by the
+// lower double-precision (64-bit) floating-point element in b, store the result
+// in the lower element of dst, and copy the upper element from a to the upper
+// element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_div_sd
+FORCE_INLINE __m128d _mm_div_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    float64x2_t tmp =
+        vdivq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b));
+    return vreinterpretq_m128d_f64(
+        vsetq_lane_f64(vgetq_lane_f64(vreinterpretq_f64_m128d(a), 1), tmp, 1));
+#else
+    return _mm_move_sd(a, _mm_div_pd(a, b));
+#endif
+}
+
+// Extract a 16-bit integer from a, selected with imm8, and store the result in
+// the lower element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_extract_epi16
+// FORCE_INLINE int _mm_extract_epi16(__m128i a, __constrange(0,8) int imm)
+#define _mm_extract_epi16(a, imm) \
+    vgetq_lane_u16(vreinterpretq_u16_m128i(a), (imm))
+
+// Copy a to dst, and insert the 16-bit integer i into dst at the location
+// specified by imm8.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_insert_epi16
+// FORCE_INLINE __m128i _mm_insert_epi16(__m128i a, int b,
+//                                       __constrange(0,8) int imm)
+#define _mm_insert_epi16(a, b, imm) \
+    vreinterpretq_m128i_s16(        \
+        vsetq_lane_s16((b), vreinterpretq_s16_m128i(a), (imm)))
+
+// Load 128-bits (composed of 2 packed double-precision (64-bit) floating-point
+// elements) from memory into dst. mem_addr must be aligned on a 16-byte
+// boundary or a general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_load_pd
+FORCE_INLINE __m128d _mm_load_pd(const double *p)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(vld1q_f64(p));
+#else
+    const float *fp = (const float *) p;
+    float ALIGN_STRUCT(16) data[4] = {fp[0], fp[1], fp[2], fp[3]};
+    return vreinterpretq_m128d_f32(vld1q_f32(data));
+#endif
+}
+
+// Load a double-precision (64-bit) floating-point element from memory into both
+// elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_load_pd1
+#define _mm_load_pd1 _mm_load1_pd
+
+// Load a double-precision (64-bit) floating-point element from memory into the
+// lower of dst, and zero the upper element. mem_addr does not need to be
+// aligned on any particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_load_sd
+FORCE_INLINE __m128d _mm_load_sd(const double *p)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(vsetq_lane_f64(*p, vdupq_n_f64(0), 0));
+#else
+    const float *fp = (const float *) p;
+    float ALIGN_STRUCT(16) data[4] = {fp[0], fp[1], 0, 0};
+    return vreinterpretq_m128d_f32(vld1q_f32(data));
+#endif
+}
+
+// Load 128-bits of integer data from memory into dst. mem_addr must be aligned
+// on a 16-byte boundary or a general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_load_si128
+FORCE_INLINE __m128i _mm_load_si128(const __m128i *p)
+{
+    return vreinterpretq_m128i_s32(vld1q_s32((const int32_t *) p));
+}
+
+// Load a double-precision (64-bit) floating-point element from memory into both
+// elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_load1_pd
+FORCE_INLINE __m128d _mm_load1_pd(const double *p)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(vld1q_dup_f64(p));
+#else
+    return vreinterpretq_m128d_s64(vdupq_n_s64(*(const int64_t *) p));
+#endif
+}
+
+// Load a double-precision (64-bit) floating-point element from memory into the
+// upper element of dst, and copy the lower element from a to dst. mem_addr does
+// not need to be aligned on any particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadh_pd
+FORCE_INLINE __m128d _mm_loadh_pd(__m128d a, const double *p)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vcombine_f64(vget_low_f64(vreinterpretq_f64_m128d(a)), vld1_f64(p)));
+#else
+    return vreinterpretq_m128d_f32(vcombine_f32(
+        vget_low_f32(vreinterpretq_f32_m128d(a)), vld1_f32((const float *) p)));
+#endif
+}
+
+// Load 64-bit integer from memory into the first element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadl_epi64
+FORCE_INLINE __m128i _mm_loadl_epi64(__m128i const *p)
+{
+    /* Load the lower 64 bits of the value pointed to by p into the
+     * lower 64 bits of the result, zeroing the upper 64 bits of the result.
+     */
+    return vreinterpretq_m128i_s32(
+        vcombine_s32(vld1_s32((int32_t const *) p), vcreate_s32(0)));
+}
+
+// Load a double-precision (64-bit) floating-point element from memory into the
+// lower element of dst, and copy the upper element from a to dst. mem_addr does
+// not need to be aligned on any particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadl_pd
+FORCE_INLINE __m128d _mm_loadl_pd(__m128d a, const double *p)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vcombine_f64(vld1_f64(p), vget_high_f64(vreinterpretq_f64_m128d(a))));
+#else
+    return vreinterpretq_m128d_f32(
+        vcombine_f32(vld1_f32((const float *) p),
+                     vget_high_f32(vreinterpretq_f32_m128d(a))));
+#endif
+}
+
+// Load 2 double-precision (64-bit) floating-point elements from memory into dst
+// in reverse order. mem_addr must be aligned on a 16-byte boundary or a
+// general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadr_pd
+FORCE_INLINE __m128d _mm_loadr_pd(const double *p)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    float64x2_t v = vld1q_f64(p);
+    return vreinterpretq_m128d_f64(vextq_f64(v, v, 1));
+#else
+    int64x2_t v = vld1q_s64((const int64_t *) p);
+    return vreinterpretq_m128d_s64(vextq_s64(v, v, 1));
+#endif
+}
+
+// Loads two double-precision from unaligned memory, floating-point values.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadu_pd
+FORCE_INLINE __m128d _mm_loadu_pd(const double *p)
+{
+    return _mm_load_pd(p);
+}
+
+// Load 128-bits of integer data from memory into dst. mem_addr does not need to
+// be aligned on any particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadu_si128
+FORCE_INLINE __m128i _mm_loadu_si128(const __m128i *p)
+{
+    return vreinterpretq_m128i_s32(vld1q_s32((const unaligned_int32_t *) p));
+}
+
+// Load unaligned 32-bit integer from memory into the first element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loadu_si32
+FORCE_INLINE __m128i _mm_loadu_si32(const void *p)
+{
+    return vreinterpretq_m128i_s32(
+        vsetq_lane_s32(*(const unaligned_int32_t *) p, vdupq_n_s32(0), 0));
+}
+
+// Multiply packed signed 16-bit integers in a and b, producing intermediate
+// signed 32-bit integers. Horizontally add adjacent pairs of intermediate
+// 32-bit integers, and pack the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_madd_epi16
+FORCE_INLINE __m128i _mm_madd_epi16(__m128i a, __m128i b)
+{
+    int32x4_t low = vmull_s16(vget_low_s16(vreinterpretq_s16_m128i(a)),
+                              vget_low_s16(vreinterpretq_s16_m128i(b)));
+#if defined(__aarch64__) || defined(_M_ARM64)
+    int32x4_t high =
+        vmull_high_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b));
+
+    return vreinterpretq_m128i_s32(vpaddq_s32(low, high));
+#else
+    int32x4_t high = vmull_s16(vget_high_s16(vreinterpretq_s16_m128i(a)),
+                               vget_high_s16(vreinterpretq_s16_m128i(b)));
+
+    int32x2_t low_sum = vpadd_s32(vget_low_s32(low), vget_high_s32(low));
+    int32x2_t high_sum = vpadd_s32(vget_low_s32(high), vget_high_s32(high));
+
+    return vreinterpretq_m128i_s32(vcombine_s32(low_sum, high_sum));
+#endif
+}
+
+// Conditionally store 8-bit integer elements from a into memory using mask
+// (elements are not stored when the highest bit is not set in the corresponding
+// element) and a non-temporal memory hint. mem_addr does not need to be aligned
+// on any particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_maskmoveu_si128
+FORCE_INLINE void _mm_maskmoveu_si128(__m128i a, __m128i mask, char *mem_addr)
+{
+    int8x16_t shr_mask = vshrq_n_s8(vreinterpretq_s8_m128i(mask), 7);
+    __m128 b = _mm_load_ps((const float *) mem_addr);
+    int8x16_t masked =
+        vbslq_s8(vreinterpretq_u8_s8(shr_mask), vreinterpretq_s8_m128i(a),
+                 vreinterpretq_s8_m128(b));
+    vst1q_s8((int8_t *) mem_addr, masked);
+}
+
+// Compare packed signed 16-bit integers in a and b, and store packed maximum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_epi16
+FORCE_INLINE __m128i _mm_max_epi16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s16(
+        vmaxq_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b)));
+}
+
+// Compare packed unsigned 8-bit integers in a and b, and store packed maximum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_epu8
+FORCE_INLINE __m128i _mm_max_epu8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u8(
+        vmaxq_u8(vreinterpretq_u8_m128i(a), vreinterpretq_u8_m128i(b)));
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b,
+// and store packed maximum values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_pd
+FORCE_INLINE __m128d _mm_max_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+#if SSE2NEON_PRECISE_MINMAX
+    float64x2_t _a = vreinterpretq_f64_m128d(a);
+    float64x2_t _b = vreinterpretq_f64_m128d(b);
+    return vreinterpretq_m128d_f64(vbslq_f64(vcgtq_f64(_a, _b), _a, _b));
+#else
+    return vreinterpretq_m128d_f64(
+        vmaxq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#endif
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    int64_t d[2];
+    d[0] = a0 > b0 ? sse2neon_recast_f64_s64(a0) : sse2neon_recast_f64_s64(b0);
+    d[1] = a1 > b1 ? sse2neon_recast_f64_s64(a1) : sse2neon_recast_f64_s64(b1);
+
+    return vreinterpretq_m128d_s64(vld1q_s64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b, store the maximum value in the lower element of dst, and copy the upper
+// element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_sd
+FORCE_INLINE __m128d _mm_max_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return _mm_move_sd(a, _mm_max_pd(a, b));
+#else
+    double a0, a1, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    a1 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double c[2] = {a0 > b0 ? a0 : b0, a1};
+    return vreinterpretq_m128d_f32(vld1q_f32((float32_t *) c));
+#endif
+}
+
+// Compare packed signed 16-bit integers in a and b, and store packed minimum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_min_epi16
+FORCE_INLINE __m128i _mm_min_epi16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s16(
+        vminq_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b)));
+}
+
+// Compare packed unsigned 8-bit integers in a and b, and store packed minimum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_min_epu8
+FORCE_INLINE __m128i _mm_min_epu8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u8(
+        vminq_u8(vreinterpretq_u8_m128i(a), vreinterpretq_u8_m128i(b)));
+}
+
+// Compare packed double-precision (64-bit) floating-point elements in a and b,
+// and store packed minimum values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_min_pd
+FORCE_INLINE __m128d _mm_min_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+#if SSE2NEON_PRECISE_MINMAX
+    float64x2_t _a = vreinterpretq_f64_m128d(a);
+    float64x2_t _b = vreinterpretq_f64_m128d(b);
+    return vreinterpretq_m128d_f64(vbslq_f64(vcltq_f64(_a, _b), _a, _b));
+#else
+    return vreinterpretq_m128d_f64(
+        vminq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#endif
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    int64_t d[2];
+    d[0] = a0 < b0 ? sse2neon_recast_f64_s64(a0) : sse2neon_recast_f64_s64(b0);
+    d[1] = a1 < b1 ? sse2neon_recast_f64_s64(a1) : sse2neon_recast_f64_s64(b1);
+    return vreinterpretq_m128d_s64(vld1q_s64(d));
+#endif
+}
+
+// Compare the lower double-precision (64-bit) floating-point elements in a and
+// b, store the minimum value in the lower element of dst, and copy the upper
+// element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_min_sd
+FORCE_INLINE __m128d _mm_min_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return _mm_move_sd(a, _mm_min_pd(a, b));
+#else
+    double a0, a1, b0;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    a1 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    b0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double c[2] = {a0 < b0 ? a0 : b0, a1};
+    return vreinterpretq_m128d_f32(vld1q_f32((float32_t *) c));
+#endif
+}
+
+// Copy the lower 64-bit integer in a to the lower element of dst, and zero the
+// upper element.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_move_epi64
+FORCE_INLINE __m128i _mm_move_epi64(__m128i a)
+{
+    return vreinterpretq_m128i_s64(
+        vsetq_lane_s64(0, vreinterpretq_s64_m128i(a), 1));
+}
+
+// Move the lower double-precision (64-bit) floating-point element from b to the
+// lower element of dst, and copy the upper element from a to the upper element
+// of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_move_sd
+FORCE_INLINE __m128d _mm_move_sd(__m128d a, __m128d b)
+{
+    return vreinterpretq_m128d_f32(
+        vcombine_f32(vget_low_f32(vreinterpretq_f32_m128d(b)),
+                     vget_high_f32(vreinterpretq_f32_m128d(a))));
+}
+
+// Create mask from the most significant bit of each 8-bit element in a, and
+// store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_movemask_epi8
+FORCE_INLINE int _mm_movemask_epi8(__m128i a)
+{
+    // Use increasingly wide shifts+adds to collect the sign bits
+    // together.
+    // Since the widening shifts would be rather confusing to follow in little
+    // endian, everything will be illustrated in big endian order instead. This
+    // has a different result - the bits would actually be reversed on a big
+    // endian machine.
+
+    // Starting input (only half the elements are shown):
+    // 89 ff 1d c0 00 10 99 33
+    uint8x16_t input = vreinterpretq_u8_m128i(a);
+
+    // Shift out everything but the sign bits with an unsigned shift right.
+    //
+    // Bytes of the vector::
+    // 89 ff 1d c0 00 10 99 33
+    // \  \  \  \  \  \  \  \    high_bits = (uint16x4_t)(input >> 7)
+    //  |  |  |  |  |  |  |  |
+    // 01 01 00 01 00 00 01 00
+    //
+    // Bits of first important lane(s):
+    // 10001001 (89)
+    // \______
+    //        |
+    // 00000001 (01)
+    uint16x8_t high_bits = vreinterpretq_u16_u8(vshrq_n_u8(input, 7));
+
+    // Merge the even lanes together with a 16-bit unsigned shift right + add.
+    // 'xx' represents garbage data which will be ignored in the final result.
+    // In the important bytes, the add functions like a binary OR.
+    //
+    // 01 01 00 01 00 00 01 00
+    //  \_ |  \_ |  \_ |  \_ |   paired16 = (uint32x4_t)(input + (input >> 7))
+    //    \|    \|    \|    \|
+    // xx 03 xx 01 xx 00 xx 02
+    //
+    // 00000001 00000001 (01 01)
+    //        \_______ |
+    //                \|
+    // xxxxxxxx xxxxxx11 (xx 03)
+    uint32x4_t paired16 =
+        vreinterpretq_u32_u16(vsraq_n_u16(high_bits, high_bits, 7));
+
+    // Repeat with a wider 32-bit shift + add.
+    // xx 03 xx 01 xx 00 xx 02
+    //     \____ |     \____ |  paired32 = (uint64x1_t)(paired16 + (paired16 >>
+    //     14))
+    //          \|          \|
+    // xx xx xx 0d xx xx xx 02
+    //
+    // 00000011 00000001 (03 01)
+    //        \\_____ ||
+    //         '----.\||
+    // xxxxxxxx xxxx1101 (xx 0d)
+    uint64x2_t paired32 =
+        vreinterpretq_u64_u32(vsraq_n_u32(paired16, paired16, 14));
+
+    // Last, an even wider 64-bit shift + add to get our result in the low 8 bit
+    // lanes. xx xx xx 0d xx xx xx 02
+    //            \_________ |   paired64 = (uint8x8_t)(paired32 + (paired32 >>
+    //            28))
+    //                      \|
+    // xx xx xx xx xx xx xx d2
+    //
+    // 00001101 00000010 (0d 02)
+    //     \   \___ |  |
+    //      '---.  \|  |
+    // xxxxxxxx 11010010 (xx d2)
+    uint8x16_t paired64 =
+        vreinterpretq_u8_u64(vsraq_n_u64(paired32, paired32, 28));
+
+    // Extract the low 8 bits from each 64-bit lane with 2 8-bit extracts.
+    // xx xx xx xx xx xx xx d2
+    //                      ||  return paired64[0]
+    //                      d2
+    // Note: Little endian would return the correct value 4b (01001011) instead.
+    return vgetq_lane_u8(paired64, 0) | ((int) vgetq_lane_u8(paired64, 8) << 8);
+}
+
+// Set each bit of mask dst based on the most significant bit of the
+// corresponding packed double-precision (64-bit) floating-point element in a.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_movemask_pd
+FORCE_INLINE int _mm_movemask_pd(__m128d a)
+{
+    uint64x2_t input = vreinterpretq_u64_m128d(a);
+    uint64x2_t high_bits = vshrq_n_u64(input, 63);
+    return (int) (vgetq_lane_u64(high_bits, 0) |
+                  (vgetq_lane_u64(high_bits, 1) << 1));
+}
+
+// Copy the lower 64-bit integer in a to dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_movepi64_pi64
+FORCE_INLINE __m64 _mm_movepi64_pi64(__m128i a)
+{
+    return vreinterpret_m64_s64(vget_low_s64(vreinterpretq_s64_m128i(a)));
+}
+
+// Copy the 64-bit integer a to the lower element of dst, and zero the upper
+// element.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_movpi64_epi64
+FORCE_INLINE __m128i _mm_movpi64_epi64(__m64 a)
+{
+    return vreinterpretq_m128i_s64(
+        vcombine_s64(vreinterpret_s64_m64(a), vdup_n_s64(0)));
+}
+
+// Multiply the low unsigned 32-bit integers from each packed 64-bit element in
+// a and b, and store the unsigned 64-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mul_epu32
+FORCE_INLINE __m128i _mm_mul_epu32(__m128i a, __m128i b)
+{
+    // vmull_u32 upcasts instead of masking, so we downcast.
+    uint32x2_t a_lo = vmovn_u64(vreinterpretq_u64_m128i(a));
+    uint32x2_t b_lo = vmovn_u64(vreinterpretq_u64_m128i(b));
+    return vreinterpretq_m128i_u64(vmull_u32(a_lo, b_lo));
+}
+
+// Multiply packed double-precision (64-bit) floating-point elements in a and b,
+// and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mul_pd
+FORCE_INLINE __m128d _mm_mul_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vmulq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    double c[2];
+    c[0] = a0 * b0;
+    c[1] = a1 * b1;
+    return vld1q_f32((float32_t *) c);
+#endif
+}
+
+// Multiply the lower double-precision (64-bit) floating-point element in a and
+// b, store the result in the lower element of dst, and copy the upper element
+// from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=mm_mul_sd
+FORCE_INLINE __m128d _mm_mul_sd(__m128d a, __m128d b)
+{
+    return _mm_move_sd(a, _mm_mul_pd(a, b));
+}
+
+// Multiply the low unsigned 32-bit integers from a and b, and store the
+// unsigned 64-bit result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mul_su32
+FORCE_INLINE __m64 _mm_mul_su32(__m64 a, __m64 b)
+{
+    return vreinterpret_m64_u64(vget_low_u64(
+        vmull_u32(vreinterpret_u32_m64(a), vreinterpret_u32_m64(b))));
+}
+
+// Multiply the packed signed 16-bit integers in a and b, producing intermediate
+// 32-bit integers, and store the high 16 bits of the intermediate integers in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mulhi_epi16
+FORCE_INLINE __m128i _mm_mulhi_epi16(__m128i a, __m128i b)
+{
+    /* FIXME: issue with large values because of result saturation */
+    // int16x8_t ret = vqdmulhq_s16(vreinterpretq_s16_m128i(a),
+    // vreinterpretq_s16_m128i(b)); /* =2*a*b */ return
+    // vreinterpretq_m128i_s16(vshrq_n_s16(ret, 1));
+    int16x4_t a3210 = vget_low_s16(vreinterpretq_s16_m128i(a));
+    int16x4_t b3210 = vget_low_s16(vreinterpretq_s16_m128i(b));
+    int32x4_t ab3210 = vmull_s16(a3210, b3210); /* 3333222211110000 */
+    int16x4_t a7654 = vget_high_s16(vreinterpretq_s16_m128i(a));
+    int16x4_t b7654 = vget_high_s16(vreinterpretq_s16_m128i(b));
+    int32x4_t ab7654 = vmull_s16(a7654, b7654); /* 7777666655554444 */
+    uint16x8x2_t r =
+        vuzpq_u16(vreinterpretq_u16_s32(ab3210), vreinterpretq_u16_s32(ab7654));
+    return vreinterpretq_m128i_u16(r.val[1]);
+}
+
+// Multiply the packed unsigned 16-bit integers in a and b, producing
+// intermediate 32-bit integers, and store the high 16 bits of the intermediate
+// integers in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mulhi_epu16
+FORCE_INLINE __m128i _mm_mulhi_epu16(__m128i a, __m128i b)
+{
+    uint16x4_t a3210 = vget_low_u16(vreinterpretq_u16_m128i(a));
+    uint16x4_t b3210 = vget_low_u16(vreinterpretq_u16_m128i(b));
+    uint32x4_t ab3210 = vmull_u16(a3210, b3210);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    uint32x4_t ab7654 =
+        vmull_high_u16(vreinterpretq_u16_m128i(a), vreinterpretq_u16_m128i(b));
+    uint16x8_t r = vuzp2q_u16(vreinterpretq_u16_u32(ab3210),
+                              vreinterpretq_u16_u32(ab7654));
+    return vreinterpretq_m128i_u16(r);
+#else
+    uint16x4_t a7654 = vget_high_u16(vreinterpretq_u16_m128i(a));
+    uint16x4_t b7654 = vget_high_u16(vreinterpretq_u16_m128i(b));
+    uint32x4_t ab7654 = vmull_u16(a7654, b7654);
+    uint16x8x2_t r =
+        vuzpq_u16(vreinterpretq_u16_u32(ab3210), vreinterpretq_u16_u32(ab7654));
+    return vreinterpretq_m128i_u16(r.val[1]);
+#endif
+}
+
+// Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit
+// integers, and store the low 16 bits of the intermediate integers in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mullo_epi16
+FORCE_INLINE __m128i _mm_mullo_epi16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s16(
+        vmulq_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b)));
+}
+
+// Compute the bitwise OR of packed double-precision (64-bit) floating-point
+// elements in a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=mm_or_pd
+FORCE_INLINE __m128d _mm_or_pd(__m128d a, __m128d b)
+{
+    return vreinterpretq_m128d_s64(
+        vorrq_s64(vreinterpretq_s64_m128d(a), vreinterpretq_s64_m128d(b)));
+}
+
+// Compute the bitwise OR of 128 bits (representing integer data) in a and b,
+// and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_or_si128
+FORCE_INLINE __m128i _mm_or_si128(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s32(
+        vorrq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+}
+
+// Convert packed signed 16-bit integers from a and b to packed 8-bit integers
+// using signed saturation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_packs_epi16
+FORCE_INLINE __m128i _mm_packs_epi16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s8(
+        vcombine_s8(vqmovn_s16(vreinterpretq_s16_m128i(a)),
+                    vqmovn_s16(vreinterpretq_s16_m128i(b))));
+}
+
+// Convert packed signed 32-bit integers from a and b to packed 16-bit integers
+// using signed saturation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_packs_epi32
+FORCE_INLINE __m128i _mm_packs_epi32(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s16(
+        vcombine_s16(vqmovn_s32(vreinterpretq_s32_m128i(a)),
+                     vqmovn_s32(vreinterpretq_s32_m128i(b))));
+}
+
+// Convert packed signed 16-bit integers from a and b to packed 8-bit integers
+// using unsigned saturation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_packus_epi16
+FORCE_INLINE __m128i _mm_packus_epi16(const __m128i a, const __m128i b)
+{
+    return vreinterpretq_m128i_u8(
+        vcombine_u8(vqmovun_s16(vreinterpretq_s16_m128i(a)),
+                    vqmovun_s16(vreinterpretq_s16_m128i(b))));
+}
+
+// Pause the processor. This is typically used in spin-wait loops and depending
+// on the x86 processor typical values are in the 40-100 cycle range. The
+// 'yield' instruction isn't a good fit because it's effectively a nop on most
+// Arm cores. Experience with several databases has shown has shown an 'isb' is
+// a reasonable approximation.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_pause
+FORCE_INLINE void _mm_pause(void)
+{
+#if defined(_MSC_VER) && !defined(__clang__)
+    __isb(_ARM64_BARRIER_SY);
+#else
+    __asm__ __volatile__("isb\n");
+#endif
+}
+
+// Compute the absolute differences of packed unsigned 8-bit integers in a and
+// b, then horizontally sum each consecutive 8 differences to produce two
+// unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low
+// 16 bits of 64-bit elements in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sad_epu8
+FORCE_INLINE __m128i _mm_sad_epu8(__m128i a, __m128i b)
+{
+    uint16x8_t t = vpaddlq_u8(vabdq_u8((uint8x16_t) a, (uint8x16_t) b));
+    return vreinterpretq_m128i_u64(vpaddlq_u32(vpaddlq_u16(t)));
+}
+
+// Set packed 16-bit integers in dst with the supplied values.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set_epi16
+FORCE_INLINE __m128i _mm_set_epi16(short i7,
+                                   short i6,
+                                   short i5,
+                                   short i4,
+                                   short i3,
+                                   short i2,
+                                   short i1,
+                                   short i0)
+{
+    int16_t ALIGN_STRUCT(16) data[8] = {i0, i1, i2, i3, i4, i5, i6, i7};
+    return vreinterpretq_m128i_s16(vld1q_s16(data));
+}
+
+// Set packed 32-bit integers in dst with the supplied values.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set_epi32
+FORCE_INLINE __m128i _mm_set_epi32(int i3, int i2, int i1, int i0)
+{
+    int32_t ALIGN_STRUCT(16) data[4] = {i0, i1, i2, i3};
+    return vreinterpretq_m128i_s32(vld1q_s32(data));
+}
+
+// Set packed 64-bit integers in dst with the supplied values.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set_epi64
+FORCE_INLINE __m128i _mm_set_epi64(__m64 i1, __m64 i2)
+{
+    return _mm_set_epi64x(vget_lane_s64(i1, 0), vget_lane_s64(i2, 0));
+}
+
+// Set packed 64-bit integers in dst with the supplied values.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set_epi64x
+FORCE_INLINE __m128i _mm_set_epi64x(int64_t i1, int64_t i2)
+{
+    return vreinterpretq_m128i_s64(
+        vcombine_s64(vcreate_s64(i2), vcreate_s64(i1)));
+}
+
+// Set packed 8-bit integers in dst with the supplied values.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set_epi8
+FORCE_INLINE __m128i _mm_set_epi8(signed char b15,
+                                  signed char b14,
+                                  signed char b13,
+                                  signed char b12,
+                                  signed char b11,
+                                  signed char b10,
+                                  signed char b9,
+                                  signed char b8,
+                                  signed char b7,
+                                  signed char b6,
+                                  signed char b5,
+                                  signed char b4,
+                                  signed char b3,
+                                  signed char b2,
+                                  signed char b1,
+                                  signed char b0)
+{
+    int8_t ALIGN_STRUCT(16)
+        data[16] = {(int8_t) b0,  (int8_t) b1,  (int8_t) b2,  (int8_t) b3,
+                    (int8_t) b4,  (int8_t) b5,  (int8_t) b6,  (int8_t) b7,
+                    (int8_t) b8,  (int8_t) b9,  (int8_t) b10, (int8_t) b11,
+                    (int8_t) b12, (int8_t) b13, (int8_t) b14, (int8_t) b15};
+    return (__m128i) vld1q_s8(data);
+}
+
+// Set packed double-precision (64-bit) floating-point elements in dst with the
+// supplied values.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set_pd
+FORCE_INLINE __m128d _mm_set_pd(double e1, double e0)
+{
+    double ALIGN_STRUCT(16) data[2] = {e0, e1};
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(vld1q_f64((float64_t *) data));
+#else
+    return vreinterpretq_m128d_f32(vld1q_f32((float32_t *) data));
+#endif
+}
+
+// Broadcast double-precision (64-bit) floating-point value a to all elements of
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set_pd1
+#define _mm_set_pd1 _mm_set1_pd
+
+// Copy double-precision (64-bit) floating-point element a to the lower element
+// of dst, and zero the upper element.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set_sd
+FORCE_INLINE __m128d _mm_set_sd(double a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(vsetq_lane_f64(a, vdupq_n_f64(0), 0));
+#else
+    return _mm_set_pd(0, a);
+#endif
+}
+
+// Broadcast 16-bit integer a to all elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set1_epi16
+FORCE_INLINE __m128i _mm_set1_epi16(short w)
+{
+    return vreinterpretq_m128i_s16(vdupq_n_s16(w));
+}
+
+// Broadcast 32-bit integer a to all elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set1_epi32
+FORCE_INLINE __m128i _mm_set1_epi32(int _i)
+{
+    return vreinterpretq_m128i_s32(vdupq_n_s32(_i));
+}
+
+// Broadcast 64-bit integer a to all elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set1_epi64
+FORCE_INLINE __m128i _mm_set1_epi64(__m64 _i)
+{
+    return vreinterpretq_m128i_s64(vdupq_lane_s64(_i, 0));
+}
+
+// Broadcast 64-bit integer a to all elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set1_epi64x
+FORCE_INLINE __m128i _mm_set1_epi64x(int64_t _i)
+{
+    return vreinterpretq_m128i_s64(vdupq_n_s64(_i));
+}
+
+// Broadcast 8-bit integer a to all elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set1_epi8
+FORCE_INLINE __m128i _mm_set1_epi8(signed char w)
+{
+    return vreinterpretq_m128i_s8(vdupq_n_s8(w));
+}
+
+// Broadcast double-precision (64-bit) floating-point value a to all elements of
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_set1_pd
+FORCE_INLINE __m128d _mm_set1_pd(double d)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(vdupq_n_f64(d));
+#else
+    int64_t _d = sse2neon_recast_f64_s64(d);
+    return vreinterpretq_m128d_s64(vdupq_n_s64(_d));
+#endif
+}
+
+// Set packed 16-bit integers in dst with the supplied values in reverse order.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_setr_epi16
+FORCE_INLINE __m128i _mm_setr_epi16(short w0,
+                                    short w1,
+                                    short w2,
+                                    short w3,
+                                    short w4,
+                                    short w5,
+                                    short w6,
+                                    short w7)
+{
+    int16_t ALIGN_STRUCT(16) data[8] = {w0, w1, w2, w3, w4, w5, w6, w7};
+    return vreinterpretq_m128i_s16(vld1q_s16((int16_t *) data));
+}
+
+// Set packed 32-bit integers in dst with the supplied values in reverse order.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_setr_epi32
+FORCE_INLINE __m128i _mm_setr_epi32(int i3, int i2, int i1, int i0)
+{
+    int32_t ALIGN_STRUCT(16) data[4] = {i3, i2, i1, i0};
+    return vreinterpretq_m128i_s32(vld1q_s32(data));
+}
+
+// Set packed 64-bit integers in dst with the supplied values in reverse order.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_setr_epi64
+FORCE_INLINE __m128i _mm_setr_epi64(__m64 e1, __m64 e0)
+{
+    return vreinterpretq_m128i_s64(vcombine_s64(e1, e0));
+}
+
+// Set packed 8-bit integers in dst with the supplied values in reverse order.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_setr_epi8
+FORCE_INLINE __m128i _mm_setr_epi8(signed char b0,
+                                   signed char b1,
+                                   signed char b2,
+                                   signed char b3,
+                                   signed char b4,
+                                   signed char b5,
+                                   signed char b6,
+                                   signed char b7,
+                                   signed char b8,
+                                   signed char b9,
+                                   signed char b10,
+                                   signed char b11,
+                                   signed char b12,
+                                   signed char b13,
+                                   signed char b14,
+                                   signed char b15)
+{
+    int8_t ALIGN_STRUCT(16)
+        data[16] = {(int8_t) b0,  (int8_t) b1,  (int8_t) b2,  (int8_t) b3,
+                    (int8_t) b4,  (int8_t) b5,  (int8_t) b6,  (int8_t) b7,
+                    (int8_t) b8,  (int8_t) b9,  (int8_t) b10, (int8_t) b11,
+                    (int8_t) b12, (int8_t) b13, (int8_t) b14, (int8_t) b15};
+    return (__m128i) vld1q_s8(data);
+}
+
+// Set packed double-precision (64-bit) floating-point elements in dst with the
+// supplied values in reverse order.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_setr_pd
+FORCE_INLINE __m128d _mm_setr_pd(double e1, double e0)
+{
+    return _mm_set_pd(e0, e1);
+}
+
+// Return vector of type __m128d with all elements set to zero.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_setzero_pd
+FORCE_INLINE __m128d _mm_setzero_pd(void)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(vdupq_n_f64(0));
+#else
+    return vreinterpretq_m128d_f32(vdupq_n_f32(0));
+#endif
+}
+
+// Return vector of type __m128i with all elements set to zero.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_setzero_si128
+FORCE_INLINE __m128i _mm_setzero_si128(void)
+{
+    return vreinterpretq_m128i_s32(vdupq_n_s32(0));
+}
+
+// Shuffle 32-bit integers in a using the control in imm8, and store the results
+// in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_shuffle_epi32
+// FORCE_INLINE __m128i _mm_shuffle_epi32(__m128i a,
+//                                        __constrange(0,255) int imm)
+#if defined(_sse2neon_shuffle)
+#define _mm_shuffle_epi32(a, imm)                                            \
+    __extension__({                                                          \
+        int32x4_t _input = vreinterpretq_s32_m128i(a);                       \
+        int32x4_t _shuf =                                                    \
+            vshuffleq_s32(_input, _input, (imm) & (0x3), ((imm) >> 2) & 0x3, \
+                          ((imm) >> 4) & 0x3, ((imm) >> 6) & 0x3);           \
+        vreinterpretq_m128i_s32(_shuf);                                      \
+    })
+#else  // generic
+#define _mm_shuffle_epi32(a, imm)                           \
+    _sse2neon_define1(                                      \
+        __m128i, a, __m128i ret; switch (imm) {             \
+            case _MM_SHUFFLE(1, 0, 3, 2):                   \
+                ret = _mm_shuffle_epi_1032(_a);             \
+                break;                                      \
+            case _MM_SHUFFLE(2, 3, 0, 1):                   \
+                ret = _mm_shuffle_epi_2301(_a);             \
+                break;                                      \
+            case _MM_SHUFFLE(0, 3, 2, 1):                   \
+                ret = _mm_shuffle_epi_0321(_a);             \
+                break;                                      \
+            case _MM_SHUFFLE(2, 1, 0, 3):                   \
+                ret = _mm_shuffle_epi_2103(_a);             \
+                break;                                      \
+            case _MM_SHUFFLE(1, 0, 1, 0):                   \
+                ret = _mm_shuffle_epi_1010(_a);             \
+                break;                                      \
+            case _MM_SHUFFLE(1, 0, 0, 1):                   \
+                ret = _mm_shuffle_epi_1001(_a);             \
+                break;                                      \
+            case _MM_SHUFFLE(0, 1, 0, 1):                   \
+                ret = _mm_shuffle_epi_0101(_a);             \
+                break;                                      \
+            case _MM_SHUFFLE(2, 2, 1, 1):                   \
+                ret = _mm_shuffle_epi_2211(_a);             \
+                break;                                      \
+            case _MM_SHUFFLE(0, 1, 2, 2):                   \
+                ret = _mm_shuffle_epi_0122(_a);             \
+                break;                                      \
+            case _MM_SHUFFLE(3, 3, 3, 2):                   \
+                ret = _mm_shuffle_epi_3332(_a);             \
+                break;                                      \
+            case _MM_SHUFFLE(0, 0, 0, 0):                   \
+                ret = _mm_shuffle_epi32_splat(_a, 0);       \
+                break;                                      \
+            case _MM_SHUFFLE(1, 1, 1, 1):                   \
+                ret = _mm_shuffle_epi32_splat(_a, 1);       \
+                break;                                      \
+            case _MM_SHUFFLE(2, 2, 2, 2):                   \
+                ret = _mm_shuffle_epi32_splat(_a, 2);       \
+                break;                                      \
+            case _MM_SHUFFLE(3, 3, 3, 3):                   \
+                ret = _mm_shuffle_epi32_splat(_a, 3);       \
+                break;                                      \
+            default:                                        \
+                ret = _mm_shuffle_epi32_default(_a, (imm)); \
+                break;                                      \
+        } _sse2neon_return(ret);)
+#endif
+
+// Shuffle double-precision (64-bit) floating-point elements using the control
+// in imm8, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_shuffle_pd
+#ifdef _sse2neon_shuffle
+#define _mm_shuffle_pd(a, b, imm8)                                            \
+    vreinterpretq_m128d_s64(                                                  \
+        vshuffleq_s64(vreinterpretq_s64_m128d(a), vreinterpretq_s64_m128d(b), \
+                      imm8 & 0x1, ((imm8 & 0x2) >> 1) + 2))
+#else
+#define _mm_shuffle_pd(a, b, imm8)                                     \
+    _mm_castsi128_pd(_mm_set_epi64x(                                   \
+        vgetq_lane_s64(vreinterpretq_s64_m128d(b), (imm8 & 0x2) >> 1), \
+        vgetq_lane_s64(vreinterpretq_s64_m128d(a), imm8 & 0x1)))
+#endif
+
+// FORCE_INLINE __m128i _mm_shufflehi_epi16(__m128i a,
+//                                          __constrange(0,255) int imm)
+#if defined(_sse2neon_shuffle)
+#define _mm_shufflehi_epi16(a, imm)                                           \
+    __extension__({                                                           \
+        int16x8_t _input = vreinterpretq_s16_m128i(a);                        \
+        int16x8_t _shuf =                                                     \
+            vshuffleq_s16(_input, _input, 0, 1, 2, 3, ((imm) & (0x3)) + 4,    \
+                          (((imm) >> 2) & 0x3) + 4, (((imm) >> 4) & 0x3) + 4, \
+                          (((imm) >> 6) & 0x3) + 4);                          \
+        vreinterpretq_m128i_s16(_shuf);                                       \
+    })
+#else  // generic
+#define _mm_shufflehi_epi16(a, imm) _mm_shufflehi_epi16_function((a), (imm))
+#endif
+
+// FORCE_INLINE __m128i _mm_shufflelo_epi16(__m128i a,
+//                                          __constrange(0,255) int imm)
+#if defined(_sse2neon_shuffle)
+#define _mm_shufflelo_epi16(a, imm)                                  \
+    __extension__({                                                  \
+        int16x8_t _input = vreinterpretq_s16_m128i(a);               \
+        int16x8_t _shuf = vshuffleq_s16(                             \
+            _input, _input, ((imm) & (0x3)), (((imm) >> 2) & 0x3),   \
+            (((imm) >> 4) & 0x3), (((imm) >> 6) & 0x3), 4, 5, 6, 7); \
+        vreinterpretq_m128i_s16(_shuf);                              \
+    })
+#else  // generic
+#define _mm_shufflelo_epi16(a, imm) _mm_shufflelo_epi16_function((a), (imm))
+#endif
+
+// Shift packed 16-bit integers in a left by count while shifting in zeros, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sll_epi16
+FORCE_INLINE __m128i _mm_sll_epi16(__m128i a, __m128i count)
+{
+    uint64_t c = vreinterpretq_nth_u64_m128i(count, 0);
+    if (_sse2neon_unlikely(c & ~15))
+        return _mm_setzero_si128();
+
+    int16x8_t vc = vdupq_n_s16((int16_t) c);
+    return vreinterpretq_m128i_s16(vshlq_s16(vreinterpretq_s16_m128i(a), vc));
+}
+
+// Shift packed 32-bit integers in a left by count while shifting in zeros, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sll_epi32
+FORCE_INLINE __m128i _mm_sll_epi32(__m128i a, __m128i count)
+{
+    uint64_t c = vreinterpretq_nth_u64_m128i(count, 0);
+    if (_sse2neon_unlikely(c & ~31))
+        return _mm_setzero_si128();
+
+    int32x4_t vc = vdupq_n_s32((int32_t) c);
+    return vreinterpretq_m128i_s32(vshlq_s32(vreinterpretq_s32_m128i(a), vc));
+}
+
+// Shift packed 64-bit integers in a left by count while shifting in zeros, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sll_epi64
+FORCE_INLINE __m128i _mm_sll_epi64(__m128i a, __m128i count)
+{
+    uint64_t c = vreinterpretq_nth_u64_m128i(count, 0);
+    if (_sse2neon_unlikely(c & ~63))
+        return _mm_setzero_si128();
+
+    int64x2_t vc = vdupq_n_s64((int64_t) c);
+    return vreinterpretq_m128i_s64(vshlq_s64(vreinterpretq_s64_m128i(a), vc));
+}
+
+// Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_slli_epi16
+FORCE_INLINE __m128i _mm_slli_epi16(__m128i a, int imm)
+{
+    if (_sse2neon_unlikely(imm & ~15))
+        return _mm_setzero_si128();
+    return vreinterpretq_m128i_s16(
+        vshlq_s16(vreinterpretq_s16_m128i(a), vdupq_n_s16(imm)));
+}
+
+// Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_slli_epi32
+FORCE_INLINE __m128i _mm_slli_epi32(__m128i a, int imm)
+{
+    if (_sse2neon_unlikely(imm & ~31))
+        return _mm_setzero_si128();
+    return vreinterpretq_m128i_s32(
+        vshlq_s32(vreinterpretq_s32_m128i(a), vdupq_n_s32(imm)));
+}
+
+// Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_slli_epi64
+FORCE_INLINE __m128i _mm_slli_epi64(__m128i a, int imm)
+{
+    if (_sse2neon_unlikely(imm & ~63))
+        return _mm_setzero_si128();
+    return vreinterpretq_m128i_s64(
+        vshlq_s64(vreinterpretq_s64_m128i(a), vdupq_n_s64(imm)));
+}
+
+// Shift a left by imm8 bytes while shifting in zeros, and store the results in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_slli_si128
+#define _mm_slli_si128(a, imm)                                              \
+    _sse2neon_define1(                                                      \
+        __m128i, a, int8x16_t ret;                                          \
+        if (_sse2neon_unlikely(imm == 0)) ret = vreinterpretq_s8_m128i(_a); \
+        else if (_sse2neon_unlikely((imm) & ~15)) ret = vdupq_n_s8(0);      \
+        else ret = vextq_s8(vdupq_n_s8(0), vreinterpretq_s8_m128i(_a),      \
+                            ((imm <= 0 || imm > 15) ? 0 : (16 - imm)));     \
+        _sse2neon_return(vreinterpretq_m128i_s8(ret));)
+
+// Compute the square root of packed double-precision (64-bit) floating-point
+// elements in a, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sqrt_pd
+FORCE_INLINE __m128d _mm_sqrt_pd(__m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(vsqrtq_f64(vreinterpretq_f64_m128d(a)));
+#else
+    double a0, a1;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    a1 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double _a0 = sqrt(a0);
+    double _a1 = sqrt(a1);
+    return _mm_set_pd(_a1, _a0);
+#endif
+}
+
+// Compute the square root of the lower double-precision (64-bit) floating-point
+// element in b, store the result in the lower element of dst, and copy the
+// upper element from a to the upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sqrt_sd
+FORCE_INLINE __m128d _mm_sqrt_sd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return _mm_move_sd(a, _mm_sqrt_pd(b));
+#else
+    double _a, _b;
+    _a = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    _b = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    return _mm_set_pd(_a, sqrt(_b));
+#endif
+}
+
+// Shift packed 16-bit integers in a right by count while shifting in sign bits,
+// and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sra_epi16
+FORCE_INLINE __m128i _mm_sra_epi16(__m128i a, __m128i count)
+{
+    int64_t c = vgetq_lane_s64(count, 0);
+    if (_sse2neon_unlikely(c & ~15))
+        return _mm_cmplt_epi16(a, _mm_setzero_si128());
+    return vreinterpretq_m128i_s16(
+        vshlq_s16((int16x8_t) a, vdupq_n_s16((int) -c)));
+}
+
+// Shift packed 32-bit integers in a right by count while shifting in sign bits,
+// and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sra_epi32
+FORCE_INLINE __m128i _mm_sra_epi32(__m128i a, __m128i count)
+{
+    int64_t c = vgetq_lane_s64(count, 0);
+    if (_sse2neon_unlikely(c & ~31))
+        return _mm_cmplt_epi32(a, _mm_setzero_si128());
+    return vreinterpretq_m128i_s32(
+        vshlq_s32((int32x4_t) a, vdupq_n_s32((int) -c)));
+}
+
+// Shift packed 16-bit integers in a right by imm8 while shifting in sign
+// bits, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_srai_epi16
+FORCE_INLINE __m128i _mm_srai_epi16(__m128i a, int imm)
+{
+    const int count = (imm & ~15) ? 15 : imm;
+    return (__m128i) vshlq_s16((int16x8_t) a, vdupq_n_s16(-count));
+}
+
+// Shift packed 32-bit integers in a right by imm8 while shifting in sign bits,
+// and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_srai_epi32
+// FORCE_INLINE __m128i _mm_srai_epi32(__m128i a, __constrange(0,255) int imm)
+#define _mm_srai_epi32(a, imm)                                                \
+    _sse2neon_define0(                                                        \
+        __m128i, a, __m128i ret; if (_sse2neon_unlikely((imm) == 0)) {        \
+            ret = _a;                                                         \
+        } else if (_sse2neon_likely(0 < (imm) && (imm) < 32)) {               \
+            ret = vreinterpretq_m128i_s32(                                    \
+                vshlq_s32(vreinterpretq_s32_m128i(_a), vdupq_n_s32(-(imm)))); \
+        } else {                                                              \
+            ret = vreinterpretq_m128i_s32(                                    \
+                vshrq_n_s32(vreinterpretq_s32_m128i(_a), 31));                \
+        } _sse2neon_return(ret);)
+
+// Shift packed 16-bit integers in a right by count while shifting in zeros, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_srl_epi16
+FORCE_INLINE __m128i _mm_srl_epi16(__m128i a, __m128i count)
+{
+    uint64_t c = vreinterpretq_nth_u64_m128i(count, 0);
+    if (_sse2neon_unlikely(c & ~15))
+        return _mm_setzero_si128();
+
+    int16x8_t vc = vdupq_n_s16(-(int16_t) c);
+    return vreinterpretq_m128i_u16(vshlq_u16(vreinterpretq_u16_m128i(a), vc));
+}
+
+// Shift packed 32-bit integers in a right by count while shifting in zeros, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_srl_epi32
+FORCE_INLINE __m128i _mm_srl_epi32(__m128i a, __m128i count)
+{
+    uint64_t c = vreinterpretq_nth_u64_m128i(count, 0);
+    if (_sse2neon_unlikely(c & ~31))
+        return _mm_setzero_si128();
+
+    int32x4_t vc = vdupq_n_s32(-(int32_t) c);
+    return vreinterpretq_m128i_u32(vshlq_u32(vreinterpretq_u32_m128i(a), vc));
+}
+
+// Shift packed 64-bit integers in a right by count while shifting in zeros, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_srl_epi64
+FORCE_INLINE __m128i _mm_srl_epi64(__m128i a, __m128i count)
+{
+    uint64_t c = vreinterpretq_nth_u64_m128i(count, 0);
+    if (_sse2neon_unlikely(c & ~63))
+        return _mm_setzero_si128();
+
+    int64x2_t vc = vdupq_n_s64(-(int64_t) c);
+    return vreinterpretq_m128i_u64(vshlq_u64(vreinterpretq_u64_m128i(a), vc));
+}
+
+// Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_srli_epi16
+#define _mm_srli_epi16(a, imm)                                                \
+    _sse2neon_define0(                                                        \
+        __m128i, a, __m128i ret; if (_sse2neon_unlikely((imm) & ~15)) {       \
+            ret = _mm_setzero_si128();                                        \
+        } else {                                                              \
+            ret = vreinterpretq_m128i_u16(                                    \
+                vshlq_u16(vreinterpretq_u16_m128i(_a), vdupq_n_s16(-(imm)))); \
+        } _sse2neon_return(ret);)
+
+// Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_srli_epi32
+// FORCE_INLINE __m128i _mm_srli_epi32(__m128i a, __constrange(0,255) int imm)
+#define _mm_srli_epi32(a, imm)                                                \
+    _sse2neon_define0(                                                        \
+        __m128i, a, __m128i ret; if (_sse2neon_unlikely((imm) & ~31)) {       \
+            ret = _mm_setzero_si128();                                        \
+        } else {                                                              \
+            ret = vreinterpretq_m128i_u32(                                    \
+                vshlq_u32(vreinterpretq_u32_m128i(_a), vdupq_n_s32(-(imm)))); \
+        } _sse2neon_return(ret);)
+
+// Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_srli_epi64
+#define _mm_srli_epi64(a, imm)                                                \
+    _sse2neon_define0(                                                        \
+        __m128i, a, __m128i ret; if (_sse2neon_unlikely((imm) & ~63)) {       \
+            ret = _mm_setzero_si128();                                        \
+        } else {                                                              \
+            ret = vreinterpretq_m128i_u64(                                    \
+                vshlq_u64(vreinterpretq_u64_m128i(_a), vdupq_n_s64(-(imm)))); \
+        } _sse2neon_return(ret);)
+
+// Shift a right by imm8 bytes while shifting in zeros, and store the results in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_srli_si128
+#define _mm_srli_si128(a, imm)                                         \
+    _sse2neon_define1(                                                 \
+        __m128i, a, int8x16_t ret;                                     \
+        if (_sse2neon_unlikely((imm) & ~15)) ret = vdupq_n_s8(0);      \
+        else ret = vextq_s8(vreinterpretq_s8_m128i(_a), vdupq_n_s8(0), \
+                            (imm > 15 ? 0 : imm));                     \
+        _sse2neon_return(vreinterpretq_m128i_s8(ret));)
+
+// Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point
+// elements) from a into memory. mem_addr must be aligned on a 16-byte boundary
+// or a general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_store_pd
+FORCE_INLINE void _mm_store_pd(double *mem_addr, __m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    vst1q_f64((float64_t *) mem_addr, vreinterpretq_f64_m128d(a));
+#else
+    vst1q_f32((float32_t *) mem_addr, vreinterpretq_f32_m128d(a));
+#endif
+}
+
+// Store the lower double-precision (64-bit) floating-point element from a into
+// 2 contiguous elements in memory. mem_addr must be aligned on a 16-byte
+// boundary or a general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_store_pd1
+FORCE_INLINE void _mm_store_pd1(double *mem_addr, __m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    float64x1_t a_low = vget_low_f64(vreinterpretq_f64_m128d(a));
+    vst1q_f64((float64_t *) mem_addr,
+              vreinterpretq_f64_m128d(vcombine_f64(a_low, a_low)));
+#else
+    float32x2_t a_low = vget_low_f32(vreinterpretq_f32_m128d(a));
+    vst1q_f32((float32_t *) mem_addr,
+              vreinterpretq_f32_m128d(vcombine_f32(a_low, a_low)));
+#endif
+}
+
+// Store the lower double-precision (64-bit) floating-point element from a into
+// memory. mem_addr does not need to be aligned on any particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=mm_store_sd
+FORCE_INLINE void _mm_store_sd(double *mem_addr, __m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    vst1_f64((float64_t *) mem_addr, vget_low_f64(vreinterpretq_f64_m128d(a)));
+#else
+    vst1_u64((uint64_t *) mem_addr, vget_low_u64(vreinterpretq_u64_m128d(a)));
+#endif
+}
+
+// Store 128-bits of integer data from a into memory. mem_addr must be aligned
+// on a 16-byte boundary or a general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_store_si128
+FORCE_INLINE void _mm_store_si128(__m128i *p, __m128i a)
+{
+    vst1q_s32((int32_t *) p, vreinterpretq_s32_m128i(a));
+}
+
+// Store the lower double-precision (64-bit) floating-point element from a into
+// 2 contiguous elements in memory. mem_addr must be aligned on a 16-byte
+// boundary or a general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#expand=9,526,5601&text=_mm_store1_pd
+#define _mm_store1_pd _mm_store_pd1
+
+// Store the upper double-precision (64-bit) floating-point element from a into
+// memory.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storeh_pd
+FORCE_INLINE void _mm_storeh_pd(double *mem_addr, __m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    vst1_f64((float64_t *) mem_addr, vget_high_f64(vreinterpretq_f64_m128d(a)));
+#else
+    vst1_f32((float32_t *) mem_addr, vget_high_f32(vreinterpretq_f32_m128d(a)));
+#endif
+}
+
+// Store 64-bit integer from the first element of a into memory.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storel_epi64
+FORCE_INLINE void _mm_storel_epi64(__m128i *a, __m128i b)
+{
+    vst1_u64((uint64_t *) a, vget_low_u64(vreinterpretq_u64_m128i(b)));
+}
+
+// Store the lower double-precision (64-bit) floating-point element from a into
+// memory.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storel_pd
+FORCE_INLINE void _mm_storel_pd(double *mem_addr, __m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    vst1_f64((float64_t *) mem_addr, vget_low_f64(vreinterpretq_f64_m128d(a)));
+#else
+    vst1_f32((float32_t *) mem_addr, vget_low_f32(vreinterpretq_f32_m128d(a)));
+#endif
+}
+
+// Store 2 double-precision (64-bit) floating-point elements from a into memory
+// in reverse order. mem_addr must be aligned on a 16-byte boundary or a
+// general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storer_pd
+FORCE_INLINE void _mm_storer_pd(double *mem_addr, __m128d a)
+{
+    float32x4_t f = vreinterpretq_f32_m128d(a);
+    _mm_store_pd(mem_addr, vreinterpretq_m128d_f32(vextq_f32(f, f, 2)));
+}
+
+// Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point
+// elements) from a into memory. mem_addr does not need to be aligned on any
+// particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storeu_pd
+FORCE_INLINE void _mm_storeu_pd(double *mem_addr, __m128d a)
+{
+    _mm_store_pd(mem_addr, a);
+}
+
+// Store 128-bits of integer data from a into memory. mem_addr does not need to
+// be aligned on any particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storeu_si128
+FORCE_INLINE void _mm_storeu_si128(__m128i *p, __m128i a)
+{
+    vst1q_s32((int32_t *) p, vreinterpretq_s32_m128i(a));
+}
+
+// Store 32-bit integer from the first element of a into memory. mem_addr does
+// not need to be aligned on any particular boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_storeu_si32
+FORCE_INLINE void _mm_storeu_si32(void *p, __m128i a)
+{
+    vst1q_lane_s32((int32_t *) p, vreinterpretq_s32_m128i(a), 0);
+}
+
+// Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point
+// elements) from a into memory using a non-temporal memory hint. mem_addr must
+// be aligned on a 16-byte boundary or a general-protection exception may be
+// generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_stream_pd
+FORCE_INLINE void _mm_stream_pd(double *p, __m128d a)
+{
+#if __has_builtin(__builtin_nontemporal_store)
+    __builtin_nontemporal_store(a, (__m128d *) p);
+#elif defined(__aarch64__) || defined(_M_ARM64)
+    vst1q_f64(p, vreinterpretq_f64_m128d(a));
+#else
+    vst1q_s64((int64_t *) p, vreinterpretq_s64_m128d(a));
+#endif
+}
+
+// Store 128-bits of integer data from a into memory using a non-temporal memory
+// hint. mem_addr must be aligned on a 16-byte boundary or a general-protection
+// exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_stream_si128
+FORCE_INLINE void _mm_stream_si128(__m128i *p, __m128i a)
+{
+#if __has_builtin(__builtin_nontemporal_store)
+    __builtin_nontemporal_store(a, p);
+#else
+    vst1q_s64((int64_t *) p, vreinterpretq_s64_m128i(a));
+#endif
+}
+
+// Store 32-bit integer a into memory using a non-temporal hint to minimize
+// cache pollution. If the cache line containing address mem_addr is already in
+// the cache, the cache will be updated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_stream_si32
+FORCE_INLINE void _mm_stream_si32(int *p, int a)
+{
+    vst1q_lane_s32((int32_t *) p, vdupq_n_s32(a), 0);
+}
+
+// Store 64-bit integer a into memory using a non-temporal hint to minimize
+// cache pollution. If the cache line containing address mem_addr is already in
+// the cache, the cache will be updated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_stream_si64
+FORCE_INLINE void _mm_stream_si64(__int64 *p, __int64 a)
+{
+    vst1_s64((int64_t *) p, vdup_n_s64((int64_t) a));
+}
+
+// Subtract packed 16-bit integers in b from packed 16-bit integers in a, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sub_epi16
+FORCE_INLINE __m128i _mm_sub_epi16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s16(
+        vsubq_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b)));
+}
+
+// Subtract packed 32-bit integers in b from packed 32-bit integers in a, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sub_epi32
+FORCE_INLINE __m128i _mm_sub_epi32(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s32(
+        vsubq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+}
+
+// Subtract packed 64-bit integers in b from packed 64-bit integers in a, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sub_epi64
+FORCE_INLINE __m128i _mm_sub_epi64(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s64(
+        vsubq_s64(vreinterpretq_s64_m128i(a), vreinterpretq_s64_m128i(b)));
+}
+
+// Subtract packed 8-bit integers in b from packed 8-bit integers in a, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sub_epi8
+FORCE_INLINE __m128i _mm_sub_epi8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s8(
+        vsubq_s8(vreinterpretq_s8_m128i(a), vreinterpretq_s8_m128i(b)));
+}
+
+// Subtract packed double-precision (64-bit) floating-point elements in b from
+// packed double-precision (64-bit) floating-point elements in a, and store the
+// results in dst.
+//  https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=mm_sub_pd
+FORCE_INLINE __m128d _mm_sub_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vsubq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    double c[2];
+    c[0] = a0 - b0;
+    c[1] = a1 - b1;
+    return vld1q_f32((float32_t *) c);
+#endif
+}
+
+// Subtract the lower double-precision (64-bit) floating-point element in b from
+// the lower double-precision (64-bit) floating-point element in a, store the
+// result in the lower element of dst, and copy the upper element from a to the
+// upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sub_sd
+FORCE_INLINE __m128d _mm_sub_sd(__m128d a, __m128d b)
+{
+    return _mm_move_sd(a, _mm_sub_pd(a, b));
+}
+
+// Subtract 64-bit integer b from 64-bit integer a, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sub_si64
+FORCE_INLINE __m64 _mm_sub_si64(__m64 a, __m64 b)
+{
+    return vreinterpret_m64_s64(
+        vsub_s64(vreinterpret_s64_m64(a), vreinterpret_s64_m64(b)));
+}
+
+// Subtract packed signed 16-bit integers in b from packed 16-bit integers in a
+// using saturation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_subs_epi16
+FORCE_INLINE __m128i _mm_subs_epi16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s16(
+        vqsubq_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b)));
+}
+
+// Subtract packed signed 8-bit integers in b from packed 8-bit integers in a
+// using saturation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_subs_epi8
+FORCE_INLINE __m128i _mm_subs_epi8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s8(
+        vqsubq_s8(vreinterpretq_s8_m128i(a), vreinterpretq_s8_m128i(b)));
+}
+
+// Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit
+// integers in a using saturation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_subs_epu16
+FORCE_INLINE __m128i _mm_subs_epu16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u16(
+        vqsubq_u16(vreinterpretq_u16_m128i(a), vreinterpretq_u16_m128i(b)));
+}
+
+// Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit
+// integers in a using saturation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_subs_epu8
+FORCE_INLINE __m128i _mm_subs_epu8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u8(
+        vqsubq_u8(vreinterpretq_u8_m128i(a), vreinterpretq_u8_m128i(b)));
+}
+
+#define _mm_ucomieq_sd _mm_comieq_sd
+#define _mm_ucomige_sd _mm_comige_sd
+#define _mm_ucomigt_sd _mm_comigt_sd
+#define _mm_ucomile_sd _mm_comile_sd
+#define _mm_ucomilt_sd _mm_comilt_sd
+#define _mm_ucomineq_sd _mm_comineq_sd
+
+// Return vector of type __m128d with undefined elements.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_undefined_pd
+FORCE_INLINE __m128d _mm_undefined_pd(void)
+{
+#if defined(__GNUC__) || defined(__clang__)
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wuninitialized"
+#endif
+    __m128d a;
+#if defined(_MSC_VER) && !defined(__clang__)
+    a = _mm_setzero_pd();
+#endif
+    return a;
+#if defined(__GNUC__) || defined(__clang__)
+#pragma GCC diagnostic pop
+#endif
+}
+
+// Unpack and interleave 16-bit integers from the high half of a and b, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_unpackhi_epi16
+FORCE_INLINE __m128i _mm_unpackhi_epi16(__m128i a, __m128i b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s16(
+        vzip2q_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b)));
+#else
+    int16x4_t a1 = vget_high_s16(vreinterpretq_s16_m128i(a));
+    int16x4_t b1 = vget_high_s16(vreinterpretq_s16_m128i(b));
+    int16x4x2_t result = vzip_s16(a1, b1);
+    return vreinterpretq_m128i_s16(vcombine_s16(result.val[0], result.val[1]));
+#endif
+}
+
+// Unpack and interleave 32-bit integers from the high half of a and b, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_unpackhi_epi32
+FORCE_INLINE __m128i _mm_unpackhi_epi32(__m128i a, __m128i b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s32(
+        vzip2q_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+#else
+    int32x2_t a1 = vget_high_s32(vreinterpretq_s32_m128i(a));
+    int32x2_t b1 = vget_high_s32(vreinterpretq_s32_m128i(b));
+    int32x2x2_t result = vzip_s32(a1, b1);
+    return vreinterpretq_m128i_s32(vcombine_s32(result.val[0], result.val[1]));
+#endif
+}
+
+// Unpack and interleave 64-bit integers from the high half of a and b, and
+// store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_unpackhi_epi64
+FORCE_INLINE __m128i _mm_unpackhi_epi64(__m128i a, __m128i b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s64(
+        vzip2q_s64(vreinterpretq_s64_m128i(a), vreinterpretq_s64_m128i(b)));
+#else
+    int64x1_t a_h = vget_high_s64(vreinterpretq_s64_m128i(a));
+    int64x1_t b_h = vget_high_s64(vreinterpretq_s64_m128i(b));
+    return vreinterpretq_m128i_s64(vcombine_s64(a_h, b_h));
+#endif
+}
+
+// Unpack and interleave 8-bit integers from the high half of a and b, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_unpackhi_epi8
+FORCE_INLINE __m128i _mm_unpackhi_epi8(__m128i a, __m128i b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s8(
+        vzip2q_s8(vreinterpretq_s8_m128i(a), vreinterpretq_s8_m128i(b)));
+#else
+    int8x8_t a1 =
+        vreinterpret_s8_s16(vget_high_s16(vreinterpretq_s16_m128i(a)));
+    int8x8_t b1 =
+        vreinterpret_s8_s16(vget_high_s16(vreinterpretq_s16_m128i(b)));
+    int8x8x2_t result = vzip_s8(a1, b1);
+    return vreinterpretq_m128i_s8(vcombine_s8(result.val[0], result.val[1]));
+#endif
+}
+
+// Unpack and interleave double-precision (64-bit) floating-point elements from
+// the high half of a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_unpackhi_pd
+FORCE_INLINE __m128d _mm_unpackhi_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vzip2q_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#else
+    return vreinterpretq_m128d_s64(
+        vcombine_s64(vget_high_s64(vreinterpretq_s64_m128d(a)),
+                     vget_high_s64(vreinterpretq_s64_m128d(b))));
+#endif
+}
+
+// Unpack and interleave 16-bit integers from the low half of a and b, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_unpacklo_epi16
+FORCE_INLINE __m128i _mm_unpacklo_epi16(__m128i a, __m128i b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s16(
+        vzip1q_s16(vreinterpretq_s16_m128i(a), vreinterpretq_s16_m128i(b)));
+#else
+    int16x4_t a1 = vget_low_s16(vreinterpretq_s16_m128i(a));
+    int16x4_t b1 = vget_low_s16(vreinterpretq_s16_m128i(b));
+    int16x4x2_t result = vzip_s16(a1, b1);
+    return vreinterpretq_m128i_s16(vcombine_s16(result.val[0], result.val[1]));
+#endif
+}
+
+// Unpack and interleave 32-bit integers from the low half of a and b, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_unpacklo_epi32
+FORCE_INLINE __m128i _mm_unpacklo_epi32(__m128i a, __m128i b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s32(
+        vzip1q_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+#else
+    int32x2_t a1 = vget_low_s32(vreinterpretq_s32_m128i(a));
+    int32x2_t b1 = vget_low_s32(vreinterpretq_s32_m128i(b));
+    int32x2x2_t result = vzip_s32(a1, b1);
+    return vreinterpretq_m128i_s32(vcombine_s32(result.val[0], result.val[1]));
+#endif
+}
+
+// Unpack and interleave 64-bit integers from the low half of a and b, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_unpacklo_epi64
+FORCE_INLINE __m128i _mm_unpacklo_epi64(__m128i a, __m128i b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s64(
+        vzip1q_s64(vreinterpretq_s64_m128i(a), vreinterpretq_s64_m128i(b)));
+#else
+    int64x1_t a_l = vget_low_s64(vreinterpretq_s64_m128i(a));
+    int64x1_t b_l = vget_low_s64(vreinterpretq_s64_m128i(b));
+    return vreinterpretq_m128i_s64(vcombine_s64(a_l, b_l));
+#endif
+}
+
+// Unpack and interleave 8-bit integers from the low half of a and b, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_unpacklo_epi8
+FORCE_INLINE __m128i _mm_unpacklo_epi8(__m128i a, __m128i b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s8(
+        vzip1q_s8(vreinterpretq_s8_m128i(a), vreinterpretq_s8_m128i(b)));
+#else
+    int8x8_t a1 = vreinterpret_s8_s16(vget_low_s16(vreinterpretq_s16_m128i(a)));
+    int8x8_t b1 = vreinterpret_s8_s16(vget_low_s16(vreinterpretq_s16_m128i(b)));
+    int8x8x2_t result = vzip_s8(a1, b1);
+    return vreinterpretq_m128i_s8(vcombine_s8(result.val[0], result.val[1]));
+#endif
+}
+
+// Unpack and interleave double-precision (64-bit) floating-point elements from
+// the low half of a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_unpacklo_pd
+FORCE_INLINE __m128d _mm_unpacklo_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vzip1q_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#else
+    return vreinterpretq_m128d_s64(
+        vcombine_s64(vget_low_s64(vreinterpretq_s64_m128d(a)),
+                     vget_low_s64(vreinterpretq_s64_m128d(b))));
+#endif
+}
+
+// Compute the bitwise XOR of packed double-precision (64-bit) floating-point
+// elements in a and b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_xor_pd
+FORCE_INLINE __m128d _mm_xor_pd(__m128d a, __m128d b)
+{
+    return vreinterpretq_m128d_s64(
+        veorq_s64(vreinterpretq_s64_m128d(a), vreinterpretq_s64_m128d(b)));
+}
+
+// Compute the bitwise XOR of 128 bits (representing integer data) in a and b,
+// and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_xor_si128
+FORCE_INLINE __m128i _mm_xor_si128(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s32(
+        veorq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+}
+
+/* SSE3 */
+
+// Alternatively add and subtract packed double-precision (64-bit)
+// floating-point elements in a to/from packed elements in b, and store the
+// results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_addsub_pd
+FORCE_INLINE __m128d _mm_addsub_pd(__m128d a, __m128d b)
+{
+    _sse2neon_const __m128d mask = _mm_set_pd(1.0f, -1.0f);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(vfmaq_f64(vreinterpretq_f64_m128d(a),
+                                             vreinterpretq_f64_m128d(b),
+                                             vreinterpretq_f64_m128d(mask)));
+#else
+    return _mm_add_pd(_mm_mul_pd(b, mask), a);
+#endif
+}
+
+// Alternatively add and subtract packed single-precision (32-bit)
+// floating-point elements in a to/from packed elements in b, and store the
+// results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=addsub_ps
+FORCE_INLINE __m128 _mm_addsub_ps(__m128 a, __m128 b)
+{
+    _sse2neon_const __m128 mask = _mm_setr_ps(-1.0f, 1.0f, -1.0f, 1.0f);
+#if (defined(__aarch64__) || defined(_M_ARM64)) || \
+    defined(__ARM_FEATURE_FMA) /* VFPv4+ */
+    return vreinterpretq_m128_f32(vfmaq_f32(vreinterpretq_f32_m128(a),
+                                            vreinterpretq_f32_m128(mask),
+                                            vreinterpretq_f32_m128(b)));
+#else
+    return _mm_add_ps(_mm_mul_ps(b, mask), a);
+#endif
+}
+
+// Horizontally add adjacent pairs of double-precision (64-bit) floating-point
+// elements in a and b, and pack the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hadd_pd
+FORCE_INLINE __m128d _mm_hadd_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vpaddq_f64(vreinterpretq_f64_m128d(a), vreinterpretq_f64_m128d(b)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    double c[] = {a0 + a1, b0 + b1};
+    return vreinterpretq_m128d_u64(vld1q_u64((uint64_t *) c));
+#endif
+}
+
+// Horizontally add adjacent pairs of single-precision (32-bit) floating-point
+// elements in a and b, and pack the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hadd_ps
+FORCE_INLINE __m128 _mm_hadd_ps(__m128 a, __m128 b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128_f32(
+        vpaddq_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(b)));
+#else
+    float32x2_t a10 = vget_low_f32(vreinterpretq_f32_m128(a));
+    float32x2_t a32 = vget_high_f32(vreinterpretq_f32_m128(a));
+    float32x2_t b10 = vget_low_f32(vreinterpretq_f32_m128(b));
+    float32x2_t b32 = vget_high_f32(vreinterpretq_f32_m128(b));
+    return vreinterpretq_m128_f32(
+        vcombine_f32(vpadd_f32(a10, a32), vpadd_f32(b10, b32)));
+#endif
+}
+
+// Horizontally subtract adjacent pairs of double-precision (64-bit)
+// floating-point elements in a and b, and pack the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hsub_pd
+FORCE_INLINE __m128d _mm_hsub_pd(__m128d a, __m128d b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    float64x2_t _a = vreinterpretq_f64_m128d(a);
+    float64x2_t _b = vreinterpretq_f64_m128d(b);
+    return vreinterpretq_m128d_f64(
+        vsubq_f64(vuzp1q_f64(_a, _b), vuzp2q_f64(_a, _b)));
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    double c[] = {a0 - a1, b0 - b1};
+    return vreinterpretq_m128d_u64(vld1q_u64((uint64_t *) c));
+#endif
+}
+
+// Horizontally subtract adjacent pairs of single-precision (32-bit)
+// floating-point elements in a and b, and pack the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hsub_ps
+FORCE_INLINE __m128 _mm_hsub_ps(__m128 _a, __m128 _b)
+{
+    float32x4_t a = vreinterpretq_f32_m128(_a);
+    float32x4_t b = vreinterpretq_f32_m128(_b);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128_f32(
+        vsubq_f32(vuzp1q_f32(a, b), vuzp2q_f32(a, b)));
+#else
+    float32x4x2_t c = vuzpq_f32(a, b);
+    return vreinterpretq_m128_f32(vsubq_f32(c.val[0], c.val[1]));
+#endif
+}
+
+// Load 128-bits of integer data from unaligned memory into dst. This intrinsic
+// may perform better than _mm_loadu_si128 when the data crosses a cache line
+// boundary.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_lddqu_si128
+#define _mm_lddqu_si128 _mm_loadu_si128
+
+// Load a double-precision (64-bit) floating-point element from memory into both
+// elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_loaddup_pd
+#define _mm_loaddup_pd _mm_load1_pd
+
+// Duplicate the low double-precision (64-bit) floating-point element from a,
+// and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_movedup_pd
+FORCE_INLINE __m128d _mm_movedup_pd(__m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(
+        vdupq_laneq_f64(vreinterpretq_f64_m128d(a), 0));
+#else
+    return vreinterpretq_m128d_u64(
+        vdupq_n_u64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0)));
+#endif
+}
+
+// Duplicate odd-indexed single-precision (32-bit) floating-point elements
+// from a, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_movehdup_ps
+FORCE_INLINE __m128 _mm_movehdup_ps(__m128 a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128_f32(
+        vtrn2q_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(a)));
+#elif defined(_sse2neon_shuffle)
+    return vreinterpretq_m128_f32(vshuffleq_s32(
+        vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(a), 1, 1, 3, 3));
+#else
+    float32_t a1 = vgetq_lane_f32(vreinterpretq_f32_m128(a), 1);
+    float32_t a3 = vgetq_lane_f32(vreinterpretq_f32_m128(a), 3);
+    float ALIGN_STRUCT(16) data[4] = {a1, a1, a3, a3};
+    return vreinterpretq_m128_f32(vld1q_f32(data));
+#endif
+}
+
+// Duplicate even-indexed single-precision (32-bit) floating-point elements
+// from a, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_moveldup_ps
+FORCE_INLINE __m128 _mm_moveldup_ps(__m128 a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128_f32(
+        vtrn1q_f32(vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(a)));
+#elif defined(_sse2neon_shuffle)
+    return vreinterpretq_m128_f32(vshuffleq_s32(
+        vreinterpretq_f32_m128(a), vreinterpretq_f32_m128(a), 0, 0, 2, 2));
+#else
+    float32_t a0 = vgetq_lane_f32(vreinterpretq_f32_m128(a), 0);
+    float32_t a2 = vgetq_lane_f32(vreinterpretq_f32_m128(a), 2);
+    float ALIGN_STRUCT(16) data[4] = {a0, a0, a2, a2};
+    return vreinterpretq_m128_f32(vld1q_f32(data));
+#endif
+}
+
+/* SSSE3 */
+
+// Compute the absolute value of packed signed 16-bit integers in a, and store
+// the unsigned results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_abs_epi16
+FORCE_INLINE __m128i _mm_abs_epi16(__m128i a)
+{
+    return vreinterpretq_m128i_s16(vabsq_s16(vreinterpretq_s16_m128i(a)));
+}
+
+// Compute the absolute value of packed signed 32-bit integers in a, and store
+// the unsigned results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_abs_epi32
+FORCE_INLINE __m128i _mm_abs_epi32(__m128i a)
+{
+    return vreinterpretq_m128i_s32(vabsq_s32(vreinterpretq_s32_m128i(a)));
+}
+
+// Compute the absolute value of packed signed 8-bit integers in a, and store
+// the unsigned results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_abs_epi8
+FORCE_INLINE __m128i _mm_abs_epi8(__m128i a)
+{
+    return vreinterpretq_m128i_s8(vabsq_s8(vreinterpretq_s8_m128i(a)));
+}
+
+// Compute the absolute value of packed signed 16-bit integers in a, and store
+// the unsigned results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_abs_pi16
+FORCE_INLINE __m64 _mm_abs_pi16(__m64 a)
+{
+    return vreinterpret_m64_s16(vabs_s16(vreinterpret_s16_m64(a)));
+}
+
+// Compute the absolute value of packed signed 32-bit integers in a, and store
+// the unsigned results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_abs_pi32
+FORCE_INLINE __m64 _mm_abs_pi32(__m64 a)
+{
+    return vreinterpret_m64_s32(vabs_s32(vreinterpret_s32_m64(a)));
+}
+
+// Compute the absolute value of packed signed 8-bit integers in a, and store
+// the unsigned results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_abs_pi8
+FORCE_INLINE __m64 _mm_abs_pi8(__m64 a)
+{
+    return vreinterpret_m64_s8(vabs_s8(vreinterpret_s8_m64(a)));
+}
+
+// Concatenate 16-byte blocks in a and b into a 32-byte temporary result, shift
+// the result right by imm8 bytes, and store the low 16 bytes in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_alignr_epi8
+#if defined(__GNUC__) && !defined(__clang__)
+#define _mm_alignr_epi8(a, b, imm)                                            \
+    __extension__({                                                           \
+        uint8x16_t _a = vreinterpretq_u8_m128i(a);                            \
+        uint8x16_t _b = vreinterpretq_u8_m128i(b);                            \
+        __m128i ret;                                                          \
+        if (_sse2neon_unlikely((imm) & ~31))                                  \
+            ret = vreinterpretq_m128i_u8(vdupq_n_u8(0));                      \
+        else if (imm >= 16)                                                   \
+            ret = _mm_srli_si128(a, imm >= 16 ? imm - 16 : 0);                \
+        else                                                                  \
+            ret =                                                             \
+                vreinterpretq_m128i_u8(vextq_u8(_b, _a, imm < 16 ? imm : 0)); \
+        ret;                                                                  \
+    })
+
+#else
+#define _mm_alignr_epi8(a, b, imm)                                          \
+    _sse2neon_define2(                                                      \
+        __m128i, a, b, uint8x16_t __a = vreinterpretq_u8_m128i(_a);         \
+        uint8x16_t __b = vreinterpretq_u8_m128i(_b); __m128i ret;           \
+        if (_sse2neon_unlikely((imm) & ~31)) ret =                          \
+            vreinterpretq_m128i_u8(vdupq_n_u8(0));                          \
+        else if (imm >= 16) ret =                                           \
+            _mm_srli_si128(_a, imm >= 16 ? imm - 16 : 0);                   \
+        else ret =                                                          \
+            vreinterpretq_m128i_u8(vextq_u8(__b, __a, imm < 16 ? imm : 0)); \
+        _sse2neon_return(ret);)
+
+#endif
+
+// Concatenate 8-byte blocks in a and b into a 16-byte temporary result, shift
+// the result right by imm8 bytes, and store the low 8 bytes in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_alignr_pi8
+#define _mm_alignr_pi8(a, b, imm)                                           \
+    _sse2neon_define2(                                                      \
+        __m64, a, b, __m64 ret; if (_sse2neon_unlikely((imm) >= 16)) {      \
+            ret = vreinterpret_m64_s8(vdup_n_s8(0));                        \
+        } else {                                                            \
+            uint8x8_t tmp_low;                                              \
+            uint8x8_t tmp_high;                                             \
+            if ((imm) >= 8) {                                               \
+                const int idx = (imm) -8;                                   \
+                tmp_low = vreinterpret_u8_m64(_a);                          \
+                tmp_high = vdup_n_u8(0);                                    \
+                ret = vreinterpret_m64_u8(vext_u8(tmp_low, tmp_high, idx)); \
+            } else {                                                        \
+                const int idx = (imm);                                      \
+                tmp_low = vreinterpret_u8_m64(_b);                          \
+                tmp_high = vreinterpret_u8_m64(_a);                         \
+                ret = vreinterpret_m64_u8(vext_u8(tmp_low, tmp_high, idx)); \
+            }                                                               \
+        } _sse2neon_return(ret);)
+
+// Horizontally add adjacent pairs of 16-bit integers in a and b, and pack the
+// signed 16-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hadd_epi16
+FORCE_INLINE __m128i _mm_hadd_epi16(__m128i _a, __m128i _b)
+{
+    int16x8_t a = vreinterpretq_s16_m128i(_a);
+    int16x8_t b = vreinterpretq_s16_m128i(_b);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s16(vpaddq_s16(a, b));
+#else
+    return vreinterpretq_m128i_s16(
+        vcombine_s16(vpadd_s16(vget_low_s16(a), vget_high_s16(a)),
+                     vpadd_s16(vget_low_s16(b), vget_high_s16(b))));
+#endif
+}
+
+// Horizontally add adjacent pairs of 32-bit integers in a and b, and pack the
+// signed 32-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hadd_epi32
+FORCE_INLINE __m128i _mm_hadd_epi32(__m128i _a, __m128i _b)
+{
+    int32x4_t a = vreinterpretq_s32_m128i(_a);
+    int32x4_t b = vreinterpretq_s32_m128i(_b);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s32(vpaddq_s32(a, b));
+#else
+    return vreinterpretq_m128i_s32(
+        vcombine_s32(vpadd_s32(vget_low_s32(a), vget_high_s32(a)),
+                     vpadd_s32(vget_low_s32(b), vget_high_s32(b))));
+#endif
+}
+
+// Horizontally add adjacent pairs of 16-bit integers in a and b, and pack the
+// signed 16-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hadd_pi16
+FORCE_INLINE __m64 _mm_hadd_pi16(__m64 a, __m64 b)
+{
+    return vreinterpret_m64_s16(
+        vpadd_s16(vreinterpret_s16_m64(a), vreinterpret_s16_m64(b)));
+}
+
+// Horizontally add adjacent pairs of 32-bit integers in a and b, and pack the
+// signed 32-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hadd_pi32
+FORCE_INLINE __m64 _mm_hadd_pi32(__m64 a, __m64 b)
+{
+    return vreinterpret_m64_s32(
+        vpadd_s32(vreinterpret_s32_m64(a), vreinterpret_s32_m64(b)));
+}
+
+// Horizontally add adjacent pairs of signed 16-bit integers in a and b using
+// saturation, and pack the signed 16-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hadds_epi16
+FORCE_INLINE __m128i _mm_hadds_epi16(__m128i _a, __m128i _b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    int16x8_t a = vreinterpretq_s16_m128i(_a);
+    int16x8_t b = vreinterpretq_s16_m128i(_b);
+    return vreinterpretq_s64_s16(
+        vqaddq_s16(vuzp1q_s16(a, b), vuzp2q_s16(a, b)));
+#else
+    int32x4_t a = vreinterpretq_s32_m128i(_a);
+    int32x4_t b = vreinterpretq_s32_m128i(_b);
+    // Interleave using vshrn/vmovn
+    // [a0|a2|a4|a6|b0|b2|b4|b6]
+    // [a1|a3|a5|a7|b1|b3|b5|b7]
+    int16x8_t ab0246 = vcombine_s16(vmovn_s32(a), vmovn_s32(b));
+    int16x8_t ab1357 = vcombine_s16(vshrn_n_s32(a, 16), vshrn_n_s32(b, 16));
+    // Saturated add
+    return vreinterpretq_m128i_s16(vqaddq_s16(ab0246, ab1357));
+#endif
+}
+
+// Horizontally add adjacent pairs of signed 16-bit integers in a and b using
+// saturation, and pack the signed 16-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hadds_pi16
+FORCE_INLINE __m64 _mm_hadds_pi16(__m64 _a, __m64 _b)
+{
+    int16x4_t a = vreinterpret_s16_m64(_a);
+    int16x4_t b = vreinterpret_s16_m64(_b);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpret_s64_s16(vqadd_s16(vuzp1_s16(a, b), vuzp2_s16(a, b)));
+#else
+    int16x4x2_t res = vuzp_s16(a, b);
+    return vreinterpret_s64_s16(vqadd_s16(res.val[0], res.val[1]));
+#endif
+}
+
+// Horizontally subtract adjacent pairs of 16-bit integers in a and b, and pack
+// the signed 16-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hsub_epi16
+FORCE_INLINE __m128i _mm_hsub_epi16(__m128i _a, __m128i _b)
+{
+    int16x8_t a = vreinterpretq_s16_m128i(_a);
+    int16x8_t b = vreinterpretq_s16_m128i(_b);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s16(
+        vsubq_s16(vuzp1q_s16(a, b), vuzp2q_s16(a, b)));
+#else
+    int16x8x2_t c = vuzpq_s16(a, b);
+    return vreinterpretq_m128i_s16(vsubq_s16(c.val[0], c.val[1]));
+#endif
+}
+
+// Horizontally subtract adjacent pairs of 32-bit integers in a and b, and pack
+// the signed 32-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hsub_epi32
+FORCE_INLINE __m128i _mm_hsub_epi32(__m128i _a, __m128i _b)
+{
+    int32x4_t a = vreinterpretq_s32_m128i(_a);
+    int32x4_t b = vreinterpretq_s32_m128i(_b);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s32(
+        vsubq_s32(vuzp1q_s32(a, b), vuzp2q_s32(a, b)));
+#else
+    int32x4x2_t c = vuzpq_s32(a, b);
+    return vreinterpretq_m128i_s32(vsubq_s32(c.val[0], c.val[1]));
+#endif
+}
+
+// Horizontally subtract adjacent pairs of 16-bit integers in a and b, and pack
+// the signed 16-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hsub_pi16
+FORCE_INLINE __m64 _mm_hsub_pi16(__m64 _a, __m64 _b)
+{
+    int16x4_t a = vreinterpret_s16_m64(_a);
+    int16x4_t b = vreinterpret_s16_m64(_b);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpret_m64_s16(vsub_s16(vuzp1_s16(a, b), vuzp2_s16(a, b)));
+#else
+    int16x4x2_t c = vuzp_s16(a, b);
+    return vreinterpret_m64_s16(vsub_s16(c.val[0], c.val[1]));
+#endif
+}
+
+// Horizontally subtract adjacent pairs of 32-bit integers in a and b, and pack
+// the signed 32-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=mm_hsub_pi32
+FORCE_INLINE __m64 _mm_hsub_pi32(__m64 _a, __m64 _b)
+{
+    int32x2_t a = vreinterpret_s32_m64(_a);
+    int32x2_t b = vreinterpret_s32_m64(_b);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpret_m64_s32(vsub_s32(vuzp1_s32(a, b), vuzp2_s32(a, b)));
+#else
+    int32x2x2_t c = vuzp_s32(a, b);
+    return vreinterpret_m64_s32(vsub_s32(c.val[0], c.val[1]));
+#endif
+}
+
+// Horizontally subtract adjacent pairs of signed 16-bit integers in a and b
+// using saturation, and pack the signed 16-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hsubs_epi16
+FORCE_INLINE __m128i _mm_hsubs_epi16(__m128i _a, __m128i _b)
+{
+    int16x8_t a = vreinterpretq_s16_m128i(_a);
+    int16x8_t b = vreinterpretq_s16_m128i(_b);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s16(
+        vqsubq_s16(vuzp1q_s16(a, b), vuzp2q_s16(a, b)));
+#else
+    int16x8x2_t c = vuzpq_s16(a, b);
+    return vreinterpretq_m128i_s16(vqsubq_s16(c.val[0], c.val[1]));
+#endif
+}
+
+// Horizontally subtract adjacent pairs of signed 16-bit integers in a and b
+// using saturation, and pack the signed 16-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_hsubs_pi16
+FORCE_INLINE __m64 _mm_hsubs_pi16(__m64 _a, __m64 _b)
+{
+    int16x4_t a = vreinterpret_s16_m64(_a);
+    int16x4_t b = vreinterpret_s16_m64(_b);
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpret_m64_s16(vqsub_s16(vuzp1_s16(a, b), vuzp2_s16(a, b)));
+#else
+    int16x4x2_t c = vuzp_s16(a, b);
+    return vreinterpret_m64_s16(vqsub_s16(c.val[0], c.val[1]));
+#endif
+}
+
+// Vertically multiply each unsigned 8-bit integer from a with the corresponding
+// signed 8-bit integer from b, producing intermediate signed 16-bit integers.
+// Horizontally add adjacent pairs of intermediate signed 16-bit integers,
+// and pack the saturated results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_maddubs_epi16
+FORCE_INLINE __m128i _mm_maddubs_epi16(__m128i _a, __m128i _b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    uint8x16_t a = vreinterpretq_u8_m128i(_a);
+    int8x16_t b = vreinterpretq_s8_m128i(_b);
+    int16x8_t tl = vmulq_s16(vreinterpretq_s16_u16(vmovl_u8(vget_low_u8(a))),
+                             vmovl_s8(vget_low_s8(b)));
+    int16x8_t th = vmulq_s16(vreinterpretq_s16_u16(vmovl_u8(vget_high_u8(a))),
+                             vmovl_s8(vget_high_s8(b)));
+    return vreinterpretq_m128i_s16(
+        vqaddq_s16(vuzp1q_s16(tl, th), vuzp2q_s16(tl, th)));
+#else
+    // This would be much simpler if x86 would choose to zero extend OR sign
+    // extend, not both. This could probably be optimized better.
+    uint16x8_t a = vreinterpretq_u16_m128i(_a);
+    int16x8_t b = vreinterpretq_s16_m128i(_b);
+
+    // Zero extend a
+    int16x8_t a_odd = vreinterpretq_s16_u16(vshrq_n_u16(a, 8));
+    int16x8_t a_even = vreinterpretq_s16_u16(vbicq_u16(a, vdupq_n_u16(0xff00)));
+
+    // Sign extend by shifting left then shifting right.
+    int16x8_t b_even = vshrq_n_s16(vshlq_n_s16(b, 8), 8);
+    int16x8_t b_odd = vshrq_n_s16(b, 8);
+
+    // multiply
+    int16x8_t prod1 = vmulq_s16(a_even, b_even);
+    int16x8_t prod2 = vmulq_s16(a_odd, b_odd);
+
+    // saturated add
+    return vreinterpretq_m128i_s16(vqaddq_s16(prod1, prod2));
+#endif
+}
+
+// Vertically multiply each unsigned 8-bit integer from a with the corresponding
+// signed 8-bit integer from b, producing intermediate signed 16-bit integers.
+// Horizontally add adjacent pairs of intermediate signed 16-bit integers, and
+// pack the saturated results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_maddubs_pi16
+FORCE_INLINE __m64 _mm_maddubs_pi16(__m64 _a, __m64 _b)
+{
+    uint16x4_t a = vreinterpret_u16_m64(_a);
+    int16x4_t b = vreinterpret_s16_m64(_b);
+
+    // Zero extend a
+    int16x4_t a_odd = vreinterpret_s16_u16(vshr_n_u16(a, 8));
+    int16x4_t a_even = vreinterpret_s16_u16(vand_u16(a, vdup_n_u16(0xff)));
+
+    // Sign extend by shifting left then shifting right.
+    int16x4_t b_even = vshr_n_s16(vshl_n_s16(b, 8), 8);
+    int16x4_t b_odd = vshr_n_s16(b, 8);
+
+    // multiply
+    int16x4_t prod1 = vmul_s16(a_even, b_even);
+    int16x4_t prod2 = vmul_s16(a_odd, b_odd);
+
+    // saturated add
+    return vreinterpret_m64_s16(vqadd_s16(prod1, prod2));
+}
+
+// Multiply packed signed 16-bit integers in a and b, producing intermediate
+// signed 32-bit integers. Shift right by 15 bits while rounding up, and store
+// the packed 16-bit integers in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mulhrs_epi16
+FORCE_INLINE __m128i _mm_mulhrs_epi16(__m128i a, __m128i b)
+{
+    // Has issues due to saturation
+    // return vreinterpretq_m128i_s16(vqrdmulhq_s16(a, b));
+
+    // Multiply
+    int32x4_t mul_lo = vmull_s16(vget_low_s16(vreinterpretq_s16_m128i(a)),
+                                 vget_low_s16(vreinterpretq_s16_m128i(b)));
+    int32x4_t mul_hi = vmull_s16(vget_high_s16(vreinterpretq_s16_m128i(a)),
+                                 vget_high_s16(vreinterpretq_s16_m128i(b)));
+
+    // Rounding narrowing shift right
+    // narrow = (int16_t)((mul + 16384) >> 15);
+    int16x4_t narrow_lo = vrshrn_n_s32(mul_lo, 15);
+    int16x4_t narrow_hi = vrshrn_n_s32(mul_hi, 15);
+
+    // Join together
+    return vreinterpretq_m128i_s16(vcombine_s16(narrow_lo, narrow_hi));
+}
+
+// Multiply packed signed 16-bit integers in a and b, producing intermediate
+// signed 32-bit integers. Truncate each intermediate integer to the 18 most
+// significant bits, round by adding 1, and store bits [16:1] to dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mulhrs_pi16
+FORCE_INLINE __m64 _mm_mulhrs_pi16(__m64 a, __m64 b)
+{
+    int32x4_t mul_extend =
+        vmull_s16((vreinterpret_s16_m64(a)), (vreinterpret_s16_m64(b)));
+
+    // Rounding narrowing shift right
+    return vreinterpret_m64_s16(vrshrn_n_s32(mul_extend, 15));
+}
+
+// Shuffle packed 8-bit integers in a according to shuffle control mask in the
+// corresponding 8-bit element of b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_shuffle_epi8
+FORCE_INLINE __m128i _mm_shuffle_epi8(__m128i a, __m128i b)
+{
+    int8x16_t tbl = vreinterpretq_s8_m128i(a);   // input a
+    uint8x16_t idx = vreinterpretq_u8_m128i(b);  // input b
+    uint8x16_t idx_masked =
+        vandq_u8(idx, vdupq_n_u8(0x8F));  // avoid using meaningless bits
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_s8(vqtbl1q_s8(tbl, idx_masked));
+#elif defined(__GNUC__)
+    int8x16_t ret;
+    // %e and %f represent the even and odd D registers
+    // respectively.
+    __asm__ __volatile__(
+        "vtbl.8  %e[ret], {%e[tbl], %f[tbl]}, %e[idx]\n"
+        "vtbl.8  %f[ret], {%e[tbl], %f[tbl]}, %f[idx]\n"
+        : [ret] "=&w"(ret)
+        : [tbl] "w"(tbl), [idx] "w"(idx_masked));
+    return vreinterpretq_m128i_s8(ret);
+#else
+    // use this line if testing on aarch64
+    int8x8x2_t a_split = {vget_low_s8(tbl), vget_high_s8(tbl)};
+    return vreinterpretq_m128i_s8(
+        vcombine_s8(vtbl2_s8(a_split, vget_low_u8(idx_masked)),
+                    vtbl2_s8(a_split, vget_high_u8(idx_masked))));
+#endif
+}
+
+// Shuffle packed 8-bit integers in a according to shuffle control mask in the
+// corresponding 8-bit element of b, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_shuffle_pi8
+FORCE_INLINE __m64 _mm_shuffle_pi8(__m64 a, __m64 b)
+{
+    const int8x8_t controlMask =
+        vand_s8(vreinterpret_s8_m64(b), vdup_n_s8((int8_t) (0x1 << 7 | 0x07)));
+    int8x8_t res = vtbl1_s8(vreinterpret_s8_m64(a), controlMask);
+    return vreinterpret_m64_s8(res);
+}
+
+// Negate packed 16-bit integers in a when the corresponding signed
+// 16-bit integer in b is negative, and store the results in dst.
+// Element in dst are zeroed out when the corresponding element
+// in b is zero.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sign_epi16
+FORCE_INLINE __m128i _mm_sign_epi16(__m128i _a, __m128i _b)
+{
+    int16x8_t a = vreinterpretq_s16_m128i(_a);
+    int16x8_t b = vreinterpretq_s16_m128i(_b);
+
+    // signed shift right: faster than vclt
+    // (b < 0) ? 0xFFFF : 0
+    uint16x8_t ltMask = vreinterpretq_u16_s16(vshrq_n_s16(b, 15));
+    // (b == 0) ? 0xFFFF : 0
+#if defined(__aarch64__) || defined(_M_ARM64)
+    int16x8_t zeroMask = vreinterpretq_s16_u16(vceqzq_s16(b));
+#else
+    int16x8_t zeroMask = vreinterpretq_s16_u16(vceqq_s16(b, vdupq_n_s16(0)));
+#endif
+
+    // bitwise select either a or negative 'a' (vnegq_s16(a) equals to negative
+    // 'a') based on ltMask
+    int16x8_t masked = vbslq_s16(ltMask, vnegq_s16(a), a);
+    // res = masked & (~zeroMask)
+    int16x8_t res = vbicq_s16(masked, zeroMask);
+    return vreinterpretq_m128i_s16(res);
+}
+
+// Negate packed 32-bit integers in a when the corresponding signed
+// 32-bit integer in b is negative, and store the results in dst.
+// Element in dst are zeroed out when the corresponding element
+// in b is zero.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sign_epi32
+FORCE_INLINE __m128i _mm_sign_epi32(__m128i _a, __m128i _b)
+{
+    int32x4_t a = vreinterpretq_s32_m128i(_a);
+    int32x4_t b = vreinterpretq_s32_m128i(_b);
+
+    // signed shift right: faster than vclt
+    // (b < 0) ? 0xFFFFFFFF : 0
+    uint32x4_t ltMask = vreinterpretq_u32_s32(vshrq_n_s32(b, 31));
+
+    // (b == 0) ? 0xFFFFFFFF : 0
+#if defined(__aarch64__) || defined(_M_ARM64)
+    int32x4_t zeroMask = vreinterpretq_s32_u32(vceqzq_s32(b));
+#else
+    int32x4_t zeroMask = vreinterpretq_s32_u32(vceqq_s32(b, vdupq_n_s32(0)));
+#endif
+
+    // bitwise select either a or negative 'a' (vnegq_s32(a) equals to negative
+    // 'a') based on ltMask
+    int32x4_t masked = vbslq_s32(ltMask, vnegq_s32(a), a);
+    // res = masked & (~zeroMask)
+    int32x4_t res = vbicq_s32(masked, zeroMask);
+    return vreinterpretq_m128i_s32(res);
+}
+
+// Negate packed 8-bit integers in a when the corresponding signed
+// 8-bit integer in b is negative, and store the results in dst.
+// Element in dst are zeroed out when the corresponding element
+// in b is zero.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sign_epi8
+FORCE_INLINE __m128i _mm_sign_epi8(__m128i _a, __m128i _b)
+{
+    int8x16_t a = vreinterpretq_s8_m128i(_a);
+    int8x16_t b = vreinterpretq_s8_m128i(_b);
+
+    // signed shift right: faster than vclt
+    // (b < 0) ? 0xFF : 0
+    uint8x16_t ltMask = vreinterpretq_u8_s8(vshrq_n_s8(b, 7));
+
+    // (b == 0) ? 0xFF : 0
+#if defined(__aarch64__) || defined(_M_ARM64)
+    int8x16_t zeroMask = vreinterpretq_s8_u8(vceqzq_s8(b));
+#else
+    int8x16_t zeroMask = vreinterpretq_s8_u8(vceqq_s8(b, vdupq_n_s8(0)));
+#endif
+
+    // bitwise select either a or negative 'a' (vnegq_s8(a) return negative 'a')
+    // based on ltMask
+    int8x16_t masked = vbslq_s8(ltMask, vnegq_s8(a), a);
+    // res = masked & (~zeroMask)
+    int8x16_t res = vbicq_s8(masked, zeroMask);
+
+    return vreinterpretq_m128i_s8(res);
+}
+
+// Negate packed 16-bit integers in a when the corresponding signed 16-bit
+// integer in b is negative, and store the results in dst. Element in dst are
+// zeroed out when the corresponding element in b is zero.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sign_pi16
+FORCE_INLINE __m64 _mm_sign_pi16(__m64 _a, __m64 _b)
+{
+    int16x4_t a = vreinterpret_s16_m64(_a);
+    int16x4_t b = vreinterpret_s16_m64(_b);
+
+    // signed shift right: faster than vclt
+    // (b < 0) ? 0xFFFF : 0
+    uint16x4_t ltMask = vreinterpret_u16_s16(vshr_n_s16(b, 15));
+
+    // (b == 0) ? 0xFFFF : 0
+#if defined(__aarch64__) || defined(_M_ARM64)
+    int16x4_t zeroMask = vreinterpret_s16_u16(vceqz_s16(b));
+#else
+    int16x4_t zeroMask = vreinterpret_s16_u16(vceq_s16(b, vdup_n_s16(0)));
+#endif
+
+    // bitwise select either a or negative 'a' (vneg_s16(a) return negative 'a')
+    // based on ltMask
+    int16x4_t masked = vbsl_s16(ltMask, vneg_s16(a), a);
+    // res = masked & (~zeroMask)
+    int16x4_t res = vbic_s16(masked, zeroMask);
+
+    return vreinterpret_m64_s16(res);
+}
+
+// Negate packed 32-bit integers in a when the corresponding signed 32-bit
+// integer in b is negative, and store the results in dst. Element in dst are
+// zeroed out when the corresponding element in b is zero.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sign_pi32
+FORCE_INLINE __m64 _mm_sign_pi32(__m64 _a, __m64 _b)
+{
+    int32x2_t a = vreinterpret_s32_m64(_a);
+    int32x2_t b = vreinterpret_s32_m64(_b);
+
+    // signed shift right: faster than vclt
+    // (b < 0) ? 0xFFFFFFFF : 0
+    uint32x2_t ltMask = vreinterpret_u32_s32(vshr_n_s32(b, 31));
+
+    // (b == 0) ? 0xFFFFFFFF : 0
+#if defined(__aarch64__) || defined(_M_ARM64)
+    int32x2_t zeroMask = vreinterpret_s32_u32(vceqz_s32(b));
+#else
+    int32x2_t zeroMask = vreinterpret_s32_u32(vceq_s32(b, vdup_n_s32(0)));
+#endif
+
+    // bitwise select either a or negative 'a' (vneg_s32(a) return negative 'a')
+    // based on ltMask
+    int32x2_t masked = vbsl_s32(ltMask, vneg_s32(a), a);
+    // res = masked & (~zeroMask)
+    int32x2_t res = vbic_s32(masked, zeroMask);
+
+    return vreinterpret_m64_s32(res);
+}
+
+// Negate packed 8-bit integers in a when the corresponding signed 8-bit integer
+// in b is negative, and store the results in dst. Element in dst are zeroed out
+// when the corresponding element in b is zero.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_sign_pi8
+FORCE_INLINE __m64 _mm_sign_pi8(__m64 _a, __m64 _b)
+{
+    int8x8_t a = vreinterpret_s8_m64(_a);
+    int8x8_t b = vreinterpret_s8_m64(_b);
+
+    // signed shift right: faster than vclt
+    // (b < 0) ? 0xFF : 0
+    uint8x8_t ltMask = vreinterpret_u8_s8(vshr_n_s8(b, 7));
+
+    // (b == 0) ? 0xFF : 0
+#if defined(__aarch64__) || defined(_M_ARM64)
+    int8x8_t zeroMask = vreinterpret_s8_u8(vceqz_s8(b));
+#else
+    int8x8_t zeroMask = vreinterpret_s8_u8(vceq_s8(b, vdup_n_s8(0)));
+#endif
+
+    // bitwise select either a or negative 'a' (vneg_s8(a) return negative 'a')
+    // based on ltMask
+    int8x8_t masked = vbsl_s8(ltMask, vneg_s8(a), a);
+    // res = masked & (~zeroMask)
+    int8x8_t res = vbic_s8(masked, zeroMask);
+
+    return vreinterpret_m64_s8(res);
+}
+
+/* SSE4.1 */
+
+// Blend packed 16-bit integers from a and b using control mask imm8, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_blend_epi16
+// FORCE_INLINE __m128i _mm_blend_epi16(__m128i a, __m128i b,
+//                                      __constrange(0,255) int imm)
+#define _mm_blend_epi16(a, b, imm)                                      \
+    _sse2neon_define2(                                                  \
+        __m128i, a, b,                                                  \
+        const uint16_t _mask[8] =                                       \
+            _sse2neon_init(((imm) & (1 << 0)) ? (uint16_t) -1 : 0x0,    \
+                           ((imm) & (1 << 1)) ? (uint16_t) -1 : 0x0,    \
+                           ((imm) & (1 << 2)) ? (uint16_t) -1 : 0x0,    \
+                           ((imm) & (1 << 3)) ? (uint16_t) -1 : 0x0,    \
+                           ((imm) & (1 << 4)) ? (uint16_t) -1 : 0x0,    \
+                           ((imm) & (1 << 5)) ? (uint16_t) -1 : 0x0,    \
+                           ((imm) & (1 << 6)) ? (uint16_t) -1 : 0x0,    \
+                           ((imm) & (1 << 7)) ? (uint16_t) -1 : 0x0);   \
+        uint16x8_t _mask_vec = vld1q_u16(_mask);                        \
+        uint16x8_t __a = vreinterpretq_u16_m128i(_a);                   \
+        uint16x8_t __b = vreinterpretq_u16_m128i(_b); _sse2neon_return( \
+            vreinterpretq_m128i_u16(vbslq_u16(_mask_vec, __b, __a)));)
+
+// Blend packed double-precision (64-bit) floating-point elements from a and b
+// using control mask imm8, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_blend_pd
+#define _mm_blend_pd(a, b, imm)                                              \
+    _sse2neon_define2(                                                       \
+        __m128d, a, b,                                                       \
+        const uint64_t _mask[2] =                                            \
+            _sse2neon_init(((imm) & (1 << 0)) ? ~UINT64_C(0) : UINT64_C(0),  \
+                           ((imm) & (1 << 1)) ? ~UINT64_C(0) : UINT64_C(0)); \
+        uint64x2_t _mask_vec = vld1q_u64(_mask);                             \
+        uint64x2_t __a = vreinterpretq_u64_m128d(_a);                        \
+        uint64x2_t __b = vreinterpretq_u64_m128d(_b); _sse2neon_return(      \
+            vreinterpretq_m128d_u64(vbslq_u64(_mask_vec, __b, __a)));)
+
+// Blend packed single-precision (32-bit) floating-point elements from a and b
+// using mask, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_blend_ps
+FORCE_INLINE __m128 _mm_blend_ps(__m128 _a, __m128 _b, const char imm8)
+{
+    const uint32_t ALIGN_STRUCT(16)
+        data[4] = {((imm8) & (1 << 0)) ? UINT32_MAX : 0,
+                   ((imm8) & (1 << 1)) ? UINT32_MAX : 0,
+                   ((imm8) & (1 << 2)) ? UINT32_MAX : 0,
+                   ((imm8) & (1 << 3)) ? UINT32_MAX : 0};
+    uint32x4_t mask = vld1q_u32(data);
+    float32x4_t a = vreinterpretq_f32_m128(_a);
+    float32x4_t b = vreinterpretq_f32_m128(_b);
+    return vreinterpretq_m128_f32(vbslq_f32(mask, b, a));
+}
+
+// Blend packed 8-bit integers from a and b using mask, and store the results in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_blendv_epi8
+FORCE_INLINE __m128i _mm_blendv_epi8(__m128i _a, __m128i _b, __m128i _mask)
+{
+    // Use a signed shift right to create a mask with the sign bit
+    uint8x16_t mask =
+        vreinterpretq_u8_s8(vshrq_n_s8(vreinterpretq_s8_m128i(_mask), 7));
+    uint8x16_t a = vreinterpretq_u8_m128i(_a);
+    uint8x16_t b = vreinterpretq_u8_m128i(_b);
+    return vreinterpretq_m128i_u8(vbslq_u8(mask, b, a));
+}
+
+// Blend packed double-precision (64-bit) floating-point elements from a and b
+// using mask, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_blendv_pd
+FORCE_INLINE __m128d _mm_blendv_pd(__m128d _a, __m128d _b, __m128d _mask)
+{
+    uint64x2_t mask =
+        vreinterpretq_u64_s64(vshrq_n_s64(vreinterpretq_s64_m128d(_mask), 63));
+#if defined(__aarch64__) || defined(_M_ARM64)
+    float64x2_t a = vreinterpretq_f64_m128d(_a);
+    float64x2_t b = vreinterpretq_f64_m128d(_b);
+    return vreinterpretq_m128d_f64(vbslq_f64(mask, b, a));
+#else
+    uint64x2_t a = vreinterpretq_u64_m128d(_a);
+    uint64x2_t b = vreinterpretq_u64_m128d(_b);
+    return vreinterpretq_m128d_u64(vbslq_u64(mask, b, a));
+#endif
+}
+
+// Blend packed single-precision (32-bit) floating-point elements from a and b
+// using mask, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_blendv_ps
+FORCE_INLINE __m128 _mm_blendv_ps(__m128 _a, __m128 _b, __m128 _mask)
+{
+    // Use a signed shift right to create a mask with the sign bit
+    uint32x4_t mask =
+        vreinterpretq_u32_s32(vshrq_n_s32(vreinterpretq_s32_m128(_mask), 31));
+    float32x4_t a = vreinterpretq_f32_m128(_a);
+    float32x4_t b = vreinterpretq_f32_m128(_b);
+    return vreinterpretq_m128_f32(vbslq_f32(mask, b, a));
+}
+
+// Round the packed double-precision (64-bit) floating-point elements in a up
+// to an integer value, and store the results as packed double-precision
+// floating-point elements in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_ceil_pd
+FORCE_INLINE __m128d _mm_ceil_pd(__m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(vrndpq_f64(vreinterpretq_f64_m128d(a)));
+#else
+    double a0, a1;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    a1 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    return _mm_set_pd(ceil(a1), ceil(a0));
+#endif
+}
+
+// Round the packed single-precision (32-bit) floating-point elements in a up to
+// an integer value, and store the results as packed single-precision
+// floating-point elements in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_ceil_ps
+FORCE_INLINE __m128 _mm_ceil_ps(__m128 a)
+{
+#if (defined(__aarch64__) || defined(_M_ARM64)) || \
+    defined(__ARM_FEATURE_DIRECTED_ROUNDING)
+    return vreinterpretq_m128_f32(vrndpq_f32(vreinterpretq_f32_m128(a)));
+#else
+    float *f = (float *) &a;
+    return _mm_set_ps(ceilf(f[3]), ceilf(f[2]), ceilf(f[1]), ceilf(f[0]));
+#endif
+}
+
+// Round the lower double-precision (64-bit) floating-point element in b up to
+// an integer value, store the result as a double-precision floating-point
+// element in the lower element of dst, and copy the upper element from a to the
+// upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_ceil_sd
+FORCE_INLINE __m128d _mm_ceil_sd(__m128d a, __m128d b)
+{
+    return _mm_move_sd(a, _mm_ceil_pd(b));
+}
+
+// Round the lower single-precision (32-bit) floating-point element in b up to
+// an integer value, store the result as a single-precision floating-point
+// element in the lower element of dst, and copy the upper 3 packed elements
+// from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_ceil_ss
+FORCE_INLINE __m128 _mm_ceil_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_ceil_ps(b));
+}
+
+// Compare packed 64-bit integers in a and b for equality, and store the results
+// in dst
+FORCE_INLINE __m128i _mm_cmpeq_epi64(__m128i a, __m128i b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_u64(
+        vceqq_u64(vreinterpretq_u64_m128i(a), vreinterpretq_u64_m128i(b)));
+#else
+    // ARMv7 lacks vceqq_u64
+    // (a == b) -> (a_lo == b_lo) && (a_hi == b_hi)
+    uint32x4_t cmp =
+        vceqq_u32(vreinterpretq_u32_m128i(a), vreinterpretq_u32_m128i(b));
+    uint32x4_t swapped = vrev64q_u32(cmp);
+    return vreinterpretq_m128i_u32(vandq_u32(cmp, swapped));
+#endif
+}
+
+// Sign extend packed 16-bit integers in a to packed 32-bit integers, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepi16_epi32
+FORCE_INLINE __m128i _mm_cvtepi16_epi32(__m128i a)
+{
+    return vreinterpretq_m128i_s32(
+        vmovl_s16(vget_low_s16(vreinterpretq_s16_m128i(a))));
+}
+
+// Sign extend packed 16-bit integers in a to packed 64-bit integers, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepi16_epi64
+FORCE_INLINE __m128i _mm_cvtepi16_epi64(__m128i a)
+{
+    int16x8_t s16x8 = vreinterpretq_s16_m128i(a);     /* xxxx xxxx xxxx 0B0A */
+    int32x4_t s32x4 = vmovl_s16(vget_low_s16(s16x8)); /* 000x 000x 000B 000A */
+    int64x2_t s64x2 = vmovl_s32(vget_low_s32(s32x4)); /* 0000 000B 0000 000A */
+    return vreinterpretq_m128i_s64(s64x2);
+}
+
+// Sign extend packed 32-bit integers in a to packed 64-bit integers, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepi32_epi64
+FORCE_INLINE __m128i _mm_cvtepi32_epi64(__m128i a)
+{
+    return vreinterpretq_m128i_s64(
+        vmovl_s32(vget_low_s32(vreinterpretq_s32_m128i(a))));
+}
+
+// Sign extend packed 8-bit integers in a to packed 16-bit integers, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepi8_epi16
+FORCE_INLINE __m128i _mm_cvtepi8_epi16(__m128i a)
+{
+    int8x16_t s8x16 = vreinterpretq_s8_m128i(a);    /* xxxx xxxx xxxx DCBA */
+    int16x8_t s16x8 = vmovl_s8(vget_low_s8(s8x16)); /* 0x0x 0x0x 0D0C 0B0A */
+    return vreinterpretq_m128i_s16(s16x8);
+}
+
+// Sign extend packed 8-bit integers in a to packed 32-bit integers, and store
+// the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepi8_epi32
+FORCE_INLINE __m128i _mm_cvtepi8_epi32(__m128i a)
+{
+    int8x16_t s8x16 = vreinterpretq_s8_m128i(a);      /* xxxx xxxx xxxx DCBA */
+    int16x8_t s16x8 = vmovl_s8(vget_low_s8(s8x16));   /* 0x0x 0x0x 0D0C 0B0A */
+    int32x4_t s32x4 = vmovl_s16(vget_low_s16(s16x8)); /* 000D 000C 000B 000A */
+    return vreinterpretq_m128i_s32(s32x4);
+}
+
+// Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit
+// integers, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepi8_epi64
+FORCE_INLINE __m128i _mm_cvtepi8_epi64(__m128i a)
+{
+    int8x16_t s8x16 = vreinterpretq_s8_m128i(a);      /* xxxx xxxx xxxx xxBA */
+    int16x8_t s16x8 = vmovl_s8(vget_low_s8(s8x16));   /* 0x0x 0x0x 0x0x 0B0A */
+    int32x4_t s32x4 = vmovl_s16(vget_low_s16(s16x8)); /* 000x 000x 000B 000A */
+    int64x2_t s64x2 = vmovl_s32(vget_low_s32(s32x4)); /* 0000 000B 0000 000A */
+    return vreinterpretq_m128i_s64(s64x2);
+}
+
+// Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers,
+// and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepu16_epi32
+FORCE_INLINE __m128i _mm_cvtepu16_epi32(__m128i a)
+{
+    return vreinterpretq_m128i_u32(
+        vmovl_u16(vget_low_u16(vreinterpretq_u16_m128i(a))));
+}
+
+// Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers,
+// and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepu16_epi64
+FORCE_INLINE __m128i _mm_cvtepu16_epi64(__m128i a)
+{
+    uint16x8_t u16x8 = vreinterpretq_u16_m128i(a);     /* xxxx xxxx xxxx 0B0A */
+    uint32x4_t u32x4 = vmovl_u16(vget_low_u16(u16x8)); /* 000x 000x 000B 000A */
+    uint64x2_t u64x2 = vmovl_u32(vget_low_u32(u32x4)); /* 0000 000B 0000 000A */
+    return vreinterpretq_m128i_u64(u64x2);
+}
+
+// Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers,
+// and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepu32_epi64
+FORCE_INLINE __m128i _mm_cvtepu32_epi64(__m128i a)
+{
+    return vreinterpretq_m128i_u64(
+        vmovl_u32(vget_low_u32(vreinterpretq_u32_m128i(a))));
+}
+
+// Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers,
+// and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepu8_epi16
+FORCE_INLINE __m128i _mm_cvtepu8_epi16(__m128i a)
+{
+    uint8x16_t u8x16 = vreinterpretq_u8_m128i(a);    /* xxxx xxxx HGFE DCBA */
+    uint16x8_t u16x8 = vmovl_u8(vget_low_u8(u8x16)); /* 0H0G 0F0E 0D0C 0B0A */
+    return vreinterpretq_m128i_u16(u16x8);
+}
+
+// Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers,
+// and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepu8_epi32
+FORCE_INLINE __m128i _mm_cvtepu8_epi32(__m128i a)
+{
+    uint8x16_t u8x16 = vreinterpretq_u8_m128i(a);      /* xxxx xxxx xxxx DCBA */
+    uint16x8_t u16x8 = vmovl_u8(vget_low_u8(u8x16));   /* 0x0x 0x0x 0D0C 0B0A */
+    uint32x4_t u32x4 = vmovl_u16(vget_low_u16(u16x8)); /* 000D 000C 000B 000A */
+    return vreinterpretq_m128i_u32(u32x4);
+}
+
+// Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed
+// 64-bit integers, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cvtepu8_epi64
+FORCE_INLINE __m128i _mm_cvtepu8_epi64(__m128i a)
+{
+    uint8x16_t u8x16 = vreinterpretq_u8_m128i(a);      /* xxxx xxxx xxxx xxBA */
+    uint16x8_t u16x8 = vmovl_u8(vget_low_u8(u8x16));   /* 0x0x 0x0x 0x0x 0B0A */
+    uint32x4_t u32x4 = vmovl_u16(vget_low_u16(u16x8)); /* 000x 000x 000B 000A */
+    uint64x2_t u64x2 = vmovl_u32(vget_low_u32(u32x4)); /* 0000 000B 0000 000A */
+    return vreinterpretq_m128i_u64(u64x2);
+}
+
+// Conditionally multiply the packed double-precision (64-bit) floating-point
+// elements in a and b using the high 4 bits in imm8, sum the four products, and
+// conditionally store the sum in dst using the low 4 bits of imm8.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_dp_pd
+FORCE_INLINE __m128d _mm_dp_pd(__m128d a, __m128d b, const int imm)
+{
+    // Generate mask value from constant immediate bit value
+    const int64_t bit0Mask = imm & 0x01 ? UINT64_MAX : 0;
+    const int64_t bit1Mask = imm & 0x02 ? UINT64_MAX : 0;
+#if !SSE2NEON_PRECISE_DP
+    const int64_t bit4Mask = imm & 0x10 ? UINT64_MAX : 0;
+    const int64_t bit5Mask = imm & 0x20 ? UINT64_MAX : 0;
+#endif
+    // Conditional multiplication
+#if !SSE2NEON_PRECISE_DP
+    __m128d mul = _mm_mul_pd(a, b);
+    const __m128d mulMask =
+        _mm_castsi128_pd(_mm_set_epi64x(bit5Mask, bit4Mask));
+    __m128d tmp = _mm_and_pd(mul, mulMask);
+#else
+#if defined(__aarch64__) || defined(_M_ARM64)
+    double d0 = (imm & 0x10) ? vgetq_lane_f64(vreinterpretq_f64_m128d(a), 0) *
+                                   vgetq_lane_f64(vreinterpretq_f64_m128d(b), 0)
+                             : 0;
+    double d1 = (imm & 0x20) ? vgetq_lane_f64(vreinterpretq_f64_m128d(a), 1) *
+                                   vgetq_lane_f64(vreinterpretq_f64_m128d(b), 1)
+                             : 0;
+#else
+    double a0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    double a1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    double b0 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 0));
+    double b1 =
+        sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(b), 1));
+    double d0 = (imm & 0x10) ? a0 * b0 : 0;
+    double d1 = (imm & 0x20) ? a1 * b1 : 0;
+#endif
+    __m128d tmp = _mm_set_pd(d1, d0);
+#endif
+    // Sum the products
+#if defined(__aarch64__) || defined(_M_ARM64)
+    double sum = vpaddd_f64(vreinterpretq_f64_m128d(tmp));
+#else
+    double _tmp0 = sse2neon_recast_u64_f64(
+        vgetq_lane_u64(vreinterpretq_u64_m128d(tmp), 0));
+    double _tmp1 = sse2neon_recast_u64_f64(
+        vgetq_lane_u64(vreinterpretq_u64_m128d(tmp), 1));
+    double sum = _tmp0 + _tmp1;
+#endif
+    // Conditionally store the sum
+    const __m128d sumMask =
+        _mm_castsi128_pd(_mm_set_epi64x(bit1Mask, bit0Mask));
+    __m128d res = _mm_and_pd(_mm_set_pd1(sum), sumMask);
+    return res;
+}
+
+// Conditionally multiply the packed single-precision (32-bit) floating-point
+// elements in a and b using the high 4 bits in imm8, sum the four products,
+// and conditionally store the sum in dst using the low 4 bits of imm.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_dp_ps
+FORCE_INLINE __m128 _mm_dp_ps(__m128 a, __m128 b, const int imm)
+{
+    float32x4_t elementwise_prod = _mm_mul_ps(a, b);
+
+#if defined(__aarch64__) || defined(_M_ARM64)
+    /* shortcuts */
+    if (imm == 0xFF) {
+        return _mm_set1_ps(vaddvq_f32(elementwise_prod));
+    }
+
+    if ((imm & 0x0F) == 0x0F) {
+        if (!(imm & (1 << 4)))
+            elementwise_prod = vsetq_lane_f32(0.0f, elementwise_prod, 0);
+        if (!(imm & (1 << 5)))
+            elementwise_prod = vsetq_lane_f32(0.0f, elementwise_prod, 1);
+        if (!(imm & (1 << 6)))
+            elementwise_prod = vsetq_lane_f32(0.0f, elementwise_prod, 2);
+        if (!(imm & (1 << 7)))
+            elementwise_prod = vsetq_lane_f32(0.0f, elementwise_prod, 3);
+
+        return _mm_set1_ps(vaddvq_f32(elementwise_prod));
+    }
+#endif
+
+    float s = 0.0f;
+
+    if (imm & (1 << 4))
+        s += vgetq_lane_f32(elementwise_prod, 0);
+    if (imm & (1 << 5))
+        s += vgetq_lane_f32(elementwise_prod, 1);
+    if (imm & (1 << 6))
+        s += vgetq_lane_f32(elementwise_prod, 2);
+    if (imm & (1 << 7))
+        s += vgetq_lane_f32(elementwise_prod, 3);
+
+    const float32_t res[4] = {
+        (imm & 0x1) ? s : 0.0f,
+        (imm & 0x2) ? s : 0.0f,
+        (imm & 0x4) ? s : 0.0f,
+        (imm & 0x8) ? s : 0.0f,
+    };
+    return vreinterpretq_m128_f32(vld1q_f32(res));
+}
+
+// Extract a 32-bit integer from a, selected with imm8, and store the result in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_extract_epi32
+// FORCE_INLINE int _mm_extract_epi32(__m128i a, __constrange(0,4) int imm)
+#define _mm_extract_epi32(a, imm) \
+    vgetq_lane_s32(vreinterpretq_s32_m128i(a), (imm))
+
+// Extract a 64-bit integer from a, selected with imm8, and store the result in
+// dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_extract_epi64
+// FORCE_INLINE __int64 _mm_extract_epi64(__m128i a, __constrange(0,2) int imm)
+#define _mm_extract_epi64(a, imm) \
+    vgetq_lane_s64(vreinterpretq_s64_m128i(a), (imm))
+
+// Extract an 8-bit integer from a, selected with imm8, and store the result in
+// the lower element of dst. FORCE_INLINE int _mm_extract_epi8(__m128i a,
+// __constrange(0,16) int imm)
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_extract_epi8
+#define _mm_extract_epi8(a, imm) vgetq_lane_u8(vreinterpretq_u8_m128i(a), (imm))
+
+// Extracts the selected single-precision (32-bit) floating-point from a.
+// FORCE_INLINE int _mm_extract_ps(__m128 a, __constrange(0,4) int imm)
+#define _mm_extract_ps(a, imm) vgetq_lane_s32(vreinterpretq_s32_m128(a), (imm))
+
+// Round the packed double-precision (64-bit) floating-point elements in a down
+// to an integer value, and store the results as packed double-precision
+// floating-point elements in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_floor_pd
+FORCE_INLINE __m128d _mm_floor_pd(__m128d a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128d_f64(vrndmq_f64(vreinterpretq_f64_m128d(a)));
+#else
+    double a0, a1;
+    a0 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 0));
+    a1 = sse2neon_recast_u64_f64(vgetq_lane_u64(vreinterpretq_u64_m128d(a), 1));
+    return _mm_set_pd(floor(a1), floor(a0));
+#endif
+}
+
+// Round the packed single-precision (32-bit) floating-point elements in a down
+// to an integer value, and store the results as packed single-precision
+// floating-point elements in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_floor_ps
+FORCE_INLINE __m128 _mm_floor_ps(__m128 a)
+{
+#if (defined(__aarch64__) || defined(_M_ARM64)) || \
+    defined(__ARM_FEATURE_DIRECTED_ROUNDING)
+    return vreinterpretq_m128_f32(vrndmq_f32(vreinterpretq_f32_m128(a)));
+#else
+    float *f = (float *) &a;
+    return _mm_set_ps(floorf(f[3]), floorf(f[2]), floorf(f[1]), floorf(f[0]));
+#endif
+}
+
+// Round the lower double-precision (64-bit) floating-point element in b down to
+// an integer value, store the result as a double-precision floating-point
+// element in the lower element of dst, and copy the upper element from a to the
+// upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_floor_sd
+FORCE_INLINE __m128d _mm_floor_sd(__m128d a, __m128d b)
+{
+    return _mm_move_sd(a, _mm_floor_pd(b));
+}
+
+// Round the lower single-precision (32-bit) floating-point element in b down to
+// an integer value, store the result as a single-precision floating-point
+// element in the lower element of dst, and copy the upper 3 packed elements
+// from a to the upper elements of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_floor_ss
+FORCE_INLINE __m128 _mm_floor_ss(__m128 a, __m128 b)
+{
+    return _mm_move_ss(a, _mm_floor_ps(b));
+}
+
+// Copy a to dst, and insert the 32-bit integer i into dst at the location
+// specified by imm8.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_insert_epi32
+// FORCE_INLINE __m128i _mm_insert_epi32(__m128i a, int b,
+//                                       __constrange(0,4) int imm)
+#define _mm_insert_epi32(a, b, imm) \
+    vreinterpretq_m128i_s32(        \
+        vsetq_lane_s32((b), vreinterpretq_s32_m128i(a), (imm)))
+
+// Copy a to dst, and insert the 64-bit integer i into dst at the location
+// specified by imm8.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_insert_epi64
+// FORCE_INLINE __m128i _mm_insert_epi64(__m128i a, __int64 b,
+//                                       __constrange(0,2) int imm)
+#define _mm_insert_epi64(a, b, imm) \
+    vreinterpretq_m128i_s64(        \
+        vsetq_lane_s64((b), vreinterpretq_s64_m128i(a), (imm)))
+
+// Copy a to dst, and insert the lower 8-bit integer from i into dst at the
+// location specified by imm8.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_insert_epi8
+// FORCE_INLINE __m128i _mm_insert_epi8(__m128i a, int b,
+//                                      __constrange(0,16) int imm)
+#define _mm_insert_epi8(a, b, imm) \
+    vreinterpretq_m128i_s8(vsetq_lane_s8((b), vreinterpretq_s8_m128i(a), (imm)))
+
+// Copy a to tmp, then insert a single-precision (32-bit) floating-point
+// element from b into tmp using the control in imm8. Store tmp to dst using
+// the mask in imm8 (elements are zeroed out when the corresponding bit is set).
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=insert_ps
+#define _mm_insert_ps(a, b, imm8)                                            \
+    _sse2neon_define2(                                                       \
+        __m128, a, b,                                                        \
+        float32x4_t tmp1 =                                                   \
+            vsetq_lane_f32(vgetq_lane_f32(_b, (imm8 >> 6) & 0x3),            \
+                           vreinterpretq_f32_m128(_a), 0);                   \
+        float32x4_t tmp2 =                                                   \
+            vsetq_lane_f32(vgetq_lane_f32(tmp1, 0),                          \
+                           vreinterpretq_f32_m128(_a), ((imm8 >> 4) & 0x3)); \
+        const uint32_t data[4] =                                             \
+            _sse2neon_init(((imm8) & (1 << 0)) ? UINT32_MAX : 0,             \
+                           ((imm8) & (1 << 1)) ? UINT32_MAX : 0,             \
+                           ((imm8) & (1 << 2)) ? UINT32_MAX : 0,             \
+                           ((imm8) & (1 << 3)) ? UINT32_MAX : 0);            \
+        uint32x4_t mask = vld1q_u32(data);                                   \
+        float32x4_t all_zeros = vdupq_n_f32(0);                              \
+                                                                             \
+        _sse2neon_return(vreinterpretq_m128_f32(                             \
+            vbslq_f32(mask, all_zeros, vreinterpretq_f32_m128(tmp2))));)
+
+// Compare packed signed 32-bit integers in a and b, and store packed maximum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_epi32
+FORCE_INLINE __m128i _mm_max_epi32(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s32(
+        vmaxq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+}
+
+// Compare packed signed 8-bit integers in a and b, and store packed maximum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_epi8
+FORCE_INLINE __m128i _mm_max_epi8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s8(
+        vmaxq_s8(vreinterpretq_s8_m128i(a), vreinterpretq_s8_m128i(b)));
+}
+
+// Compare packed unsigned 16-bit integers in a and b, and store packed maximum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_epu16
+FORCE_INLINE __m128i _mm_max_epu16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u16(
+        vmaxq_u16(vreinterpretq_u16_m128i(a), vreinterpretq_u16_m128i(b)));
+}
+
+// Compare packed unsigned 32-bit integers in a and b, and store packed maximum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_epu32
+FORCE_INLINE __m128i _mm_max_epu32(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u32(
+        vmaxq_u32(vreinterpretq_u32_m128i(a), vreinterpretq_u32_m128i(b)));
+}
+
+// Compare packed signed 32-bit integers in a and b, and store packed minimum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_min_epi32
+FORCE_INLINE __m128i _mm_min_epi32(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s32(
+        vminq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+}
+
+// Compare packed signed 8-bit integers in a and b, and store packed minimum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_min_epi8
+FORCE_INLINE __m128i _mm_min_epi8(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s8(
+        vminq_s8(vreinterpretq_s8_m128i(a), vreinterpretq_s8_m128i(b)));
+}
+
+// Compare packed unsigned 16-bit integers in a and b, and store packed minimum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_min_epu16
+FORCE_INLINE __m128i _mm_min_epu16(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u16(
+        vminq_u16(vreinterpretq_u16_m128i(a), vreinterpretq_u16_m128i(b)));
+}
+
+// Compare packed unsigned 32-bit integers in a and b, and store packed minimum
+// values in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_max_epu32
+FORCE_INLINE __m128i _mm_min_epu32(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u32(
+        vminq_u32(vreinterpretq_u32_m128i(a), vreinterpretq_u32_m128i(b)));
+}
+
+// Horizontally compute the minimum amongst the packed unsigned 16-bit integers
+// in a, store the minimum and index in dst, and zero the remaining bits in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_minpos_epu16
+FORCE_INLINE __m128i _mm_minpos_epu16(__m128i a)
+{
+    __m128i dst;
+    uint16_t min, idx = 0;
+#if defined(__aarch64__) || defined(_M_ARM64)
+    // Find the minimum value
+    min = vminvq_u16(vreinterpretq_u16_m128i(a));
+
+    // Get the index of the minimum value
+    static const uint16_t idxv[] = {0, 1, 2, 3, 4, 5, 6, 7};
+    uint16x8_t minv = vdupq_n_u16(min);
+    uint16x8_t cmeq = vceqq_u16(minv, vreinterpretq_u16_m128i(a));
+    idx = vminvq_u16(vornq_u16(vld1q_u16(idxv), cmeq));
+#else
+    // Find the minimum value
+    __m64 tmp;
+    tmp = vreinterpret_m64_u16(
+        vmin_u16(vget_low_u16(vreinterpretq_u16_m128i(a)),
+                 vget_high_u16(vreinterpretq_u16_m128i(a))));
+    tmp = vreinterpret_m64_u16(
+        vpmin_u16(vreinterpret_u16_m64(tmp), vreinterpret_u16_m64(tmp)));
+    tmp = vreinterpret_m64_u16(
+        vpmin_u16(vreinterpret_u16_m64(tmp), vreinterpret_u16_m64(tmp)));
+    min = vget_lane_u16(vreinterpret_u16_m64(tmp), 0);
+    // Get the index of the minimum value
+    int i;
+    for (i = 0; i < 8; i++) {
+        if (min == vgetq_lane_u16(vreinterpretq_u16_m128i(a), 0)) {
+            idx = (uint16_t) i;
+            break;
+        }
+        a = _mm_srli_si128(a, 2);
+    }
+#endif
+    // Generate result
+    dst = _mm_setzero_si128();
+    dst = vreinterpretq_m128i_u16(
+        vsetq_lane_u16(min, vreinterpretq_u16_m128i(dst), 0));
+    dst = vreinterpretq_m128i_u16(
+        vsetq_lane_u16(idx, vreinterpretq_u16_m128i(dst), 1));
+    return dst;
+}
+
+// Compute the sum of absolute differences (SADs) of quadruplets of unsigned
+// 8-bit integers in a compared to those in b, and store the 16-bit results in
+// dst. Eight SADs are performed using one quadruplet from b and eight
+// quadruplets from a. One quadruplet is selected from b starting at on the
+// offset specified in imm8. Eight quadruplets are formed from sequential 8-bit
+// integers selected from a starting at the offset specified in imm8.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mpsadbw_epu8
+FORCE_INLINE __m128i _mm_mpsadbw_epu8(__m128i a, __m128i b, const int imm)
+{
+    uint8x16_t _a, _b;
+
+    switch (imm & 0x4) {
+    case 0:
+        // do nothing
+        _a = vreinterpretq_u8_m128i(a);
+        break;
+    case 4:
+        _a = vreinterpretq_u8_u32(vextq_u32(vreinterpretq_u32_m128i(a),
+                                            vreinterpretq_u32_m128i(a), 1));
+        break;
+    default:
+#if defined(__GNUC__) || defined(__clang__)
+        __builtin_unreachable();
+#elif defined(_MSC_VER)
+        __assume(0);
+#endif
+        break;
+    }
+
+    switch (imm & 0x3) {
+    case 0:
+        _b = vreinterpretq_u8_u32(
+            vdupq_n_u32(vgetq_lane_u32(vreinterpretq_u32_m128i(b), 0)));
+        break;
+    case 1:
+        _b = vreinterpretq_u8_u32(
+            vdupq_n_u32(vgetq_lane_u32(vreinterpretq_u32_m128i(b), 1)));
+        break;
+    case 2:
+        _b = vreinterpretq_u8_u32(
+            vdupq_n_u32(vgetq_lane_u32(vreinterpretq_u32_m128i(b), 2)));
+        break;
+    case 3:
+        _b = vreinterpretq_u8_u32(
+            vdupq_n_u32(vgetq_lane_u32(vreinterpretq_u32_m128i(b), 3)));
+        break;
+    default:
+#if defined(__GNUC__) || defined(__clang__)
+        __builtin_unreachable();
+#elif defined(_MSC_VER)
+        __assume(0);
+#endif
+        break;
+    }
+
+    int16x8_t c04, c15, c26, c37;
+    uint8x8_t low_b = vget_low_u8(_b);
+    c04 = vreinterpretq_s16_u16(vabdl_u8(vget_low_u8(_a), low_b));
+    uint8x16_t _a_1 = vextq_u8(_a, _a, 1);
+    c15 = vreinterpretq_s16_u16(vabdl_u8(vget_low_u8(_a_1), low_b));
+    uint8x16_t _a_2 = vextq_u8(_a, _a, 2);
+    c26 = vreinterpretq_s16_u16(vabdl_u8(vget_low_u8(_a_2), low_b));
+    uint8x16_t _a_3 = vextq_u8(_a, _a, 3);
+    c37 = vreinterpretq_s16_u16(vabdl_u8(vget_low_u8(_a_3), low_b));
+#if defined(__aarch64__) || defined(_M_ARM64)
+    // |0|4|2|6|
+    c04 = vpaddq_s16(c04, c26);
+    // |1|5|3|7|
+    c15 = vpaddq_s16(c15, c37);
+
+    int32x4_t trn1_c =
+        vtrn1q_s32(vreinterpretq_s32_s16(c04), vreinterpretq_s32_s16(c15));
+    int32x4_t trn2_c =
+        vtrn2q_s32(vreinterpretq_s32_s16(c04), vreinterpretq_s32_s16(c15));
+    return vreinterpretq_m128i_s16(vpaddq_s16(vreinterpretq_s16_s32(trn1_c),
+                                              vreinterpretq_s16_s32(trn2_c)));
+#else
+    int16x4_t c01, c23, c45, c67;
+    c01 = vpadd_s16(vget_low_s16(c04), vget_low_s16(c15));
+    c23 = vpadd_s16(vget_low_s16(c26), vget_low_s16(c37));
+    c45 = vpadd_s16(vget_high_s16(c04), vget_high_s16(c15));
+    c67 = vpadd_s16(vget_high_s16(c26), vget_high_s16(c37));
+
+    return vreinterpretq_m128i_s16(
+        vcombine_s16(vpadd_s16(c01, c23), vpadd_s16(c45, c67)));
+#endif
+}
+
+// Multiply the low signed 32-bit integers from each packed 64-bit element in
+// a and b, and store the signed 64-bit results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mul_epi32
+FORCE_INLINE __m128i _mm_mul_epi32(__m128i a, __m128i b)
+{
+    // vmull_s32 upcasts instead of masking, so we downcast.
+    int32x2_t a_lo = vmovn_s64(vreinterpretq_s64_m128i(a));
+    int32x2_t b_lo = vmovn_s64(vreinterpretq_s64_m128i(b));
+    return vreinterpretq_m128i_s64(vmull_s32(a_lo, b_lo));
+}
+
+// Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit
+// integers, and store the low 32 bits of the intermediate integers in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mullo_epi32
+FORCE_INLINE __m128i _mm_mullo_epi32(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_s32(
+        vmulq_s32(vreinterpretq_s32_m128i(a), vreinterpretq_s32_m128i(b)));
+}
+
+// Convert packed signed 32-bit integers from a and b to packed 16-bit integers
+// using unsigned saturation, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_packus_epi32
+FORCE_INLINE __m128i _mm_packus_epi32(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u16(
+        vcombine_u16(vqmovun_s32(vreinterpretq_s32_m128i(a)),
+                     vqmovun_s32(vreinterpretq_s32_m128i(b))));
+}
+
+// Round the packed double-precision (64-bit) floating-point elements in a using
+// the rounding parameter, and store the results as packed double-precision
+// floating-point elements in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_round_pd
+FORCE_INLINE_OPTNONE __m128d _mm_round_pd(__m128d a, int rounding)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    switch (rounding) {
+    case (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC):
+        return vreinterpretq_m128d_f64(vrndnq_f64(vreinterpretq_f64_m128d(a)));
+    case (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC):
+        return _mm_floor_pd(a);
+    case (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC):
+        return _mm_ceil_pd(a);
+    case (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC):
+        return vreinterpretq_m128d_f64(vrndq_f64(vreinterpretq_f64_m128d(a)));
+    default:  //_MM_FROUND_CUR_DIRECTION
+        return vreinterpretq_m128d_f64(vrndiq_f64(vreinterpretq_f64_m128d(a)));
+    }
+#else
+    double *v_double = (double *) &a;
+
+    if (rounding == (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) ||
+        (rounding == _MM_FROUND_CUR_DIRECTION &&
+         _MM_GET_ROUNDING_MODE() == _MM_ROUND_NEAREST)) {
+        double res[2], tmp;
+        for (int i = 0; i < 2; i++) {
+            tmp = (v_double[i] < 0) ? -v_double[i] : v_double[i];
+            double roundDown = floor(tmp);  // Round down value
+            double roundUp = ceil(tmp);     // Round up value
+            double diffDown = tmp - roundDown;
+            double diffUp = roundUp - tmp;
+            if (diffDown < diffUp) {
+                /* If it's closer to the round down value, then use it */
+                res[i] = roundDown;
+            } else if (diffDown > diffUp) {
+                /* If it's closer to the round up value, then use it */
+                res[i] = roundUp;
+            } else {
+                /* If it's equidistant between round up and round down value,
+                 * pick the one which is an even number */
+                double half = roundDown / 2;
+                if (half != floor(half)) {
+                    /* If the round down value is odd, return the round up value
+                     */
+                    res[i] = roundUp;
+                } else {
+                    /* If the round up value is odd, return the round down value
+                     */
+                    res[i] = roundDown;
+                }
+            }
+            res[i] = (v_double[i] < 0) ? -res[i] : res[i];
+        }
+        return _mm_set_pd(res[1], res[0]);
+    } else if (rounding == (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC) ||
+               (rounding == _MM_FROUND_CUR_DIRECTION &&
+                _MM_GET_ROUNDING_MODE() == _MM_ROUND_DOWN)) {
+        return _mm_floor_pd(a);
+    } else if (rounding == (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC) ||
+               (rounding == _MM_FROUND_CUR_DIRECTION &&
+                _MM_GET_ROUNDING_MODE() == _MM_ROUND_UP)) {
+        return _mm_ceil_pd(a);
+    }
+    return _mm_set_pd(v_double[1] > 0 ? floor(v_double[1]) : ceil(v_double[1]),
+                      v_double[0] > 0 ? floor(v_double[0]) : ceil(v_double[0]));
+#endif
+}
+
+// Round the packed single-precision (32-bit) floating-point elements in a using
+// the rounding parameter, and store the results as packed single-precision
+// floating-point elements in dst.
+// software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_round_ps
+FORCE_INLINE_OPTNONE __m128 _mm_round_ps(__m128 a, int rounding)
+{
+#if (defined(__aarch64__) || defined(_M_ARM64)) || \
+    defined(__ARM_FEATURE_DIRECTED_ROUNDING)
+    switch (rounding) {
+    case (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC):
+        return vreinterpretq_m128_f32(vrndnq_f32(vreinterpretq_f32_m128(a)));
+    case (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC):
+        return _mm_floor_ps(a);
+    case (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC):
+        return _mm_ceil_ps(a);
+    case (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC):
+        return vreinterpretq_m128_f32(vrndq_f32(vreinterpretq_f32_m128(a)));
+    default:  //_MM_FROUND_CUR_DIRECTION
+        return vreinterpretq_m128_f32(vrndiq_f32(vreinterpretq_f32_m128(a)));
+    }
+#else
+    float *v_float = (float *) &a;
+
+    if (rounding == (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) ||
+        (rounding == _MM_FROUND_CUR_DIRECTION &&
+         _MM_GET_ROUNDING_MODE() == _MM_ROUND_NEAREST)) {
+        uint32x4_t signmask = vdupq_n_u32(0x80000000);
+        float32x4_t half = vbslq_f32(signmask, vreinterpretq_f32_m128(a),
+                                     vdupq_n_f32(0.5f)); /* +/- 0.5 */
+        int32x4_t r_normal = vcvtq_s32_f32(vaddq_f32(
+            vreinterpretq_f32_m128(a), half)); /* round to integer: [a + 0.5]*/
+        int32x4_t r_trunc = vcvtq_s32_f32(
+            vreinterpretq_f32_m128(a)); /* truncate to integer: [a] */
+        int32x4_t plusone = vreinterpretq_s32_u32(vshrq_n_u32(
+            vreinterpretq_u32_s32(vnegq_s32(r_trunc)), 31)); /* 1 or 0 */
+        int32x4_t r_even = vbicq_s32(vaddq_s32(r_trunc, plusone),
+                                     vdupq_n_s32(1)); /* ([a] + {0,1}) & ~1 */
+        float32x4_t delta = vsubq_f32(
+            vreinterpretq_f32_m128(a),
+            vcvtq_f32_s32(r_trunc)); /* compute delta: delta = (a - [a]) */
+        uint32x4_t is_delta_half =
+            vceqq_f32(delta, half); /* delta == +/- 0.5 */
+        return vreinterpretq_m128_f32(
+            vcvtq_f32_s32(vbslq_s32(is_delta_half, r_even, r_normal)));
+    } else if (rounding == (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC) ||
+               (rounding == _MM_FROUND_CUR_DIRECTION &&
+                _MM_GET_ROUNDING_MODE() == _MM_ROUND_DOWN)) {
+        return _mm_floor_ps(a);
+    } else if (rounding == (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC) ||
+               (rounding == _MM_FROUND_CUR_DIRECTION &&
+                _MM_GET_ROUNDING_MODE() == _MM_ROUND_UP)) {
+        return _mm_ceil_ps(a);
+    }
+    return _mm_set_ps(v_float[3] > 0 ? floorf(v_float[3]) : ceilf(v_float[3]),
+                      v_float[2] > 0 ? floorf(v_float[2]) : ceilf(v_float[2]),
+                      v_float[1] > 0 ? floorf(v_float[1]) : ceilf(v_float[1]),
+                      v_float[0] > 0 ? floorf(v_float[0]) : ceilf(v_float[0]));
+#endif
+}
+
+// Round the lower double-precision (64-bit) floating-point element in b using
+// the rounding parameter, store the result as a double-precision floating-point
+// element in the lower element of dst, and copy the upper element from a to the
+// upper element of dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_round_sd
+FORCE_INLINE __m128d _mm_round_sd(__m128d a, __m128d b, int rounding)
+{
+    return _mm_move_sd(a, _mm_round_pd(b, rounding));
+}
+
+// Round the lower single-precision (32-bit) floating-point element in b using
+// the rounding parameter, store the result as a single-precision floating-point
+// element in the lower element of dst, and copy the upper 3 packed elements
+// from a to the upper elements of dst. Rounding is done according to the
+// rounding[3:0] parameter, which can be one of:
+//     (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and
+//     suppress exceptions
+//     (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and
+//     suppress exceptions
+//     (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress
+//     exceptions
+//     (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress
+//     exceptions _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see
+//     _MM_SET_ROUNDING_MODE
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_round_ss
+FORCE_INLINE __m128 _mm_round_ss(__m128 a, __m128 b, int rounding)
+{
+    return _mm_move_ss(a, _mm_round_ps(b, rounding));
+}
+
+// Load 128-bits of integer data from memory into dst using a non-temporal
+// memory hint. mem_addr must be aligned on a 16-byte boundary or a
+// general-protection exception may be generated.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_stream_load_si128
+FORCE_INLINE __m128i _mm_stream_load_si128(__m128i *p)
+{
+#if __has_builtin(__builtin_nontemporal_store)
+    return __builtin_nontemporal_load(p);
+#else
+    return vreinterpretq_m128i_s64(vld1q_s64((int64_t *) p));
+#endif
+}
+
+// Compute the bitwise NOT of a and then AND with a 128-bit vector containing
+// all 1's, and return 1 if the result is zero, otherwise return 0.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_test_all_ones
+FORCE_INLINE int _mm_test_all_ones(__m128i a)
+{
+    return (uint64_t) (vgetq_lane_s64(a, 0) & vgetq_lane_s64(a, 1)) ==
+           ~(uint64_t) 0;
+}
+
+// Compute the bitwise AND of 128 bits (representing integer data) in a and
+// mask, and return 1 if the result is zero, otherwise return 0.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_test_all_zeros
+FORCE_INLINE int _mm_test_all_zeros(__m128i a, __m128i mask)
+{
+    int64x2_t a_and_mask =
+        vandq_s64(vreinterpretq_s64_m128i(a), vreinterpretq_s64_m128i(mask));
+    return !(vgetq_lane_s64(a_and_mask, 0) | vgetq_lane_s64(a_and_mask, 1));
+}
+
+// Compute the bitwise AND of 128 bits (representing integer data) in a and
+// mask, and set ZF to 1 if the result is zero, otherwise set ZF to 0. Compute
+// the bitwise NOT of a and then AND with mask, and set CF to 1 if the result is
+// zero, otherwise set CF to 0. Return 1 if both the ZF and CF values are zero,
+// otherwise return 0.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=mm_test_mix_ones_zero
+// Note: Argument names may be wrong in the Intel intrinsics guide.
+FORCE_INLINE int _mm_test_mix_ones_zeros(__m128i a, __m128i mask)
+{
+    uint64x2_t v = vreinterpretq_u64_m128i(a);
+    uint64x2_t m = vreinterpretq_u64_m128i(mask);
+
+    // find ones (set-bits) and zeros (clear-bits) under clip mask
+    uint64x2_t ones = vandq_u64(m, v);
+    uint64x2_t zeros = vbicq_u64(m, v);
+
+    // If both 128-bit variables are populated (non-zero) then return 1.
+    // For comparison purposes, first compact each var down to 32-bits.
+    uint32x2_t reduced = vpmax_u32(vqmovn_u64(ones), vqmovn_u64(zeros));
+
+    // if folding minimum is non-zero then both vars must be non-zero
+    return (vget_lane_u32(vpmin_u32(reduced, reduced), 0) != 0);
+}
+
+// Compute the bitwise AND of 128 bits (representing integer data) in a and b,
+// and set ZF to 1 if the result is zero, otherwise set ZF to 0. Compute the
+// bitwise NOT of a and then AND with b, and set CF to 1 if the result is zero,
+// otherwise set CF to 0. Return the CF value.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_testc_si128
+FORCE_INLINE int _mm_testc_si128(__m128i a, __m128i b)
+{
+    int64x2_t s64 =
+        vbicq_s64(vreinterpretq_s64_m128i(b), vreinterpretq_s64_m128i(a));
+    return !(vgetq_lane_s64(s64, 0) | vgetq_lane_s64(s64, 1));
+}
+
+// Compute the bitwise AND of 128 bits (representing integer data) in a and b,
+// and set ZF to 1 if the result is zero, otherwise set ZF to 0. Compute the
+// bitwise NOT of a and then AND with b, and set CF to 1 if the result is zero,
+// otherwise set CF to 0. Return 1 if both the ZF and CF values are zero,
+// otherwise return 0.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_testnzc_si128
+#define _mm_testnzc_si128(a, b) _mm_test_mix_ones_zeros(a, b)
+
+// Compute the bitwise AND of 128 bits (representing integer data) in a and b,
+// and set ZF to 1 if the result is zero, otherwise set ZF to 0. Compute the
+// bitwise NOT of a and then AND with b, and set CF to 1 if the result is zero,
+// otherwise set CF to 0. Return the ZF value.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_testz_si128
+FORCE_INLINE int _mm_testz_si128(__m128i a, __m128i b)
+{
+    int64x2_t s64 =
+        vandq_s64(vreinterpretq_s64_m128i(a), vreinterpretq_s64_m128i(b));
+    return !(vgetq_lane_s64(s64, 0) | vgetq_lane_s64(s64, 1));
+}
+
+/* SSE4.2 */
+
+static const uint16_t ALIGN_STRUCT(16) _sse2neon_cmpestr_mask16b[8] = {
+    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
+};
+static const uint8_t ALIGN_STRUCT(16) _sse2neon_cmpestr_mask8b[16] = {
+    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
+    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
+};
+
+/* specify the source data format */
+#define _SIDD_UBYTE_OPS 0x00 /* unsigned 8-bit characters */
+#define _SIDD_UWORD_OPS 0x01 /* unsigned 16-bit characters */
+#define _SIDD_SBYTE_OPS 0x02 /* signed 8-bit characters */
+#define _SIDD_SWORD_OPS 0x03 /* signed 16-bit characters */
+
+/* specify the comparison operation */
+#define _SIDD_CMP_EQUAL_ANY 0x00     /* compare equal any: strchr */
+#define _SIDD_CMP_RANGES 0x04        /* compare ranges */
+#define _SIDD_CMP_EQUAL_EACH 0x08    /* compare equal each: strcmp */
+#define _SIDD_CMP_EQUAL_ORDERED 0x0C /* compare equal ordered */
+
+/* specify the polarity */
+#define _SIDD_POSITIVE_POLARITY 0x00
+#define _SIDD_MASKED_POSITIVE_POLARITY 0x20
+#define _SIDD_NEGATIVE_POLARITY 0x10 /* negate results */
+#define _SIDD_MASKED_NEGATIVE_POLARITY \
+    0x30 /* negate results only before end of string */
+
+/* specify the output selection in _mm_cmpXstri */
+#define _SIDD_LEAST_SIGNIFICANT 0x00
+#define _SIDD_MOST_SIGNIFICANT 0x40
+
+/* specify the output selection in _mm_cmpXstrm */
+#define _SIDD_BIT_MASK 0x00
+#define _SIDD_UNIT_MASK 0x40
+
+/* Pattern Matching for C macros.
+ * https://github.com/pfultz2/Cloak/wiki/C-Preprocessor-tricks,-tips,-and-idioms
+ */
+
+/* catenate */
+#define SSE2NEON_PRIMITIVE_CAT(a, ...) a##__VA_ARGS__
+#define SSE2NEON_CAT(a, b) SSE2NEON_PRIMITIVE_CAT(a, b)
+
+#define SSE2NEON_IIF(c) SSE2NEON_PRIMITIVE_CAT(SSE2NEON_IIF_, c)
+/* run the 2nd parameter */
+#define SSE2NEON_IIF_0(t, ...) __VA_ARGS__
+/* run the 1st parameter */
+#define SSE2NEON_IIF_1(t, ...) t
+
+#define SSE2NEON_COMPL(b) SSE2NEON_PRIMITIVE_CAT(SSE2NEON_COMPL_, b)
+#define SSE2NEON_COMPL_0 1
+#define SSE2NEON_COMPL_1 0
+
+#define SSE2NEON_DEC(x) SSE2NEON_PRIMITIVE_CAT(SSE2NEON_DEC_, x)
+#define SSE2NEON_DEC_1 0
+#define SSE2NEON_DEC_2 1
+#define SSE2NEON_DEC_3 2
+#define SSE2NEON_DEC_4 3
+#define SSE2NEON_DEC_5 4
+#define SSE2NEON_DEC_6 5
+#define SSE2NEON_DEC_7 6
+#define SSE2NEON_DEC_8 7
+#define SSE2NEON_DEC_9 8
+#define SSE2NEON_DEC_10 9
+#define SSE2NEON_DEC_11 10
+#define SSE2NEON_DEC_12 11
+#define SSE2NEON_DEC_13 12
+#define SSE2NEON_DEC_14 13
+#define SSE2NEON_DEC_15 14
+#define SSE2NEON_DEC_16 15
+
+/* detection */
+#define SSE2NEON_CHECK_N(x, n, ...) n
+#define SSE2NEON_CHECK(...) SSE2NEON_CHECK_N(__VA_ARGS__, 0, )
+#define SSE2NEON_PROBE(x) x, 1,
+
+#define SSE2NEON_NOT(x) SSE2NEON_CHECK(SSE2NEON_PRIMITIVE_CAT(SSE2NEON_NOT_, x))
+#define SSE2NEON_NOT_0 SSE2NEON_PROBE(~)
+
+#define SSE2NEON_BOOL(x) SSE2NEON_COMPL(SSE2NEON_NOT(x))
+#define SSE2NEON_IF(c) SSE2NEON_IIF(SSE2NEON_BOOL(c))
+
+#define SSE2NEON_EAT(...)
+#define SSE2NEON_EXPAND(...) __VA_ARGS__
+#define SSE2NEON_WHEN(c) SSE2NEON_IF(c)(SSE2NEON_EXPAND, SSE2NEON_EAT)
+
+/* recursion */
+/* deferred expression */
+#define SSE2NEON_EMPTY()
+#define SSE2NEON_DEFER(id) id SSE2NEON_EMPTY()
+#define SSE2NEON_OBSTRUCT(...) __VA_ARGS__ SSE2NEON_DEFER(SSE2NEON_EMPTY)()
+#define SSE2NEON_EXPAND(...) __VA_ARGS__
+
+#define SSE2NEON_EVAL(...) \
+    SSE2NEON_EVAL1(SSE2NEON_EVAL1(SSE2NEON_EVAL1(__VA_ARGS__)))
+#define SSE2NEON_EVAL1(...) \
+    SSE2NEON_EVAL2(SSE2NEON_EVAL2(SSE2NEON_EVAL2(__VA_ARGS__)))
+#define SSE2NEON_EVAL2(...) \
+    SSE2NEON_EVAL3(SSE2NEON_EVAL3(SSE2NEON_EVAL3(__VA_ARGS__)))
+#define SSE2NEON_EVAL3(...) __VA_ARGS__
+
+#define SSE2NEON_REPEAT(count, macro, ...)                         \
+    SSE2NEON_WHEN(count)                                           \
+    (SSE2NEON_OBSTRUCT(SSE2NEON_REPEAT_INDIRECT)()(                \
+        SSE2NEON_DEC(count), macro,                                \
+        __VA_ARGS__) SSE2NEON_OBSTRUCT(macro)(SSE2NEON_DEC(count), \
+                                              __VA_ARGS__))
+#define SSE2NEON_REPEAT_INDIRECT() SSE2NEON_REPEAT
+
+#define SSE2NEON_SIZE_OF_byte 8
+#define SSE2NEON_NUMBER_OF_LANES_byte 16
+#define SSE2NEON_SIZE_OF_word 16
+#define SSE2NEON_NUMBER_OF_LANES_word 8
+
+#define SSE2NEON_COMPARE_EQUAL_THEN_FILL_LANE(i, type)                         \
+    mtx[i] = vreinterpretq_m128i_##type(vceqq_##type(                          \
+        vdupq_n_##type(vgetq_lane_##type(vreinterpretq_##type##_m128i(b), i)), \
+        vreinterpretq_##type##_m128i(a)));
+
+#define SSE2NEON_FILL_LANE(i, type) \
+    vec_b[i] =                      \
+        vdupq_n_##type(vgetq_lane_##type(vreinterpretq_##type##_m128i(b), i));
+
+#define PCMPSTR_RANGES(a, b, mtx, data_type_prefix, type_prefix, size,        \
+                       number_of_lanes, byte_or_word)                         \
+    do {                                                                      \
+        SSE2NEON_CAT(                                                         \
+            data_type_prefix,                                                 \
+            SSE2NEON_CAT(size,                                                \
+                         SSE2NEON_CAT(x, SSE2NEON_CAT(number_of_lanes, _t)))) \
+        vec_b[number_of_lanes];                                               \
+        __m128i mask = SSE2NEON_IIF(byte_or_word)(                            \
+            vreinterpretq_m128i_u16(vdupq_n_u16(0xff)),                       \
+            vreinterpretq_m128i_u32(vdupq_n_u32(0xffff)));                    \
+        SSE2NEON_EVAL(SSE2NEON_REPEAT(number_of_lanes, SSE2NEON_FILL_LANE,    \
+                                      SSE2NEON_CAT(type_prefix, size)))       \
+        for (int i = 0; i < number_of_lanes; i++) {                           \
+            mtx[i] = SSE2NEON_CAT(vreinterpretq_m128i_u,                      \
+                                  size)(SSE2NEON_CAT(vbslq_u, size)(          \
+                SSE2NEON_CAT(vreinterpretq_u,                                 \
+                             SSE2NEON_CAT(size, _m128i))(mask),               \
+                SSE2NEON_CAT(vcgeq_, SSE2NEON_CAT(type_prefix, size))(        \
+                    vec_b[i],                                                 \
+                    SSE2NEON_CAT(                                             \
+                        vreinterpretq_,                                       \
+                        SSE2NEON_CAT(type_prefix,                             \
+                                     SSE2NEON_CAT(size, _m128i(a))))),        \
+                SSE2NEON_CAT(vcleq_, SSE2NEON_CAT(type_prefix, size))(        \
+                    vec_b[i],                                                 \
+                    SSE2NEON_CAT(                                             \
+                        vreinterpretq_,                                       \
+                        SSE2NEON_CAT(type_prefix,                             \
+                                     SSE2NEON_CAT(size, _m128i(a)))))));      \
+        }                                                                     \
+    } while (0)
+
+#define PCMPSTR_EQ(a, b, mtx, size, number_of_lanes)                         \
+    do {                                                                     \
+        SSE2NEON_EVAL(SSE2NEON_REPEAT(number_of_lanes,                       \
+                                      SSE2NEON_COMPARE_EQUAL_THEN_FILL_LANE, \
+                                      SSE2NEON_CAT(u, size)))                \
+    } while (0)
+
+#define SSE2NEON_CMP_EQUAL_ANY_IMPL(type)                                     \
+    static int _sse2neon_cmp_##type##_equal_any(__m128i a, int la, __m128i b, \
+                                                int lb)                       \
+    {                                                                         \
+        __m128i mtx[16];                                                      \
+        PCMPSTR_EQ(a, b, mtx, SSE2NEON_CAT(SSE2NEON_SIZE_OF_, type),          \
+                   SSE2NEON_CAT(SSE2NEON_NUMBER_OF_LANES_, type));            \
+        return SSE2NEON_CAT(                                                  \
+            _sse2neon_aggregate_equal_any_,                                   \
+            SSE2NEON_CAT(                                                     \
+                SSE2NEON_CAT(SSE2NEON_SIZE_OF_, type),                        \
+                SSE2NEON_CAT(x, SSE2NEON_CAT(SSE2NEON_NUMBER_OF_LANES_,       \
+                                             type))))(la, lb, mtx);           \
+    }
+
+#define SSE2NEON_CMP_RANGES_IMPL(type, data_type, us, byte_or_word)            \
+    static int _sse2neon_cmp_##us##type##_ranges(__m128i a, int la, __m128i b, \
+                                                 int lb)                       \
+    {                                                                          \
+        __m128i mtx[16];                                                       \
+        PCMPSTR_RANGES(                                                        \
+            a, b, mtx, data_type, us, SSE2NEON_CAT(SSE2NEON_SIZE_OF_, type),   \
+            SSE2NEON_CAT(SSE2NEON_NUMBER_OF_LANES_, type), byte_or_word);      \
+        return SSE2NEON_CAT(                                                   \
+            _sse2neon_aggregate_ranges_,                                       \
+            SSE2NEON_CAT(                                                      \
+                SSE2NEON_CAT(SSE2NEON_SIZE_OF_, type),                         \
+                SSE2NEON_CAT(x, SSE2NEON_CAT(SSE2NEON_NUMBER_OF_LANES_,        \
+                                             type))))(la, lb, mtx);            \
+    }
+
+#define SSE2NEON_CMP_EQUAL_ORDERED_IMPL(type)                                  \
+    static int _sse2neon_cmp_##type##_equal_ordered(__m128i a, int la,         \
+                                                    __m128i b, int lb)         \
+    {                                                                          \
+        __m128i mtx[16];                                                       \
+        PCMPSTR_EQ(a, b, mtx, SSE2NEON_CAT(SSE2NEON_SIZE_OF_, type),           \
+                   SSE2NEON_CAT(SSE2NEON_NUMBER_OF_LANES_, type));             \
+        return SSE2NEON_CAT(                                                   \
+            _sse2neon_aggregate_equal_ordered_,                                \
+            SSE2NEON_CAT(                                                      \
+                SSE2NEON_CAT(SSE2NEON_SIZE_OF_, type),                         \
+                SSE2NEON_CAT(x,                                                \
+                             SSE2NEON_CAT(SSE2NEON_NUMBER_OF_LANES_, type))))( \
+            SSE2NEON_CAT(SSE2NEON_NUMBER_OF_LANES_, type), la, lb, mtx);       \
+    }
+
+static int _sse2neon_aggregate_equal_any_8x16(int la, int lb, __m128i mtx[16])
+{
+    int res = 0;
+    int m = (1 << la) - 1;
+    uint8x8_t vec_mask = vld1_u8(_sse2neon_cmpestr_mask8b);
+    uint8x8_t t_lo = vtst_u8(vdup_n_u8(m & 0xff), vec_mask);
+    uint8x8_t t_hi = vtst_u8(vdup_n_u8(m >> 8), vec_mask);
+    uint8x16_t vec = vcombine_u8(t_lo, t_hi);
+    for (int j = 0; j < lb; j++) {
+        mtx[j] = vreinterpretq_m128i_u8(
+            vandq_u8(vec, vreinterpretq_u8_m128i(mtx[j])));
+        mtx[j] = vreinterpretq_m128i_u8(
+            vshrq_n_u8(vreinterpretq_u8_m128i(mtx[j]), 7));
+        int tmp = _sse2neon_vaddvq_u8(vreinterpretq_u8_m128i(mtx[j])) ? 1 : 0;
+        res |= (tmp << j);
+    }
+    return res;
+}
+
+static int _sse2neon_aggregate_equal_any_16x8(int la, int lb, __m128i mtx[16])
+{
+    int res = 0;
+    int m = (1 << la) - 1;
+    uint16x8_t vec =
+        vtstq_u16(vdupq_n_u16(m), vld1q_u16(_sse2neon_cmpestr_mask16b));
+    for (int j = 0; j < lb; j++) {
+        mtx[j] = vreinterpretq_m128i_u16(
+            vandq_u16(vec, vreinterpretq_u16_m128i(mtx[j])));
+        mtx[j] = vreinterpretq_m128i_u16(
+            vshrq_n_u16(vreinterpretq_u16_m128i(mtx[j]), 15));
+        int tmp = _sse2neon_vaddvq_u16(vreinterpretq_u16_m128i(mtx[j])) ? 1 : 0;
+        res |= (tmp << j);
+    }
+    return res;
+}
+
+/* clang-format off */
+#define SSE2NEON_GENERATE_CMP_EQUAL_ANY(prefix) \
+    prefix##IMPL(byte) \
+    prefix##IMPL(word)
+/* clang-format on */
+
+SSE2NEON_GENERATE_CMP_EQUAL_ANY(SSE2NEON_CMP_EQUAL_ANY_)
+
+static int _sse2neon_aggregate_ranges_16x8(int la, int lb, __m128i mtx[16])
+{
+    int res = 0;
+    int m = (1 << la) - 1;
+    uint16x8_t vec =
+        vtstq_u16(vdupq_n_u16(m), vld1q_u16(_sse2neon_cmpestr_mask16b));
+    for (int j = 0; j < lb; j++) {
+        mtx[j] = vreinterpretq_m128i_u16(
+            vandq_u16(vec, vreinterpretq_u16_m128i(mtx[j])));
+        mtx[j] = vreinterpretq_m128i_u16(
+            vshrq_n_u16(vreinterpretq_u16_m128i(mtx[j]), 15));
+        __m128i tmp = vreinterpretq_m128i_u32(
+            vshrq_n_u32(vreinterpretq_u32_m128i(mtx[j]), 16));
+        uint32x4_t vec_res = vandq_u32(vreinterpretq_u32_m128i(mtx[j]),
+                                       vreinterpretq_u32_m128i(tmp));
+#if defined(__aarch64__) || defined(_M_ARM64)
+        int t = vaddvq_u32(vec_res) ? 1 : 0;
+#else
+        uint64x2_t sumh = vpaddlq_u32(vec_res);
+        int t = vgetq_lane_u64(sumh, 0) + vgetq_lane_u64(sumh, 1);
+#endif
+        res |= (t << j);
+    }
+    return res;
+}
+
+static int _sse2neon_aggregate_ranges_8x16(int la, int lb, __m128i mtx[16])
+{
+    int res = 0;
+    int m = (1 << la) - 1;
+    uint8x8_t vec_mask = vld1_u8(_sse2neon_cmpestr_mask8b);
+    uint8x8_t t_lo = vtst_u8(vdup_n_u8(m & 0xff), vec_mask);
+    uint8x8_t t_hi = vtst_u8(vdup_n_u8(m >> 8), vec_mask);
+    uint8x16_t vec = vcombine_u8(t_lo, t_hi);
+    for (int j = 0; j < lb; j++) {
+        mtx[j] = vreinterpretq_m128i_u8(
+            vandq_u8(vec, vreinterpretq_u8_m128i(mtx[j])));
+        mtx[j] = vreinterpretq_m128i_u8(
+            vshrq_n_u8(vreinterpretq_u8_m128i(mtx[j]), 7));
+        __m128i tmp = vreinterpretq_m128i_u16(
+            vshrq_n_u16(vreinterpretq_u16_m128i(mtx[j]), 8));
+        uint16x8_t vec_res = vandq_u16(vreinterpretq_u16_m128i(mtx[j]),
+                                       vreinterpretq_u16_m128i(tmp));
+        int t = _sse2neon_vaddvq_u16(vec_res) ? 1 : 0;
+        res |= (t << j);
+    }
+    return res;
+}
+
+#define SSE2NEON_CMP_RANGES_IS_BYTE 1
+#define SSE2NEON_CMP_RANGES_IS_WORD 0
+
+/* clang-format off */
+#define SSE2NEON_GENERATE_CMP_RANGES(prefix)             \
+    prefix##IMPL(byte, uint, u, prefix##IS_BYTE)         \
+    prefix##IMPL(byte, int, s, prefix##IS_BYTE)          \
+    prefix##IMPL(word, uint, u, prefix##IS_WORD)         \
+    prefix##IMPL(word, int, s, prefix##IS_WORD)
+/* clang-format on */
+
+SSE2NEON_GENERATE_CMP_RANGES(SSE2NEON_CMP_RANGES_)
+
+#undef SSE2NEON_CMP_RANGES_IS_BYTE
+#undef SSE2NEON_CMP_RANGES_IS_WORD
+
+static int _sse2neon_cmp_byte_equal_each(__m128i a, int la, __m128i b, int lb)
+{
+    uint8x16_t mtx =
+        vceqq_u8(vreinterpretq_u8_m128i(a), vreinterpretq_u8_m128i(b));
+    int m0 = (la < lb) ? 0 : ((1 << la) - (1 << lb));
+    int m1 = 0x10000 - (1 << la);
+    int tb = 0x10000 - (1 << lb);
+    uint8x8_t vec_mask, vec0_lo, vec0_hi, vec1_lo, vec1_hi;
+    uint8x8_t tmp_lo, tmp_hi, res_lo, res_hi;
+    vec_mask = vld1_u8(_sse2neon_cmpestr_mask8b);
+    vec0_lo = vtst_u8(vdup_n_u8(m0), vec_mask);
+    vec0_hi = vtst_u8(vdup_n_u8(m0 >> 8), vec_mask);
+    vec1_lo = vtst_u8(vdup_n_u8(m1), vec_mask);
+    vec1_hi = vtst_u8(vdup_n_u8(m1 >> 8), vec_mask);
+    tmp_lo = vtst_u8(vdup_n_u8(tb), vec_mask);
+    tmp_hi = vtst_u8(vdup_n_u8(tb >> 8), vec_mask);
+
+    res_lo = vbsl_u8(vec0_lo, vdup_n_u8(0), vget_low_u8(mtx));
+    res_hi = vbsl_u8(vec0_hi, vdup_n_u8(0), vget_high_u8(mtx));
+    res_lo = vbsl_u8(vec1_lo, tmp_lo, res_lo);
+    res_hi = vbsl_u8(vec1_hi, tmp_hi, res_hi);
+    res_lo = vand_u8(res_lo, vec_mask);
+    res_hi = vand_u8(res_hi, vec_mask);
+
+    int res = _sse2neon_vaddv_u8(res_lo) + (_sse2neon_vaddv_u8(res_hi) << 8);
+    return res;
+}
+
+static int _sse2neon_cmp_word_equal_each(__m128i a, int la, __m128i b, int lb)
+{
+    uint16x8_t mtx =
+        vceqq_u16(vreinterpretq_u16_m128i(a), vreinterpretq_u16_m128i(b));
+    int m0 = (la < lb) ? 0 : ((1 << la) - (1 << lb));
+    int m1 = 0x100 - (1 << la);
+    int tb = 0x100 - (1 << lb);
+    uint16x8_t vec_mask = vld1q_u16(_sse2neon_cmpestr_mask16b);
+    uint16x8_t vec0 = vtstq_u16(vdupq_n_u16(m0), vec_mask);
+    uint16x8_t vec1 = vtstq_u16(vdupq_n_u16(m1), vec_mask);
+    uint16x8_t tmp = vtstq_u16(vdupq_n_u16(tb), vec_mask);
+    mtx = vbslq_u16(vec0, vdupq_n_u16(0), mtx);
+    mtx = vbslq_u16(vec1, tmp, mtx);
+    mtx = vandq_u16(mtx, vec_mask);
+    return _sse2neon_vaddvq_u16(mtx);
+}
+
+#define SSE2NEON_AGGREGATE_EQUAL_ORDER_IS_UBYTE 1
+#define SSE2NEON_AGGREGATE_EQUAL_ORDER_IS_UWORD 0
+
+#define SSE2NEON_AGGREGATE_EQUAL_ORDER_IMPL(size, number_of_lanes, data_type)  \
+    static int _sse2neon_aggregate_equal_ordered_##size##x##number_of_lanes(   \
+        int bound, int la, int lb, __m128i mtx[16])                            \
+    {                                                                          \
+        int res = 0;                                                           \
+        int m1 = SSE2NEON_IIF(data_type)(0x10000, 0x100) - (1 << la);          \
+        uint##size##x8_t vec_mask = SSE2NEON_IIF(data_type)(                   \
+            vld1_u##size(_sse2neon_cmpestr_mask##size##b),                     \
+            vld1q_u##size(_sse2neon_cmpestr_mask##size##b));                   \
+        uint##size##x##number_of_lanes##_t vec1 = SSE2NEON_IIF(data_type)(     \
+            vcombine_u##size(vtst_u##size(vdup_n_u##size(m1), vec_mask),       \
+                             vtst_u##size(vdup_n_u##size(m1 >> 8), vec_mask)), \
+            vtstq_u##size(vdupq_n_u##size(m1), vec_mask));                     \
+        uint##size##x##number_of_lanes##_t vec_minusone = vdupq_n_u##size(-1); \
+        uint##size##x##number_of_lanes##_t vec_zero = vdupq_n_u##size(0);      \
+        for (int j = 0; j < lb; j++) {                                         \
+            mtx[j] = vreinterpretq_m128i_u##size(vbslq_u##size(                \
+                vec1, vec_minusone, vreinterpretq_u##size##_m128i(mtx[j])));   \
+        }                                                                      \
+        for (int j = lb; j < bound; j++) {                                     \
+            mtx[j] = vreinterpretq_m128i_u##size(                              \
+                vbslq_u##size(vec1, vec_minusone, vec_zero));                  \
+        }                                                                      \
+        unsigned SSE2NEON_IIF(data_type)(char, short) *ptr =                   \
+            (unsigned SSE2NEON_IIF(data_type)(char, short) *) mtx;             \
+        for (int i = 0; i < bound; i++) {                                      \
+            int val = 1;                                                       \
+            for (int j = 0, k = i; j < bound - i && k < bound; j++, k++)       \
+                val &= ptr[k * bound + j];                                     \
+            res += val << i;                                                   \
+        }                                                                      \
+        return res;                                                            \
+    }
+
+/* clang-format off */
+#define SSE2NEON_GENERATE_AGGREGATE_EQUAL_ORDER(prefix) \
+    prefix##IMPL(8, 16, prefix##IS_UBYTE)               \
+    prefix##IMPL(16, 8, prefix##IS_UWORD)
+/* clang-format on */
+
+SSE2NEON_GENERATE_AGGREGATE_EQUAL_ORDER(SSE2NEON_AGGREGATE_EQUAL_ORDER_)
+
+#undef SSE2NEON_AGGREGATE_EQUAL_ORDER_IS_UBYTE
+#undef SSE2NEON_AGGREGATE_EQUAL_ORDER_IS_UWORD
+
+/* clang-format off */
+#define SSE2NEON_GENERATE_CMP_EQUAL_ORDERED(prefix) \
+    prefix##IMPL(byte)                              \
+    prefix##IMPL(word)
+/* clang-format on */
+
+SSE2NEON_GENERATE_CMP_EQUAL_ORDERED(SSE2NEON_CMP_EQUAL_ORDERED_)
+
+#define SSE2NEON_CMPESTR_LIST                          \
+    _(CMP_UBYTE_EQUAL_ANY, cmp_byte_equal_any)         \
+    _(CMP_UWORD_EQUAL_ANY, cmp_word_equal_any)         \
+    _(CMP_SBYTE_EQUAL_ANY, cmp_byte_equal_any)         \
+    _(CMP_SWORD_EQUAL_ANY, cmp_word_equal_any)         \
+    _(CMP_UBYTE_RANGES, cmp_ubyte_ranges)              \
+    _(CMP_UWORD_RANGES, cmp_uword_ranges)              \
+    _(CMP_SBYTE_RANGES, cmp_sbyte_ranges)              \
+    _(CMP_SWORD_RANGES, cmp_sword_ranges)              \
+    _(CMP_UBYTE_EQUAL_EACH, cmp_byte_equal_each)       \
+    _(CMP_UWORD_EQUAL_EACH, cmp_word_equal_each)       \
+    _(CMP_SBYTE_EQUAL_EACH, cmp_byte_equal_each)       \
+    _(CMP_SWORD_EQUAL_EACH, cmp_word_equal_each)       \
+    _(CMP_UBYTE_EQUAL_ORDERED, cmp_byte_equal_ordered) \
+    _(CMP_UWORD_EQUAL_ORDERED, cmp_word_equal_ordered) \
+    _(CMP_SBYTE_EQUAL_ORDERED, cmp_byte_equal_ordered) \
+    _(CMP_SWORD_EQUAL_ORDERED, cmp_word_equal_ordered)
+
+enum {
+#define _(name, func_suffix) name,
+    SSE2NEON_CMPESTR_LIST
+#undef _
+};
+typedef int (*cmpestr_func_t)(__m128i a, int la, __m128i b, int lb);
+static cmpestr_func_t _sse2neon_cmpfunc_table[] = {
+#define _(name, func_suffix) _sse2neon_##func_suffix,
+    SSE2NEON_CMPESTR_LIST
+#undef _
+};
+
+FORCE_INLINE int _sse2neon_sido_negative(int res, int lb, int imm8, int bound)
+{
+    switch (imm8 & 0x30) {
+    case _SIDD_NEGATIVE_POLARITY:
+        res ^= 0xffffffff;
+        break;
+    case _SIDD_MASKED_NEGATIVE_POLARITY:
+        res ^= (1 << lb) - 1;
+        break;
+    default:
+        break;
+    }
+
+    return res & ((bound == 8) ? 0xFF : 0xFFFF);
+}
+
+FORCE_INLINE int _sse2neon_clz(unsigned int x)
+{
+#if defined(_MSC_VER) && !defined(__clang__)
+    unsigned long cnt = 0;
+    if (_BitScanReverse(&cnt, x))
+        return 31 - cnt;
+    return 32;
+#else
+    return x != 0 ? __builtin_clz(x) : 32;
+#endif
+}
+
+FORCE_INLINE int _sse2neon_ctz(unsigned int x)
+{
+#if defined(_MSC_VER) && !defined(__clang__)
+    unsigned long cnt = 0;
+    if (_BitScanForward(&cnt, x))
+        return cnt;
+    return 32;
+#else
+    return x != 0 ? __builtin_ctz(x) : 32;
+#endif
+}
+
+FORCE_INLINE int _sse2neon_ctzll(unsigned long long x)
+{
+#ifdef _MSC_VER
+    unsigned long cnt;
+#if defined(SSE2NEON_HAS_BITSCAN64)
+    if (_BitScanForward64(&cnt, x))
+        return (int) (cnt);
+#else
+    if (_BitScanForward(&cnt, (unsigned long) (x)))
+        return (int) cnt;
+    if (_BitScanForward(&cnt, (unsigned long) (x >> 32)))
+        return (int) (cnt + 32);
+#endif /* SSE2NEON_HAS_BITSCAN64 */
+    return 64;
+#else /* assume GNU compatible compilers */
+    return x != 0 ? __builtin_ctzll(x) : 64;
+#endif
+}
+
+#define SSE2NEON_MIN(x, y) (x) < (y) ? (x) : (y)
+
+#define SSE2NEON_CMPSTR_SET_UPPER(var, imm) \
+    const int var = (imm & 0x01) ? 8 : 16
+
+#define SSE2NEON_CMPESTRX_LEN_PAIR(a, b, la, lb) \
+    int tmp1 = la ^ (la >> 31);                  \
+    la = tmp1 - (la >> 31);                      \
+    int tmp2 = lb ^ (lb >> 31);                  \
+    lb = tmp2 - (lb >> 31);                      \
+    la = SSE2NEON_MIN(la, bound);                \
+    lb = SSE2NEON_MIN(lb, bound)
+
+// Compare all pairs of character in string a and b,
+// then aggregate the result.
+// As the only difference of PCMPESTR* and PCMPISTR* is the way to calculate the
+// length of string, we use SSE2NEON_CMP{I,E}STRX_GET_LEN to get the length of
+// string a and b.
+#define SSE2NEON_COMP_AGG(a, b, la, lb, imm8, IE)                  \
+    SSE2NEON_CMPSTR_SET_UPPER(bound, imm8);                        \
+    SSE2NEON_##IE##_LEN_PAIR(a, b, la, lb);                        \
+    int r2 = (_sse2neon_cmpfunc_table[imm8 & 0x0f])(a, la, b, lb); \
+    r2 = _sse2neon_sido_negative(r2, lb, imm8, bound)
+
+#define SSE2NEON_CMPSTR_GENERATE_INDEX(r2, bound, imm8)          \
+    return (r2 == 0) ? bound                                     \
+                     : ((imm8 & 0x40) ? (31 - _sse2neon_clz(r2)) \
+                                      : _sse2neon_ctz(r2))
+
+#define SSE2NEON_CMPSTR_GENERATE_MASK(dst)                                     \
+    __m128i dst = vreinterpretq_m128i_u8(vdupq_n_u8(0));                       \
+    if (imm8 & 0x40) {                                                         \
+        if (bound == 8) {                                                      \
+            uint16x8_t tmp = vtstq_u16(vdupq_n_u16(r2),                        \
+                                       vld1q_u16(_sse2neon_cmpestr_mask16b));  \
+            dst = vreinterpretq_m128i_u16(vbslq_u16(                           \
+                tmp, vdupq_n_u16(-1), vreinterpretq_u16_m128i(dst)));          \
+        } else {                                                               \
+            uint8x16_t vec_r2 =                                                \
+                vcombine_u8(vdup_n_u8(r2), vdup_n_u8(r2 >> 8));                \
+            uint8x16_t tmp =                                                   \
+                vtstq_u8(vec_r2, vld1q_u8(_sse2neon_cmpestr_mask8b));          \
+            dst = vreinterpretq_m128i_u8(                                      \
+                vbslq_u8(tmp, vdupq_n_u8(-1), vreinterpretq_u8_m128i(dst)));   \
+        }                                                                      \
+    } else {                                                                   \
+        if (bound == 16) {                                                     \
+            dst = vreinterpretq_m128i_u16(                                     \
+                vsetq_lane_u16(r2 & 0xffff, vreinterpretq_u16_m128i(dst), 0)); \
+        } else {                                                               \
+            dst = vreinterpretq_m128i_u8(                                      \
+                vsetq_lane_u8(r2 & 0xff, vreinterpretq_u8_m128i(dst), 0));     \
+        }                                                                      \
+    }                                                                          \
+    return dst
+
+// Compare packed strings in a and b with lengths la and lb using the control
+// in imm8, and returns 1 if b did not contain a null character and the
+// resulting mask was zero, and 0 otherwise.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpestra
+FORCE_INLINE int _mm_cmpestra(__m128i a,
+                              int la,
+                              __m128i b,
+                              int lb,
+                              const int imm8)
+{
+    int lb_cpy = lb;
+    SSE2NEON_COMP_AGG(a, b, la, lb, imm8, CMPESTRX);
+    return !r2 & (lb_cpy > bound);
+}
+
+// Compare packed strings in a and b with lengths la and lb using the control in
+// imm8, and returns 1 if the resulting mask was non-zero, and 0 otherwise.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpestrc
+FORCE_INLINE int _mm_cmpestrc(__m128i a,
+                              int la,
+                              __m128i b,
+                              int lb,
+                              const int imm8)
+{
+    SSE2NEON_COMP_AGG(a, b, la, lb, imm8, CMPESTRX);
+    return r2 != 0;
+}
+
+// Compare packed strings in a and b with lengths la and lb using the control
+// in imm8, and store the generated index in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpestri
+FORCE_INLINE int _mm_cmpestri(__m128i a,
+                              int la,
+                              __m128i b,
+                              int lb,
+                              const int imm8)
+{
+    SSE2NEON_COMP_AGG(a, b, la, lb, imm8, CMPESTRX);
+    SSE2NEON_CMPSTR_GENERATE_INDEX(r2, bound, imm8);
+}
+
+// Compare packed strings in a and b with lengths la and lb using the control
+// in imm8, and store the generated mask in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpestrm
+FORCE_INLINE __m128i
+_mm_cmpestrm(__m128i a, int la, __m128i b, int lb, const int imm8)
+{
+    SSE2NEON_COMP_AGG(a, b, la, lb, imm8, CMPESTRX);
+    SSE2NEON_CMPSTR_GENERATE_MASK(dst);
+}
+
+// Compare packed strings in a and b with lengths la and lb using the control in
+// imm8, and returns bit 0 of the resulting bit mask.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpestro
+FORCE_INLINE int _mm_cmpestro(__m128i a,
+                              int la,
+                              __m128i b,
+                              int lb,
+                              const int imm8)
+{
+    SSE2NEON_COMP_AGG(a, b, la, lb, imm8, CMPESTRX);
+    return r2 & 1;
+}
+
+// Compare packed strings in a and b with lengths la and lb using the control in
+// imm8, and returns 1 if any character in a was null, and 0 otherwise.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpestrs
+FORCE_INLINE int _mm_cmpestrs(__m128i a,
+                              int la,
+                              __m128i b,
+                              int lb,
+                              const int imm8)
+{
+    (void) a;
+    (void) b;
+    (void) lb;
+    SSE2NEON_CMPSTR_SET_UPPER(bound, imm8);
+    return la <= (bound - 1);
+}
+
+// Compare packed strings in a and b with lengths la and lb using the control in
+// imm8, and returns 1 if any character in b was null, and 0 otherwise.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpestrz
+FORCE_INLINE int _mm_cmpestrz(__m128i a,
+                              int la,
+                              __m128i b,
+                              int lb,
+                              const int imm8)
+{
+    (void) a;
+    (void) b;
+    (void) la;
+    SSE2NEON_CMPSTR_SET_UPPER(bound, imm8);
+    return lb <= (bound - 1);
+}
+
+#define SSE2NEON_CMPISTRX_LENGTH(str, len, imm8)                         \
+    do {                                                                 \
+        if (imm8 & 0x01) {                                               \
+            uint16x8_t equal_mask_##str =                                \
+                vceqq_u16(vreinterpretq_u16_m128i(str), vdupq_n_u16(0)); \
+            uint8x8_t res_##str = vshrn_n_u16(equal_mask_##str, 4);      \
+            uint64_t matches_##str =                                     \
+                vget_lane_u64(vreinterpret_u64_u8(res_##str), 0);        \
+            len = _sse2neon_ctzll(matches_##str) >> 3;                   \
+        } else {                                                         \
+            uint16x8_t equal_mask_##str = vreinterpretq_u16_u8(          \
+                vceqq_u8(vreinterpretq_u8_m128i(str), vdupq_n_u8(0)));   \
+            uint8x8_t res_##str = vshrn_n_u16(equal_mask_##str, 4);      \
+            uint64_t matches_##str =                                     \
+                vget_lane_u64(vreinterpret_u64_u8(res_##str), 0);        \
+            len = _sse2neon_ctzll(matches_##str) >> 2;                   \
+        }                                                                \
+    } while (0)
+
+#define SSE2NEON_CMPISTRX_LEN_PAIR(a, b, la, lb) \
+    int la, lb;                                  \
+    do {                                         \
+        SSE2NEON_CMPISTRX_LENGTH(a, la, imm8);   \
+        SSE2NEON_CMPISTRX_LENGTH(b, lb, imm8);   \
+    } while (0)
+
+// Compare packed strings with implicit lengths in a and b using the control in
+// imm8, and returns 1 if b did not contain a null character and the resulting
+// mask was zero, and 0 otherwise.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpistra
+FORCE_INLINE int _mm_cmpistra(__m128i a, __m128i b, const int imm8)
+{
+    SSE2NEON_COMP_AGG(a, b, la, lb, imm8, CMPISTRX);
+    return !r2 & (lb >= bound);
+}
+
+// Compare packed strings with implicit lengths in a and b using the control in
+// imm8, and returns 1 if the resulting mask was non-zero, and 0 otherwise.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpistrc
+FORCE_INLINE int _mm_cmpistrc(__m128i a, __m128i b, const int imm8)
+{
+    SSE2NEON_COMP_AGG(a, b, la, lb, imm8, CMPISTRX);
+    return r2 != 0;
+}
+
+// Compare packed strings with implicit lengths in a and b using the control in
+// imm8, and store the generated index in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpistri
+FORCE_INLINE int _mm_cmpistri(__m128i a, __m128i b, const int imm8)
+{
+    SSE2NEON_COMP_AGG(a, b, la, lb, imm8, CMPISTRX);
+    SSE2NEON_CMPSTR_GENERATE_INDEX(r2, bound, imm8);
+}
+
+// Compare packed strings with implicit lengths in a and b using the control in
+// imm8, and store the generated mask in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpistrm
+FORCE_INLINE __m128i _mm_cmpistrm(__m128i a, __m128i b, const int imm8)
+{
+    SSE2NEON_COMP_AGG(a, b, la, lb, imm8, CMPISTRX);
+    SSE2NEON_CMPSTR_GENERATE_MASK(dst);
+}
+
+// Compare packed strings with implicit lengths in a and b using the control in
+// imm8, and returns bit 0 of the resulting bit mask.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpistro
+FORCE_INLINE int _mm_cmpistro(__m128i a, __m128i b, const int imm8)
+{
+    SSE2NEON_COMP_AGG(a, b, la, lb, imm8, CMPISTRX);
+    return r2 & 1;
+}
+
+// Compare packed strings with implicit lengths in a and b using the control in
+// imm8, and returns 1 if any character in a was null, and 0 otherwise.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpistrs
+FORCE_INLINE int _mm_cmpistrs(__m128i a, __m128i b, const int imm8)
+{
+    (void) b;
+    SSE2NEON_CMPSTR_SET_UPPER(bound, imm8);
+    int la;
+    SSE2NEON_CMPISTRX_LENGTH(a, la, imm8);
+    return la <= (bound - 1);
+}
+
+// Compare packed strings with implicit lengths in a and b using the control in
+// imm8, and returns 1 if any character in b was null, and 0 otherwise.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpistrz
+FORCE_INLINE int _mm_cmpistrz(__m128i a, __m128i b, const int imm8)
+{
+    (void) a;
+    SSE2NEON_CMPSTR_SET_UPPER(bound, imm8);
+    int lb;
+    SSE2NEON_CMPISTRX_LENGTH(b, lb, imm8);
+    return lb <= (bound - 1);
+}
+
+// Compares the 2 signed 64-bit integers in a and the 2 signed 64-bit integers
+// in b for greater than.
+FORCE_INLINE __m128i _mm_cmpgt_epi64(__m128i a, __m128i b)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    return vreinterpretq_m128i_u64(
+        vcgtq_s64(vreinterpretq_s64_m128i(a), vreinterpretq_s64_m128i(b)));
+#else
+    return vreinterpretq_m128i_s64(vshrq_n_s64(
+        vqsubq_s64(vreinterpretq_s64_m128i(b), vreinterpretq_s64_m128i(a)),
+        63));
+#endif
+}
+
+// Starting with the initial value in crc, accumulates a CRC32 value for
+// unsigned 16-bit integer v, and stores the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_crc32_u16
+FORCE_INLINE uint32_t _mm_crc32_u16(uint32_t crc, uint16_t v)
+{
+#if defined(__aarch64__) && defined(__ARM_FEATURE_CRC32)
+    __asm__ __volatile__("crc32ch %w[c], %w[c], %w[v]\n\t"
+                         : [c] "+r"(crc)
+                         : [v] "r"(v));
+#elif ((__ARM_ARCH == 8) && defined(__ARM_FEATURE_CRC32)) || \
+    (defined(_M_ARM64) && !defined(__clang__))
+    crc = __crc32ch(crc, v);
+#else
+    crc = _mm_crc32_u8(crc, v & 0xff);
+    crc = _mm_crc32_u8(crc, (v >> 8) & 0xff);
+#endif
+    return crc;
+}
+
+// Starting with the initial value in crc, accumulates a CRC32 value for
+// unsigned 32-bit integer v, and stores the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_crc32_u32
+FORCE_INLINE uint32_t _mm_crc32_u32(uint32_t crc, uint32_t v)
+{
+#if defined(__aarch64__) && defined(__ARM_FEATURE_CRC32)
+    __asm__ __volatile__("crc32cw %w[c], %w[c], %w[v]\n\t"
+                         : [c] "+r"(crc)
+                         : [v] "r"(v));
+#elif ((__ARM_ARCH == 8) && defined(__ARM_FEATURE_CRC32)) || \
+    (defined(_M_ARM64) && !defined(__clang__))
+    crc = __crc32cw(crc, v);
+#else
+    crc = _mm_crc32_u16(crc, v & 0xffff);
+    crc = _mm_crc32_u16(crc, (v >> 16) & 0xffff);
+#endif
+    return crc;
+}
+
+// Starting with the initial value in crc, accumulates a CRC32 value for
+// unsigned 64-bit integer v, and stores the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_crc32_u64
+FORCE_INLINE uint64_t _mm_crc32_u64(uint64_t crc, uint64_t v)
+{
+#if defined(__aarch64__) && defined(__ARM_FEATURE_CRC32)
+    __asm__ __volatile__("crc32cx %w[c], %w[c], %x[v]\n\t"
+                         : [c] "+r"(crc)
+                         : [v] "r"(v));
+#elif (defined(_M_ARM64) && !defined(__clang__))
+    crc = __crc32cd((uint32_t) crc, v);
+#else
+    crc = _mm_crc32_u32((uint32_t) (crc), v & 0xffffffff);
+    crc = _mm_crc32_u32((uint32_t) (crc), (v >> 32) & 0xffffffff);
+#endif
+    return crc;
+}
+
+// Starting with the initial value in crc, accumulates a CRC32 value for
+// unsigned 8-bit integer v, and stores the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_crc32_u8
+FORCE_INLINE uint32_t _mm_crc32_u8(uint32_t crc, uint8_t v)
+{
+#if defined(__aarch64__) && defined(__ARM_FEATURE_CRC32)
+    __asm__ __volatile__("crc32cb %w[c], %w[c], %w[v]\n\t"
+                         : [c] "+r"(crc)
+                         : [v] "r"(v));
+#elif ((__ARM_ARCH == 8) && defined(__ARM_FEATURE_CRC32)) || \
+    (defined(_M_ARM64) && !defined(__clang__))
+    crc = __crc32cb(crc, v);
+#else
+    crc ^= v;
+#if defined(__ARM_FEATURE_CRYPTO)
+    // Adapted from: https://mary.rs/lab/crc32/
+    // Barrent reduction
+    uint64x2_t orig =
+        vcombine_u64(vcreate_u64((uint64_t) (crc) << 24), vcreate_u64(0x0));
+    uint64x2_t tmp = orig;
+
+    // Polynomial P(x) of CRC32C
+    uint64_t p = 0x105EC76F1;
+    // Barrett Reduction (in bit-reflected form) constant mu_{64} = \lfloor
+    // 2^{64} / P(x) \rfloor = 0x11f91caf6
+    uint64_t mu = 0x1dea713f1;
+
+    // Multiply by mu_{64}
+    tmp = _sse2neon_vmull_p64(vget_low_u64(tmp), vcreate_u64(mu));
+    // Divide by 2^{64} (mask away the unnecessary bits)
+    tmp =
+        vandq_u64(tmp, vcombine_u64(vcreate_u64(0xFFFFFFFF), vcreate_u64(0x0)));
+    // Multiply by P(x) (shifted left by 1 for alignment reasons)
+    tmp = _sse2neon_vmull_p64(vget_low_u64(tmp), vcreate_u64(p));
+    // Subtract original from result
+    tmp = veorq_u64(tmp, orig);
+
+    // Extract the 'lower' (in bit-reflected sense) 32 bits
+    crc = vgetq_lane_u32(vreinterpretq_u32_u64(tmp), 1);
+#else  // Fall back to the generic table lookup approach
+    // Adapted from: https://create.stephan-brumme.com/crc32/
+    // Apply half-byte comparison algorithm for the best ratio between
+    // performance and lookup table.
+
+    // The lookup table just needs to store every 16th entry
+    // of the standard look-up table.
+    static const uint32_t crc32_half_byte_tbl[] = {
+        0x00000000, 0x105ec76f, 0x20bd8ede, 0x30e349b1, 0x417b1dbc, 0x5125dad3,
+        0x61c69362, 0x7198540d, 0x82f63b78, 0x92a8fc17, 0xa24bb5a6, 0xb21572c9,
+        0xc38d26c4, 0xd3d3e1ab, 0xe330a81a, 0xf36e6f75,
+    };
+
+    crc = (crc >> 4) ^ crc32_half_byte_tbl[crc & 0x0F];
+    crc = (crc >> 4) ^ crc32_half_byte_tbl[crc & 0x0F];
+#endif
+#endif
+    return crc;
+}
+
+/* AES */
+
+#if !defined(__ARM_FEATURE_CRYPTO) && (!defined(_M_ARM64) || defined(__clang__))
+/* clang-format off */
+#define SSE2NEON_AES_SBOX(w)                                           \
+    {                                                                  \
+        w(0x63), w(0x7c), w(0x77), w(0x7b), w(0xf2), w(0x6b), w(0x6f), \
+        w(0xc5), w(0x30), w(0x01), w(0x67), w(0x2b), w(0xfe), w(0xd7), \
+        w(0xab), w(0x76), w(0xca), w(0x82), w(0xc9), w(0x7d), w(0xfa), \
+        w(0x59), w(0x47), w(0xf0), w(0xad), w(0xd4), w(0xa2), w(0xaf), \
+        w(0x9c), w(0xa4), w(0x72), w(0xc0), w(0xb7), w(0xfd), w(0x93), \
+        w(0x26), w(0x36), w(0x3f), w(0xf7), w(0xcc), w(0x34), w(0xa5), \
+        w(0xe5), w(0xf1), w(0x71), w(0xd8), w(0x31), w(0x15), w(0x04), \
+        w(0xc7), w(0x23), w(0xc3), w(0x18), w(0x96), w(0x05), w(0x9a), \
+        w(0x07), w(0x12), w(0x80), w(0xe2), w(0xeb), w(0x27), w(0xb2), \
+        w(0x75), w(0x09), w(0x83), w(0x2c), w(0x1a), w(0x1b), w(0x6e), \
+        w(0x5a), w(0xa0), w(0x52), w(0x3b), w(0xd6), w(0xb3), w(0x29), \
+        w(0xe3), w(0x2f), w(0x84), w(0x53), w(0xd1), w(0x00), w(0xed), \
+        w(0x20), w(0xfc), w(0xb1), w(0x5b), w(0x6a), w(0xcb), w(0xbe), \
+        w(0x39), w(0x4a), w(0x4c), w(0x58), w(0xcf), w(0xd0), w(0xef), \
+        w(0xaa), w(0xfb), w(0x43), w(0x4d), w(0x33), w(0x85), w(0x45), \
+        w(0xf9), w(0x02), w(0x7f), w(0x50), w(0x3c), w(0x9f), w(0xa8), \
+        w(0x51), w(0xa3), w(0x40), w(0x8f), w(0x92), w(0x9d), w(0x38), \
+        w(0xf5), w(0xbc), w(0xb6), w(0xda), w(0x21), w(0x10), w(0xff), \
+        w(0xf3), w(0xd2), w(0xcd), w(0x0c), w(0x13), w(0xec), w(0x5f), \
+        w(0x97), w(0x44), w(0x17), w(0xc4), w(0xa7), w(0x7e), w(0x3d), \
+        w(0x64), w(0x5d), w(0x19), w(0x73), w(0x60), w(0x81), w(0x4f), \
+        w(0xdc), w(0x22), w(0x2a), w(0x90), w(0x88), w(0x46), w(0xee), \
+        w(0xb8), w(0x14), w(0xde), w(0x5e), w(0x0b), w(0xdb), w(0xe0), \
+        w(0x32), w(0x3a), w(0x0a), w(0x49), w(0x06), w(0x24), w(0x5c), \
+        w(0xc2), w(0xd3), w(0xac), w(0x62), w(0x91), w(0x95), w(0xe4), \
+        w(0x79), w(0xe7), w(0xc8), w(0x37), w(0x6d), w(0x8d), w(0xd5), \
+        w(0x4e), w(0xa9), w(0x6c), w(0x56), w(0xf4), w(0xea), w(0x65), \
+        w(0x7a), w(0xae), w(0x08), w(0xba), w(0x78), w(0x25), w(0x2e), \
+        w(0x1c), w(0xa6), w(0xb4), w(0xc6), w(0xe8), w(0xdd), w(0x74), \
+        w(0x1f), w(0x4b), w(0xbd), w(0x8b), w(0x8a), w(0x70), w(0x3e), \
+        w(0xb5), w(0x66), w(0x48), w(0x03), w(0xf6), w(0x0e), w(0x61), \
+        w(0x35), w(0x57), w(0xb9), w(0x86), w(0xc1), w(0x1d), w(0x9e), \
+        w(0xe1), w(0xf8), w(0x98), w(0x11), w(0x69), w(0xd9), w(0x8e), \
+        w(0x94), w(0x9b), w(0x1e), w(0x87), w(0xe9), w(0xce), w(0x55), \
+        w(0x28), w(0xdf), w(0x8c), w(0xa1), w(0x89), w(0x0d), w(0xbf), \
+        w(0xe6), w(0x42), w(0x68), w(0x41), w(0x99), w(0x2d), w(0x0f), \
+        w(0xb0), w(0x54), w(0xbb), w(0x16)                             \
+    }
+#define SSE2NEON_AES_RSBOX(w)                                          \
+    {                                                                  \
+        w(0x52), w(0x09), w(0x6a), w(0xd5), w(0x30), w(0x36), w(0xa5), \
+        w(0x38), w(0xbf), w(0x40), w(0xa3), w(0x9e), w(0x81), w(0xf3), \
+        w(0xd7), w(0xfb), w(0x7c), w(0xe3), w(0x39), w(0x82), w(0x9b), \
+        w(0x2f), w(0xff), w(0x87), w(0x34), w(0x8e), w(0x43), w(0x44), \
+        w(0xc4), w(0xde), w(0xe9), w(0xcb), w(0x54), w(0x7b), w(0x94), \
+        w(0x32), w(0xa6), w(0xc2), w(0x23), w(0x3d), w(0xee), w(0x4c), \
+        w(0x95), w(0x0b), w(0x42), w(0xfa), w(0xc3), w(0x4e), w(0x08), \
+        w(0x2e), w(0xa1), w(0x66), w(0x28), w(0xd9), w(0x24), w(0xb2), \
+        w(0x76), w(0x5b), w(0xa2), w(0x49), w(0x6d), w(0x8b), w(0xd1), \
+        w(0x25), w(0x72), w(0xf8), w(0xf6), w(0x64), w(0x86), w(0x68), \
+        w(0x98), w(0x16), w(0xd4), w(0xa4), w(0x5c), w(0xcc), w(0x5d), \
+        w(0x65), w(0xb6), w(0x92), w(0x6c), w(0x70), w(0x48), w(0x50), \
+        w(0xfd), w(0xed), w(0xb9), w(0xda), w(0x5e), w(0x15), w(0x46), \
+        w(0x57), w(0xa7), w(0x8d), w(0x9d), w(0x84), w(0x90), w(0xd8), \
+        w(0xab), w(0x00), w(0x8c), w(0xbc), w(0xd3), w(0x0a), w(0xf7), \
+        w(0xe4), w(0x58), w(0x05), w(0xb8), w(0xb3), w(0x45), w(0x06), \
+        w(0xd0), w(0x2c), w(0x1e), w(0x8f), w(0xca), w(0x3f), w(0x0f), \
+        w(0x02), w(0xc1), w(0xaf), w(0xbd), w(0x03), w(0x01), w(0x13), \
+        w(0x8a), w(0x6b), w(0x3a), w(0x91), w(0x11), w(0x41), w(0x4f), \
+        w(0x67), w(0xdc), w(0xea), w(0x97), w(0xf2), w(0xcf), w(0xce), \
+        w(0xf0), w(0xb4), w(0xe6), w(0x73), w(0x96), w(0xac), w(0x74), \
+        w(0x22), w(0xe7), w(0xad), w(0x35), w(0x85), w(0xe2), w(0xf9), \
+        w(0x37), w(0xe8), w(0x1c), w(0x75), w(0xdf), w(0x6e), w(0x47), \
+        w(0xf1), w(0x1a), w(0x71), w(0x1d), w(0x29), w(0xc5), w(0x89), \
+        w(0x6f), w(0xb7), w(0x62), w(0x0e), w(0xaa), w(0x18), w(0xbe), \
+        w(0x1b), w(0xfc), w(0x56), w(0x3e), w(0x4b), w(0xc6), w(0xd2), \
+        w(0x79), w(0x20), w(0x9a), w(0xdb), w(0xc0), w(0xfe), w(0x78), \
+        w(0xcd), w(0x5a), w(0xf4), w(0x1f), w(0xdd), w(0xa8), w(0x33), \
+        w(0x88), w(0x07), w(0xc7), w(0x31), w(0xb1), w(0x12), w(0x10), \
+        w(0x59), w(0x27), w(0x80), w(0xec), w(0x5f), w(0x60), w(0x51), \
+        w(0x7f), w(0xa9), w(0x19), w(0xb5), w(0x4a), w(0x0d), w(0x2d), \
+        w(0xe5), w(0x7a), w(0x9f), w(0x93), w(0xc9), w(0x9c), w(0xef), \
+        w(0xa0), w(0xe0), w(0x3b), w(0x4d), w(0xae), w(0x2a), w(0xf5), \
+        w(0xb0), w(0xc8), w(0xeb), w(0xbb), w(0x3c), w(0x83), w(0x53), \
+        w(0x99), w(0x61), w(0x17), w(0x2b), w(0x04), w(0x7e), w(0xba), \
+        w(0x77), w(0xd6), w(0x26), w(0xe1), w(0x69), w(0x14), w(0x63), \
+        w(0x55), w(0x21), w(0x0c), w(0x7d)                             \
+    }
+/* clang-format on */
+
+/* X Macro trick. See https://en.wikipedia.org/wiki/X_Macro */
+#define SSE2NEON_AES_H0(x) (x)
+static const uint8_t _sse2neon_sbox[256] = SSE2NEON_AES_SBOX(SSE2NEON_AES_H0);
+static const uint8_t _sse2neon_rsbox[256] = SSE2NEON_AES_RSBOX(SSE2NEON_AES_H0);
+#undef SSE2NEON_AES_H0
+
+/* x_time function and matrix multiply function */
+#if !defined(__aarch64__) && !defined(_M_ARM64)
+#define SSE2NEON_XT(x) (((x) << 1) ^ ((((x) >> 7) & 1) * 0x1b))
+#define SSE2NEON_MULTIPLY(x, y)                                  \
+    (((y & 1) * x) ^ ((y >> 1 & 1) * SSE2NEON_XT(x)) ^           \
+     ((y >> 2 & 1) * SSE2NEON_XT(SSE2NEON_XT(x))) ^              \
+     ((y >> 3 & 1) * SSE2NEON_XT(SSE2NEON_XT(SSE2NEON_XT(x)))) ^ \
+     ((y >> 4 & 1) * SSE2NEON_XT(SSE2NEON_XT(SSE2NEON_XT(SSE2NEON_XT(x))))))
+#endif
+
+// In the absence of crypto extensions, implement aesenc using regular NEON
+// intrinsics instead. See:
+// https://www.workofard.com/2017/01/accelerated-aes-for-the-arm64-linux-kernel/
+// https://www.workofard.com/2017/07/ghash-for-low-end-cores/ and
+// for more information.
+FORCE_INLINE __m128i _mm_aesenc_si128(__m128i a, __m128i RoundKey)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    static const uint8_t shift_rows[] = {
+        0x0, 0x5, 0xa, 0xf, 0x4, 0x9, 0xe, 0x3,
+        0x8, 0xd, 0x2, 0x7, 0xc, 0x1, 0x6, 0xb,
+    };
+    static const uint8_t ror32by8[] = {
+        0x1, 0x2, 0x3, 0x0, 0x5, 0x6, 0x7, 0x4,
+        0x9, 0xa, 0xb, 0x8, 0xd, 0xe, 0xf, 0xc,
+    };
+
+    uint8x16_t v;
+    uint8x16_t w = vreinterpretq_u8_m128i(a);
+
+    /* shift rows */
+    w = vqtbl1q_u8(w, vld1q_u8(shift_rows));
+
+    /* sub bytes */
+    // Here, we separate the whole 256-bytes table into 4 64-bytes tables, and
+    // look up each of the table. After each lookup, we load the next table
+    // which locates at the next 64-bytes. In the meantime, the index in the
+    // table would be smaller than it was, so the index parameters of
+    // `vqtbx4q_u8()` need to be added the same constant as the loaded tables.
+    v = vqtbl4q_u8(_sse2neon_vld1q_u8_x4(_sse2neon_sbox), w);
+    // 'w-0x40' equals to 'vsubq_u8(w, vdupq_n_u8(0x40))'
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_sbox + 0x40), w - 0x40);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_sbox + 0x80), w - 0x80);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_sbox + 0xc0), w - 0xc0);
+
+    /* mix columns */
+    w = (v << 1) ^ (uint8x16_t) (((int8x16_t) v >> 7) & 0x1b);
+    w ^= (uint8x16_t) vrev32q_u16((uint16x8_t) v);
+    w ^= vqtbl1q_u8(v ^ w, vld1q_u8(ror32by8));
+
+    /* add round key */
+    return vreinterpretq_m128i_u8(w) ^ RoundKey;
+
+#else /* ARMv7-A implementation for a table-based AES */
+#define SSE2NEON_AES_B2W(b0, b1, b2, b3)                 \
+    (((uint32_t) (b3) << 24) | ((uint32_t) (b2) << 16) | \
+     ((uint32_t) (b1) << 8) | (uint32_t) (b0))
+// multiplying 'x' by 2 in GF(2^8)
+#define SSE2NEON_AES_F2(x) ((x << 1) ^ (((x >> 7) & 1) * 0x011b /* WPOLY */))
+// multiplying 'x' by 3 in GF(2^8)
+#define SSE2NEON_AES_F3(x) (SSE2NEON_AES_F2(x) ^ x)
+#define SSE2NEON_AES_U0(p) \
+    SSE2NEON_AES_B2W(SSE2NEON_AES_F2(p), p, p, SSE2NEON_AES_F3(p))
+#define SSE2NEON_AES_U1(p) \
+    SSE2NEON_AES_B2W(SSE2NEON_AES_F3(p), SSE2NEON_AES_F2(p), p, p)
+#define SSE2NEON_AES_U2(p) \
+    SSE2NEON_AES_B2W(p, SSE2NEON_AES_F3(p), SSE2NEON_AES_F2(p), p)
+#define SSE2NEON_AES_U3(p) \
+    SSE2NEON_AES_B2W(p, p, SSE2NEON_AES_F3(p), SSE2NEON_AES_F2(p))
+
+    // this generates a table containing every possible permutation of
+    // shift_rows() and sub_bytes() with mix_columns().
+    static const uint32_t ALIGN_STRUCT(16) aes_table[4][256] = {
+        SSE2NEON_AES_SBOX(SSE2NEON_AES_U0),
+        SSE2NEON_AES_SBOX(SSE2NEON_AES_U1),
+        SSE2NEON_AES_SBOX(SSE2NEON_AES_U2),
+        SSE2NEON_AES_SBOX(SSE2NEON_AES_U3),
+    };
+#undef SSE2NEON_AES_B2W
+#undef SSE2NEON_AES_F2
+#undef SSE2NEON_AES_F3
+#undef SSE2NEON_AES_U0
+#undef SSE2NEON_AES_U1
+#undef SSE2NEON_AES_U2
+#undef SSE2NEON_AES_U3
+
+    uint32_t x0 = _mm_cvtsi128_si32(a);  // get a[31:0]
+    uint32_t x1 =
+        _mm_cvtsi128_si32(_mm_shuffle_epi32(a, 0x55));  // get a[63:32]
+    uint32_t x2 =
+        _mm_cvtsi128_si32(_mm_shuffle_epi32(a, 0xAA));  // get a[95:64]
+    uint32_t x3 =
+        _mm_cvtsi128_si32(_mm_shuffle_epi32(a, 0xFF));  // get a[127:96]
+
+    // finish the modulo addition step in mix_columns()
+    __m128i out = _mm_set_epi32(
+        (aes_table[0][x3 & 0xff] ^ aes_table[1][(x0 >> 8) & 0xff] ^
+         aes_table[2][(x1 >> 16) & 0xff] ^ aes_table[3][x2 >> 24]),
+        (aes_table[0][x2 & 0xff] ^ aes_table[1][(x3 >> 8) & 0xff] ^
+         aes_table[2][(x0 >> 16) & 0xff] ^ aes_table[3][x1 >> 24]),
+        (aes_table[0][x1 & 0xff] ^ aes_table[1][(x2 >> 8) & 0xff] ^
+         aes_table[2][(x3 >> 16) & 0xff] ^ aes_table[3][x0 >> 24]),
+        (aes_table[0][x0 & 0xff] ^ aes_table[1][(x1 >> 8) & 0xff] ^
+         aes_table[2][(x2 >> 16) & 0xff] ^ aes_table[3][x3 >> 24]));
+
+    return _mm_xor_si128(out, RoundKey);
+#endif
+}
+
+// Perform one round of an AES decryption flow on data (state) in a using the
+// round key in RoundKey, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_aesdec_si128
+FORCE_INLINE __m128i _mm_aesdec_si128(__m128i a, __m128i RoundKey)
+{
+#if defined(__aarch64__)
+    static const uint8_t inv_shift_rows[] = {
+        0x0, 0xd, 0xa, 0x7, 0x4, 0x1, 0xe, 0xb,
+        0x8, 0x5, 0x2, 0xf, 0xc, 0x9, 0x6, 0x3,
+    };
+    static const uint8_t ror32by8[] = {
+        0x1, 0x2, 0x3, 0x0, 0x5, 0x6, 0x7, 0x4,
+        0x9, 0xa, 0xb, 0x8, 0xd, 0xe, 0xf, 0xc,
+    };
+
+    uint8x16_t v;
+    uint8x16_t w = vreinterpretq_u8_m128i(a);
+
+    // inverse shift rows
+    w = vqtbl1q_u8(w, vld1q_u8(inv_shift_rows));
+
+    // inverse sub bytes
+    v = vqtbl4q_u8(_sse2neon_vld1q_u8_x4(_sse2neon_rsbox), w);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_rsbox + 0x40), w - 0x40);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_rsbox + 0x80), w - 0x80);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_rsbox + 0xc0), w - 0xc0);
+
+    // inverse mix columns
+    // multiplying 'v' by 4 in GF(2^8)
+    w = (v << 1) ^ (uint8x16_t) (((int8x16_t) v >> 7) & 0x1b);
+    w = (w << 1) ^ (uint8x16_t) (((int8x16_t) w >> 7) & 0x1b);
+    v ^= w;
+    v ^= (uint8x16_t) vrev32q_u16((uint16x8_t) w);
+
+    w = (v << 1) ^ (uint8x16_t) (((int8x16_t) v >> 7) &
+                                 0x1b);  // multiplying 'v' by 2 in GF(2^8)
+    w ^= (uint8x16_t) vrev32q_u16((uint16x8_t) v);
+    w ^= vqtbl1q_u8(v ^ w, vld1q_u8(ror32by8));
+
+    // add round key
+    return vreinterpretq_m128i_u8(w) ^ RoundKey;
+
+#else /* ARMv7-A NEON implementation */
+    /* FIXME: optimized for NEON */
+    uint8_t i, e, f, g, h, v[4][4];
+    uint8_t *_a = (uint8_t *) &a;
+    for (i = 0; i < 16; ++i) {
+        v[((i / 4) + (i % 4)) % 4][i % 4] = _sse2neon_rsbox[_a[i]];
+    }
+
+    // inverse mix columns
+    for (i = 0; i < 4; ++i) {
+        e = v[i][0];
+        f = v[i][1];
+        g = v[i][2];
+        h = v[i][3];
+
+        v[i][0] = SSE2NEON_MULTIPLY(e, 0x0e) ^ SSE2NEON_MULTIPLY(f, 0x0b) ^
+                  SSE2NEON_MULTIPLY(g, 0x0d) ^ SSE2NEON_MULTIPLY(h, 0x09);
+        v[i][1] = SSE2NEON_MULTIPLY(e, 0x09) ^ SSE2NEON_MULTIPLY(f, 0x0e) ^
+                  SSE2NEON_MULTIPLY(g, 0x0b) ^ SSE2NEON_MULTIPLY(h, 0x0d);
+        v[i][2] = SSE2NEON_MULTIPLY(e, 0x0d) ^ SSE2NEON_MULTIPLY(f, 0x09) ^
+                  SSE2NEON_MULTIPLY(g, 0x0e) ^ SSE2NEON_MULTIPLY(h, 0x0b);
+        v[i][3] = SSE2NEON_MULTIPLY(e, 0x0b) ^ SSE2NEON_MULTIPLY(f, 0x0d) ^
+                  SSE2NEON_MULTIPLY(g, 0x09) ^ SSE2NEON_MULTIPLY(h, 0x0e);
+    }
+
+    return vreinterpretq_m128i_u8(vld1q_u8((uint8_t *) v)) ^ RoundKey;
+#endif
+}
+
+// Perform the last round of an AES encryption flow on data (state) in a using
+// the round key in RoundKey, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_aesenclast_si128
+FORCE_INLINE __m128i _mm_aesenclast_si128(__m128i a, __m128i RoundKey)
+{
+#if defined(__aarch64__)
+    static const uint8_t shift_rows[] = {
+        0x0, 0x5, 0xa, 0xf, 0x4, 0x9, 0xe, 0x3,
+        0x8, 0xd, 0x2, 0x7, 0xc, 0x1, 0x6, 0xb,
+    };
+
+    uint8x16_t v;
+    uint8x16_t w = vreinterpretq_u8_m128i(a);
+
+    // shift rows
+    w = vqtbl1q_u8(w, vld1q_u8(shift_rows));
+
+    // sub bytes
+    v = vqtbl4q_u8(_sse2neon_vld1q_u8_x4(_sse2neon_sbox), w);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_sbox + 0x40), w - 0x40);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_sbox + 0x80), w - 0x80);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_sbox + 0xc0), w - 0xc0);
+
+    // add round key
+    return vreinterpretq_m128i_u8(v) ^ RoundKey;
+
+#else /* ARMv7-A implementation */
+    uint8_t v[16] = {
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 0)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 5)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 10)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 15)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 4)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 9)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 14)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 3)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 8)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 13)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 2)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 7)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 12)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 1)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 6)],
+        _sse2neon_sbox[vgetq_lane_u8(vreinterpretq_u8_m128i(a), 11)],
+    };
+
+    return vreinterpretq_m128i_u8(vld1q_u8(v)) ^ RoundKey;
+#endif
+}
+
+// Perform the last round of an AES decryption flow on data (state) in a using
+// the round key in RoundKey, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_aesdeclast_si128
+FORCE_INLINE __m128i _mm_aesdeclast_si128(__m128i a, __m128i RoundKey)
+{
+#if defined(__aarch64__)
+    static const uint8_t inv_shift_rows[] = {
+        0x0, 0xd, 0xa, 0x7, 0x4, 0x1, 0xe, 0xb,
+        0x8, 0x5, 0x2, 0xf, 0xc, 0x9, 0x6, 0x3,
+    };
+
+    uint8x16_t v;
+    uint8x16_t w = vreinterpretq_u8_m128i(a);
+
+    // inverse shift rows
+    w = vqtbl1q_u8(w, vld1q_u8(inv_shift_rows));
+
+    // inverse sub bytes
+    v = vqtbl4q_u8(_sse2neon_vld1q_u8_x4(_sse2neon_rsbox), w);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_rsbox + 0x40), w - 0x40);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_rsbox + 0x80), w - 0x80);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_rsbox + 0xc0), w - 0xc0);
+
+    // add round key
+    return vreinterpretq_m128i_u8(v) ^ RoundKey;
+
+#else /* ARMv7-A NEON implementation */
+    /* FIXME: optimized for NEON */
+    uint8_t v[4][4];
+    uint8_t *_a = (uint8_t *) &a;
+    for (int i = 0; i < 16; ++i) {
+        v[((i / 4) + (i % 4)) % 4][i % 4] = _sse2neon_rsbox[_a[i]];
+    }
+
+    return vreinterpretq_m128i_u8(vld1q_u8((uint8_t *) v)) ^ RoundKey;
+#endif
+}
+
+// Perform the InvMixColumns transformation on a and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_aesimc_si128
+FORCE_INLINE __m128i _mm_aesimc_si128(__m128i a)
+{
+#if defined(__aarch64__)
+    static const uint8_t ror32by8[] = {
+        0x1, 0x2, 0x3, 0x0, 0x5, 0x6, 0x7, 0x4,
+        0x9, 0xa, 0xb, 0x8, 0xd, 0xe, 0xf, 0xc,
+    };
+    uint8x16_t v = vreinterpretq_u8_m128i(a);
+    uint8x16_t w;
+
+    // multiplying 'v' by 4 in GF(2^8)
+    w = (v << 1) ^ (uint8x16_t) (((int8x16_t) v >> 7) & 0x1b);
+    w = (w << 1) ^ (uint8x16_t) (((int8x16_t) w >> 7) & 0x1b);
+    v ^= w;
+    v ^= (uint8x16_t) vrev32q_u16((uint16x8_t) w);
+
+    // multiplying 'v' by 2 in GF(2^8)
+    w = (v << 1) ^ (uint8x16_t) (((int8x16_t) v >> 7) & 0x1b);
+    w ^= (uint8x16_t) vrev32q_u16((uint16x8_t) v);
+    w ^= vqtbl1q_u8(v ^ w, vld1q_u8(ror32by8));
+    return vreinterpretq_m128i_u8(w);
+
+#else /* ARMv7-A NEON implementation */
+    uint8_t i, e, f, g, h, v[4][4];
+    vst1q_u8((uint8_t *) v, vreinterpretq_u8_m128i(a));
+    for (i = 0; i < 4; ++i) {
+        e = v[i][0];
+        f = v[i][1];
+        g = v[i][2];
+        h = v[i][3];
+
+        v[i][0] = SSE2NEON_MULTIPLY(e, 0x0e) ^ SSE2NEON_MULTIPLY(f, 0x0b) ^
+                  SSE2NEON_MULTIPLY(g, 0x0d) ^ SSE2NEON_MULTIPLY(h, 0x09);
+        v[i][1] = SSE2NEON_MULTIPLY(e, 0x09) ^ SSE2NEON_MULTIPLY(f, 0x0e) ^
+                  SSE2NEON_MULTIPLY(g, 0x0b) ^ SSE2NEON_MULTIPLY(h, 0x0d);
+        v[i][2] = SSE2NEON_MULTIPLY(e, 0x0d) ^ SSE2NEON_MULTIPLY(f, 0x09) ^
+                  SSE2NEON_MULTIPLY(g, 0x0e) ^ SSE2NEON_MULTIPLY(h, 0x0b);
+        v[i][3] = SSE2NEON_MULTIPLY(e, 0x0b) ^ SSE2NEON_MULTIPLY(f, 0x0d) ^
+                  SSE2NEON_MULTIPLY(g, 0x09) ^ SSE2NEON_MULTIPLY(h, 0x0e);
+    }
+
+    return vreinterpretq_m128i_u8(vld1q_u8((uint8_t *) v));
+#endif
+}
+
+// Assist in expanding the AES cipher key by computing steps towards generating
+// a round key for encryption cipher using data from a and an 8-bit round
+// constant specified in imm8, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_aeskeygenassist_si128
+//
+// Emits the Advanced Encryption Standard (AES) instruction aeskeygenassist.
+// This instruction generates a round key for AES encryption. See
+// https://kazakov.life/2017/11/01/cryptocurrency-mining-on-ios-devices/
+// for details.
+FORCE_INLINE __m128i _mm_aeskeygenassist_si128(__m128i a, const int rcon)
+{
+#if defined(__aarch64__)
+    uint8x16_t _a = vreinterpretq_u8_m128i(a);
+    uint8x16_t v = vqtbl4q_u8(_sse2neon_vld1q_u8_x4(_sse2neon_sbox), _a);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_sbox + 0x40), _a - 0x40);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_sbox + 0x80), _a - 0x80);
+    v = vqtbx4q_u8(v, _sse2neon_vld1q_u8_x4(_sse2neon_sbox + 0xc0), _a - 0xc0);
+
+    uint32x4_t v_u32 = vreinterpretq_u32_u8(v);
+    uint32x4_t ror_v = vorrq_u32(vshrq_n_u32(v_u32, 8), vshlq_n_u32(v_u32, 24));
+    uint32x4_t ror_xor_v = veorq_u32(ror_v, vdupq_n_u32(rcon));
+
+    return vreinterpretq_m128i_u32(vtrn2q_u32(v_u32, ror_xor_v));
+
+#else /* ARMv7-A NEON implementation */
+    uint32_t X1 = _mm_cvtsi128_si32(_mm_shuffle_epi32(a, 0x55));
+    uint32_t X3 = _mm_cvtsi128_si32(_mm_shuffle_epi32(a, 0xFF));
+    for (int i = 0; i < 4; ++i) {
+        ((uint8_t *) &X1)[i] = _sse2neon_sbox[((uint8_t *) &X1)[i]];
+        ((uint8_t *) &X3)[i] = _sse2neon_sbox[((uint8_t *) &X3)[i]];
+    }
+    return _mm_set_epi32(((X3 >> 8) | (X3 << 24)) ^ rcon, X3,
+                         ((X1 >> 8) | (X1 << 24)) ^ rcon, X1);
+#endif
+}
+#undef SSE2NEON_AES_SBOX
+#undef SSE2NEON_AES_RSBOX
+
+#if defined(__aarch64__)
+#undef SSE2NEON_XT
+#undef SSE2NEON_MULTIPLY
+#endif
+
+#else /* __ARM_FEATURE_CRYPTO */
+// Implements equivalent of 'aesenc' by combining AESE (with an empty key) and
+// AESMC and then manually applying the real key as an xor operation. This
+// unfortunately means an additional xor op; the compiler should be able to
+// optimize this away for repeated calls however. See
+// https://blog.michaelbrase.com/2018/05/08/emulating-x86-aes-intrinsics-on-armv8-a
+// for more details.
+FORCE_INLINE __m128i _mm_aesenc_si128(__m128i a, __m128i b)
+{
+    return vreinterpretq_m128i_u8(veorq_u8(
+        vaesmcq_u8(vaeseq_u8(vreinterpretq_u8_m128i(a), vdupq_n_u8(0))),
+        vreinterpretq_u8_m128i(b)));
+}
+
+// Perform one round of an AES decryption flow on data (state) in a using the
+// round key in RoundKey, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_aesdec_si128
+FORCE_INLINE __m128i _mm_aesdec_si128(__m128i a, __m128i RoundKey)
+{
+    return vreinterpretq_m128i_u8(veorq_u8(
+        vaesimcq_u8(vaesdq_u8(vreinterpretq_u8_m128i(a), vdupq_n_u8(0))),
+        vreinterpretq_u8_m128i(RoundKey)));
+}
+
+// Perform the last round of an AES encryption flow on data (state) in a using
+// the round key in RoundKey, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_aesenclast_si128
+FORCE_INLINE __m128i _mm_aesenclast_si128(__m128i a, __m128i RoundKey)
+{
+    return _mm_xor_si128(vreinterpretq_m128i_u8(vaeseq_u8(
+                             vreinterpretq_u8_m128i(a), vdupq_n_u8(0))),
+                         RoundKey);
+}
+
+// Perform the last round of an AES decryption flow on data (state) in a using
+// the round key in RoundKey, and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_aesdeclast_si128
+FORCE_INLINE __m128i _mm_aesdeclast_si128(__m128i a, __m128i RoundKey)
+{
+    return vreinterpretq_m128i_u8(
+        veorq_u8(vaesdq_u8(vreinterpretq_u8_m128i(a), vdupq_n_u8(0)),
+                 vreinterpretq_u8_m128i(RoundKey)));
+}
+
+// Perform the InvMixColumns transformation on a and store the result in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_aesimc_si128
+FORCE_INLINE __m128i _mm_aesimc_si128(__m128i a)
+{
+    return vreinterpretq_m128i_u8(vaesimcq_u8(vreinterpretq_u8_m128i(a)));
+}
+
+// Assist in expanding the AES cipher key by computing steps towards generating
+// a round key for encryption cipher using data from a and an 8-bit round
+// constant specified in imm8, and store the result in dst."
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_aeskeygenassist_si128
+FORCE_INLINE __m128i _mm_aeskeygenassist_si128(__m128i a, const int rcon)
+{
+    // AESE does ShiftRows and SubBytes on A
+    uint8x16_t u8 = vaeseq_u8(vreinterpretq_u8_m128i(a), vdupq_n_u8(0));
+
+#if !defined(_MSC_VER) || defined(__clang__)
+    uint8x16_t dest = {
+        // Undo ShiftRows step from AESE and extract X1 and X3
+        u8[0x4], u8[0x1], u8[0xE], u8[0xB],  // SubBytes(X1)
+        u8[0x1], u8[0xE], u8[0xB], u8[0x4],  // ROT(SubBytes(X1))
+        u8[0xC], u8[0x9], u8[0x6], u8[0x3],  // SubBytes(X3)
+        u8[0x9], u8[0x6], u8[0x3], u8[0xC],  // ROT(SubBytes(X3))
+    };
+    uint32x4_t r = {0, (unsigned) rcon, 0, (unsigned) rcon};
+    return vreinterpretq_m128i_u8(dest) ^ vreinterpretq_m128i_u32(r);
+#else
+    // We have to do this hack because MSVC is strictly adhering to the CPP
+    // standard, in particular C++03 8.5.1 sub-section 15, which states that
+    // unions must be initialized by their first member type.
+
+    // As per the Windows ARM64 ABI, it is always little endian, so this works
+    __n128 dest{
+        ((uint64_t) u8.n128_u8[0x4] << 0) | ((uint64_t) u8.n128_u8[0x1] << 8) |
+            ((uint64_t) u8.n128_u8[0xE] << 16) |
+            ((uint64_t) u8.n128_u8[0xB] << 24) |
+            ((uint64_t) u8.n128_u8[0x1] << 32) |
+            ((uint64_t) u8.n128_u8[0xE] << 40) |
+            ((uint64_t) u8.n128_u8[0xB] << 48) |
+            ((uint64_t) u8.n128_u8[0x4] << 56),
+        ((uint64_t) u8.n128_u8[0xC] << 0) | ((uint64_t) u8.n128_u8[0x9] << 8) |
+            ((uint64_t) u8.n128_u8[0x6] << 16) |
+            ((uint64_t) u8.n128_u8[0x3] << 24) |
+            ((uint64_t) u8.n128_u8[0x9] << 32) |
+            ((uint64_t) u8.n128_u8[0x6] << 40) |
+            ((uint64_t) u8.n128_u8[0x3] << 48) |
+            ((uint64_t) u8.n128_u8[0xC] << 56)};
+
+    dest.n128_u32[1] = dest.n128_u32[1] ^ rcon;
+    dest.n128_u32[3] = dest.n128_u32[3] ^ rcon;
+
+    return dest;
+#endif
+}
+#endif
+
+/* Others */
+
+// Perform a carry-less multiplication of two 64-bit integers, selected from a
+// and b according to imm8, and store the results in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_clmulepi64_si128
+FORCE_INLINE __m128i _mm_clmulepi64_si128(__m128i _a, __m128i _b, const int imm)
+{
+    uint64x2_t a = vreinterpretq_u64_m128i(_a);
+    uint64x2_t b = vreinterpretq_u64_m128i(_b);
+    switch (imm & 0x11) {
+    case 0x00:
+        return vreinterpretq_m128i_u64(
+            _sse2neon_vmull_p64(vget_low_u64(a), vget_low_u64(b)));
+    case 0x01:
+        return vreinterpretq_m128i_u64(
+            _sse2neon_vmull_p64(vget_high_u64(a), vget_low_u64(b)));
+    case 0x10:
+        return vreinterpretq_m128i_u64(
+            _sse2neon_vmull_p64(vget_low_u64(a), vget_high_u64(b)));
+    case 0x11:
+        return vreinterpretq_m128i_u64(
+            _sse2neon_vmull_p64(vget_high_u64(a), vget_high_u64(b)));
+    default:
+        abort();
+    }
+}
+
+FORCE_INLINE unsigned int _sse2neon_mm_get_denormals_zero_mode(void)
+{
+    union {
+        fpcr_bitfield field;
+#if defined(__aarch64__) || defined(_M_ARM64)
+        uint64_t value;
+#else
+        uint32_t value;
+#endif
+    } r;
+
+#if defined(__aarch64__) || defined(_M_ARM64)
+    r.value = _sse2neon_get_fpcr();
+#else
+    __asm__ __volatile__("vmrs %0, FPSCR" : "=r"(r.value)); /* read */
+#endif
+
+    return r.field.bit24 ? _MM_DENORMALS_ZERO_ON : _MM_DENORMALS_ZERO_OFF;
+}
+
+// Count the number of bits set to 1 in unsigned 32-bit integer a, and
+// return that count in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_popcnt_u32
+FORCE_INLINE int _mm_popcnt_u32(unsigned int a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+#if __has_builtin(__builtin_popcount)
+    return __builtin_popcount(a);
+#elif defined(_MSC_VER)
+    return _CountOneBits(a);
+#else
+    return (int) vaddlv_u8(vcnt_u8(vcreate_u8((uint64_t) a)));
+#endif
+#else
+    uint32_t count = 0;
+    uint8x8_t input_val, count8x8_val;
+    uint16x4_t count16x4_val;
+    uint32x2_t count32x2_val;
+
+    input_val = vld1_u8((uint8_t *) &a);
+    count8x8_val = vcnt_u8(input_val);
+    count16x4_val = vpaddl_u8(count8x8_val);
+    count32x2_val = vpaddl_u16(count16x4_val);
+
+    vst1_u32(&count, count32x2_val);
+    return count;
+#endif
+}
+
+// Count the number of bits set to 1 in unsigned 64-bit integer a, and
+// return that count in dst.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_popcnt_u64
+FORCE_INLINE int64_t _mm_popcnt_u64(uint64_t a)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+#if __has_builtin(__builtin_popcountll)
+    return __builtin_popcountll(a);
+#elif defined(_MSC_VER)
+    return _CountOneBits64(a);
+#else
+    return (int64_t) vaddlv_u8(vcnt_u8(vcreate_u8(a)));
+#endif
+#else
+    uint64_t count = 0;
+    uint8x8_t input_val, count8x8_val;
+    uint16x4_t count16x4_val;
+    uint32x2_t count32x2_val;
+    uint64x1_t count64x1_val;
+
+    input_val = vld1_u8((uint8_t *) &a);
+    count8x8_val = vcnt_u8(input_val);
+    count16x4_val = vpaddl_u8(count8x8_val);
+    count32x2_val = vpaddl_u16(count16x4_val);
+    count64x1_val = vpaddl_u32(count32x2_val);
+    vst1_u64(&count, count64x1_val);
+    return count;
+#endif
+}
+
+FORCE_INLINE_OPTNONE void _sse2neon_mm_set_denormals_zero_mode(
+    unsigned int flag)
+{
+    // AArch32 Advanced SIMD arithmetic always uses the Flush-to-zero setting,
+    // regardless of the value of the FZ bit.
+    union {
+        fpcr_bitfield field;
+#if defined(__aarch64__) || defined(_M_ARM64)
+        uint64_t value;
+#else
+        uint32_t value;
+#endif
+    } r;
+
+#if defined(__aarch64__) || defined(_M_ARM64)
+    r.value = _sse2neon_get_fpcr();
+#else
+    __asm__ __volatile__("vmrs %0, FPSCR" : "=r"(r.value)); /* read */
+#endif
+
+    r.field.bit24 = (flag & _MM_DENORMALS_ZERO_MASK) == _MM_DENORMALS_ZERO_ON;
+
+#if defined(__aarch64__) || defined(_M_ARM64)
+    _sse2neon_set_fpcr(r.value);
+#else
+    __asm__ __volatile__("vmsr FPSCR, %0" ::"r"(r));        /* write */
+#endif
+}
+
+// Return the current 64-bit value of the processor's time-stamp counter.
+// https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=rdtsc
+FORCE_INLINE uint64_t _rdtsc(void)
+{
+#if defined(__aarch64__) || defined(_M_ARM64)
+    uint64_t val;
+
+    /* According to ARM DDI 0487F.c, from Armv8.0 to Armv8.5 inclusive, the
+     * system counter is at least 56 bits wide; from Armv8.6, the counter
+     * must be 64 bits wide.  So the system counter could be less than 64
+     * bits wide and it is attributed with the flag 'cap_user_time_short'
+     * is true.
+     */
+#if defined(_MSC_VER) && !defined(__clang__)
+    val = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
+#else
+    __asm__ __volatile__("mrs %0, cntvct_el0" : "=r"(val));
+#endif
+
+    return val;
+#else
+    uint32_t pmccntr, pmuseren, pmcntenset;
+    // Read the user mode Performance Monitoring Unit (PMU)
+    // User Enable Register (PMUSERENR) access permissions.
+    __asm__ __volatile__("mrc p15, 0, %0, c9, c14, 0" : "=r"(pmuseren));
+    if (pmuseren & 1) {  // Allows reading PMUSERENR for user mode code.
+        __asm__ __volatile__("mrc p15, 0, %0, c9, c12, 1" : "=r"(pmcntenset));
+        if (pmcntenset & 0x80000000UL) {  // Is it counting?
+            __asm__ __volatile__("mrc p15, 0, %0, c9, c13, 0" : "=r"(pmccntr));
+            // The counter is set up to count every 64th cycle
+            return (uint64_t) (pmccntr) << 6;
+        }
+    }
+
+    // Fallback to syscall as we can't enable PMUSERENR in user mode.
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    return (uint64_t) (tv.tv_sec) * 1000000 + tv.tv_usec;
+#endif
+}
+
+#if defined(__GNUC__) || defined(__clang__)
+#pragma pop_macro("ALIGN_STRUCT")
+#pragma pop_macro("FORCE_INLINE")
+#pragma pop_macro("FORCE_INLINE_OPTNONE")
+#endif
+
+#if defined(__GNUC__) && !defined(__clang__)
+#pragma GCC pop_options
+#endif
+
+#endif
diff --git a/LGhost/VCL2/vector_convert.h b/LGhost/VCL2/vector_convert.h
index a7aa2b6..f942ecb 100644
--- a/LGhost/VCL2/vector_convert.h
+++ b/LGhost/VCL2/vector_convert.h
@@ -1,14 +1,14 @@
 /**************************  vector_convert.h   *******************************
 * Author:        Agner Fog
 * Date created:  2014-07-23
-* Last modified: 2019-11-17
-* Version:       2.01.00
+* Last modified: 2022-07-20
+* Version:       2.02.00
 * Project:       vector class library
 * Description:
 * Header file for conversion between different vector classes with different
 * sizes. Also includes verious generic template functions.
 *
-* (c) Copyright 2012-2019 Agner Fog.
+* (c) Copyright 2012-2022 Agner Fog.
 * Apache License version 2.0 or later.
 *****************************************************************************/
 
@@ -19,7 +19,7 @@
 #include "vectorclass.h"
 #endif
 
-#if VECTORCLASS_H < 20100
+#if VECTORCLASS_H < 20200
 #error Incompatible versions of vector class library mixed
 #endif
 
@@ -164,6 +164,32 @@ static inline Vec4ui compress (Vec4uq const a) {
     return _mm256_cvtepi64_epi32(a);
 }
 
+// compress_saturated functions. overflow saturates
+static inline Vec16c compress_saturated (Vec16s const a) {
+    return _mm256_cvtsepi16_epi8(a);
+}
+
+static inline Vec16uc compress_saturated (Vec16us const a) {
+    return _mm256_cvtusepi16_epi8(a);
+}
+
+static inline Vec8s compress_saturated (Vec8i const a) {
+    return _mm256_cvtsepi32_epi16(a);
+}
+
+static inline Vec8us compress_saturated (Vec8ui const a) {
+    return _mm256_cvtusepi32_epi16(a);
+}
+
+static inline Vec4i compress_saturated (Vec4q const a) {
+    return _mm256_cvtsepi64_epi32(a);
+}
+
+static inline Vec4ui compress_saturated (Vec4uq const a) {
+    return _mm256_cvtusepi64_epi32(a);
+}
+
+
 #else  // no AVX512
 
 // compress functions. overflow wraps around
@@ -191,6 +217,31 @@ static inline Vec4ui compress (Vec4uq const a) {
     return compress(a.get_low(), a.get_high());
 }
 
+// compress_saturated functions. overflow saturates
+static inline Vec16c compress_saturated (Vec16s const a) {
+    return compress_saturated(a.get_low(), a.get_high());
+}
+
+static inline Vec16uc compress_saturated (Vec16us const a) {
+    return compress_saturated(a.get_low(), a.get_high());
+}
+
+static inline Vec8s compress_saturated (Vec8i const a) {
+    return compress_saturated(a.get_low(), a.get_high());
+}
+
+static inline Vec8us compress_saturated (Vec8ui const a) {
+    return compress_saturated(a.get_low(), a.get_high());
+}
+
+static inline Vec4i compress_saturated (Vec4q const a) {
+    return compress_saturated(a.get_low(), a.get_high());
+}
+
+static inline Vec4ui compress_saturated (Vec4uq const a) {
+    return compress_saturated(a.get_low(), a.get_high());
+}
+
 #endif  // AVX512
 
 #endif // MAX_VECTOR_SIZE >= 256
@@ -198,6 +249,67 @@ static inline Vec4ui compress (Vec4uq const a) {
 
 #if MAX_VECTOR_SIZE >= 512
 
+/*****************************************************************************
+*
+*          Reduce from 512 to 256 bit vectors
+*
+*****************************************************************************/
+#if INSTRSET >= 10  // AVX512VL
+
+// compress_saturated functions. overflow saturates
+static inline Vec32c compress_saturated (Vec32s const a) {
+    return _mm512_cvtsepi16_epi8(a);
+}
+
+static inline Vec32uc compress_saturated (Vec32us const a) {
+    return _mm512_cvtusepi16_epi8(a);
+}
+
+static inline Vec16s compress_saturated (Vec16i const a) {
+    return _mm512_cvtsepi32_epi16(a);
+}
+
+static inline Vec16us compress_saturated (Vec16ui const a) {
+    return _mm512_cvtusepi32_epi16(a);
+}
+
+static inline Vec8i compress_saturated (Vec8q const a) {
+    return _mm512_cvtsepi64_epi32(a);
+}
+
+static inline Vec8ui compress_saturated (Vec8uq const a) {
+    return _mm512_cvtusepi64_epi32(a);
+}
+
+#else  // no AVX512
+
+// compress_saturated functions. overflow saturates
+static inline Vec32c compress_saturated (Vec32s const a) {
+    return compress_saturated(a.get_low(), a.get_high());
+}
+
+static inline Vec32uc compress_saturated (Vec32us const a) {
+    return compress_saturated(a.get_low(), a.get_high());
+}
+
+static inline Vec16s compress_saturated (Vec16i const a) {
+    return compress_saturated(a.get_low(), a.get_high());
+}
+
+static inline Vec16us compress_saturated (Vec16ui const a) {
+    return compress_saturated(a.get_low(), a.get_high());
+}
+
+static inline Vec8i compress_saturated (Vec8q const a) {
+    return compress_saturated(a.get_low(), a.get_high());
+}
+
+static inline Vec8ui compress_saturated (Vec8uq const a) {
+    return compress_saturated(a.get_low(), a.get_high());
+}
+
+#endif  // AVX512
+
 /*****************************************************************************
 *
 *          Extend from 256 to 512 bit vectors
@@ -398,11 +510,18 @@ static inline Vec4f to_float (Vec2d const a) {
 *
 *****************************************************************************/
 
+// concatenate two vectors into one vector of double size
+template <typename T> auto concatenate2(T const a, T const b) {
+    static_assert(sizeof(T) * 8 < MAX_VECTOR_SIZE, "Maximum vector size exceeded");
+    return decltype(extend_z(a))(a, b);   // call constructor for double size vector type
+}
+
+
 // horizontal min/max of vector elements
 // implemented with universal template, works for all vector types:
 
 template <typename T> auto horizontal_min(T const x) {
-    if constexpr ((T::elementtype() & 16) != 0) {
+    if constexpr (T::elementtype() >= 15) {
         // T is a float or double vector
         if (horizontal_or(is_nan(x))) {
             // check for NAN because min does not guarantee NAN propagation
@@ -456,7 +575,7 @@ template <typename T> auto horizontal_min1(T const x) {
 }
 
 template <typename T> auto horizontal_max(T const x) {
-    if constexpr ((T::elementtype() & 16) != 0) {
+    if constexpr (T::elementtype() >= 15) {
         // T is a float or double vector
         if (horizontal_or(is_nan(x))) {
             // check for NAN because max does not guarantee NAN propagation
@@ -540,7 +659,7 @@ static inline int horizontal_count(V const x) {
 // conforming to the new IEEE-754 2019 standard
 template <typename V>
 static inline V maximum(V const a, V const b) {
-    if constexpr (V::elementtype() < 16) {
+    if constexpr (V::elementtype() < 15) {
         return max(a, b);              // integer type
     }
     else {                             // float or double vector
@@ -554,7 +673,7 @@ static inline V maximum(V const a, V const b) {
 
 template <typename V>
 static inline V minimum(V const a, V const b) {
-    if constexpr (V::elementtype() < 16) {
+    if constexpr (V::elementtype() < 15) {
         return min(a, b);              // integer type
     }
     else {                             // float or double vector
@@ -566,6 +685,141 @@ static inline V minimum(V const a, V const b) {
     }
 }
 
+// floating point remainder
+// -denominator/2 <= result < denominator/2
+template <typename V>
+static inline V fremainder(V const numerator, double const denominator) {
+    // (Optimization notice: Calculation of 1/denominator and constants for extended precision reduction
+    // may be optimized by a compiler moving loop-invariant code. This is intended)
+    static_assert(V::elementtype() == 16 || V::elementtype() == 17, "wrong vector type"); // supports only float and double
+    if (denominator > 0.) {                                // denominator must be positive
+        if constexpr (V::elementtype() == 16) {            // float
+#ifdef __FMA__
+            float recipd = float(1.0 / denominator);       // reciprocal denominator
+            float fd = float(denominator);                 // denominator rounded to single precision
+            float d2 = float(denominator - fd);            // remaining bits for double precision
+            V q = round(numerator * recipd);               // divide and round
+            V m = nmul_add(q, d2, nmul_add(q, fd, numerator));// double precision reduction
+#else  // no FMA. Use extended precision reduction
+            union {
+                float f;
+                uint32_t i;
+            } u;
+            u.f = float(denominator);
+            u.i &= 0xFFFFF000;                             // remove 12 least significant bits for extended precision reduction
+            float d2 = denominator - u.f;                  // remaining bits
+            float recipd = float(1.0 / denominator);       // reciprocal
+            V q = round(numerator * recipd);               // divide and round
+            V m = nmul_add(q, d2, nmul_add(q, u.f, numerator));// extended precision reduction
+#endif  // FMA
+            if (true) { // Check that result is within desired interval. This may be omitted if not essential:
+                // This check may be needed in extreme cases of numerator > 1.E5 * denominator
+                auto too_high = m >= float( denominator * 0.5);
+                auto too_low  = m <  float(-denominator * 0.5);
+                m = if_sub(too_high, m, float(denominator));
+                m = if_add(too_low,  m, float(denominator));
+            }
+            return m;
+        }
+        else if constexpr (V::elementtype() == 17) {       // double precision
+#ifdef __FMA__
+            double recipd = 1.0 / denominator;             // reciprocal
+            V q = round(numerator * recipd);               // divide and round
+            V m = nmul_add(q, denominator, numerator);     // nmul_add has extended precision
+#else  // no FMA. Use extended precision reduction
+            union {
+                double f;
+                uint64_t i;
+            } u;
+            u.f = denominator;
+            u.i &= 0xFFFFFFFFFF000000;                     // remove 24 least significant bits for extended precision reduction
+            double d2 = denominator - u.f;                 // remaining bits
+            double recipd = 1.0 / denominator;             // reciprocal
+            V q = round(numerator * recipd);               // divide and round
+            V m = nmul_add(q, d2, nmul_add(q, u.f, numerator));// extended precision reduction
+#endif  // FMA
+            if (true) { // Check that result is within desired interval. This may be omitted if not essential:
+                // This check is rarely needed except in extreme cases of numerator > 1.E14 * denominator
+                auto too_high = m >=  denominator * 0.5;
+                auto too_low  = m <  -denominator * 0.5;
+                m = if_sub(too_high, m, denominator);
+                m = if_add(too_low,  m, denominator);
+            }
+            return m;
+        }
+    }
+    else {
+        return nan_vec<V>(1);                              //  denominator is not positive
+    }
+}
+
+// floating point modulo
+// 0 <= result < denominator
+template <typename V>
+static inline V fmodulo(V const numerator, double const denominator) {
+    // (Optimization notice: Calculation of 1/denominator and constants for extended precision reduction
+    // may be optimized by a compiler moving loop-invariant code. This is intended)
+    static_assert(V::elementtype() == 16 || V::elementtype() == 17, "wrong vector type"); // supports only float and double
+    if (denominator > 0.) {                                // denominator must be positive
+        if constexpr (V::elementtype() == 16) {            // float
+#ifdef __FMA__
+            float recipd = float(1.0 / denominator);       // reciprocal denominator
+            float fd = float(denominator);                 // denominator rounded to single precision
+            float d2 = float(denominator - fd);            // remaining bits for double precision
+            V q = floor(numerator * recipd);               // divide and floor
+            V m = nmul_add(q, d2, nmul_add(q, fd, numerator));// double precision reduction
+#else  // no FMA. Use extended precision reduction
+            union {
+                float f;
+                uint32_t i;
+            } u;
+            u.f = float(denominator);
+            u.i &= 0xFFFFF000;                             // remove 12 least significant bits for extended precision reduction
+            float d2 = denominator - u.f;                  // remaining bits
+            float recipd = float(1.0 / denominator);       // reciprocal
+            V q = floor(numerator * recipd);               // divide and floor
+            V m = nmul_add(q, d2, nmul_add(q, u.f, numerator));// extended precision reduction
+#endif  // FMA
+            if (true) { // Check that result is within desired interval. This may be omitted if not essential:
+                // This check may be needed in extreme cases of numerator > 1.E5 * denominator
+                auto too_high = m >= float(denominator);
+                auto too_low  = m <  0.f;
+                m = if_sub(too_high, m, float(denominator));
+                m = if_add(too_low,  m, float(denominator));
+            }
+            return m;
+        }
+        else if constexpr (V::elementtype() == 17) {       // double precision
+#ifdef __FMA__
+            double recipd = 1.0 / denominator;             // reciprocal
+            V q = floor(numerator * recipd);               // divide and floor
+            V m = nmul_add(q, denominator, numerator);     // nmul_add has extended precision
+#else  // no FMA. Use extended precision reduction
+            union {
+                double f;
+                uint64_t i;
+            } u;
+            u.f = denominator;
+            u.i &= 0xFFFFFFFFFF000000;                     // remove 24 least significant bits for extended precision reduction
+            double d2 = denominator - u.f;                 // remaining bits
+            double recipd = 1.0 / denominator;             // reciprocal
+            V q = floor(numerator * recipd);               // divide and floor
+            V m = nmul_add(q, d2, nmul_add(q, u.f, numerator));// extended precision reduction
+#endif  // FMA
+            if (true) { // Check that result is within desired interval. This may be omitted if not essential:
+                // This check is rarely needed except in extreme cases of numerator > 1.E14 * denominator
+                auto too_high = m >= denominator;
+                auto too_low  = m <  0.;
+                m = if_sub(too_high, m, denominator);
+                m = if_add(too_low,  m, denominator);
+            }
+            return m;
+        }
+    }
+    else {
+        return nan_vec<V>(1);                              //  denominator is not positive
+    }
+}
 
 #ifdef VCL_NAMESPACE
 }
diff --git a/LGhost/VCL2/vectorclass.h b/LGhost/VCL2/vectorclass.h
index b105711..80f57eb 100644
--- a/LGhost/VCL2/vectorclass.h
+++ b/LGhost/VCL2/vectorclass.h
@@ -1,8 +1,8 @@
 /****************************  vectorclass.h   ********************************
 * Author:        Agner Fog
 * Date created:  2012-05-30
-* Last modified: 2020-04-11
-* Version:       2.01.02
+* Last modified: 2022-07-20
+* Version:       2.02.00
 * Project:       vector class library
 * Home:          https://github.com/vectorclass
 * Description:
@@ -10,7 +10,7 @@
 * in x86 and x86-64 microprocessors with SSE2 and later instruction sets.
 *
 * Instructions:
-* Use Gnu, Clang, Intel or Microsoft C++ compiler. Compile for the desired
+* Use Gnu, Clang, Microsoft, or Intel C++ compiler. Compile for the desired
 * instruction set, which must be at least SSE2. Specify the supported
 * instruction set by a command line define, e.g. __SSE4_1__ if the
 * compiler does not automatically do so.
@@ -22,11 +22,12 @@
 * This header file includes the appropriate header files depending on the
 * selected instruction set.
 *
-* (c) Copyright 2012-2020 Agner Fog.
+* (c) Copyright 2012-2022 Agner Fog.
 * Apache License version 2.0 or later.
 ******************************************************************************/
+
 #ifndef VECTORCLASS_H
-#define VECTORCLASS_H  20102
+#define VECTORCLASS_H  20200
 
 // Maximum vector size, bits. Allowed values are 128, 256, 512
 #ifndef MAX_VECTOR_SIZE
@@ -72,7 +73,7 @@
 #endif
 #endif  //  MAX_VECTOR_SIZE >= 512
 
-#include "vector_convert.h"  // conversion between different vector sizes
+#include "vector_convert.h"  // conversion between different vector sizes, and common templates
 
 #endif  // INSTRSET >= 2
 
diff --git a/LGhost/VCL2/vectorf256.h b/LGhost/VCL2/vectorf256.h
index 8db54df..2b222c7 100644
--- a/LGhost/VCL2/vectorf256.h
+++ b/LGhost/VCL2/vectorf256.h
@@ -1,8 +1,8 @@
 /****************************  vectorf256.h   *******************************
 * Author:        Agner Fog
 * Date created:  2012-05-30
-* Last modified: 2020-03-26
-* Version:       2.01.02
+* Last modified: 2023-07-04
+* Version:       2.02.02
 * Project:       vector class library
 * Description:
 * Header file defining 256-bit floating point vector classes
@@ -18,7 +18,7 @@
 * Each vector object is represented internally in the CPU as a 256-bit register.
 * This header file defines operators and functions for these vectors.
 *
-* (c) Copyright 2012-2020 Agner Fog.
+* (c) Copyright 2012-2023 Agner Fog.
 * Apache License version 2.0 or later.
 *****************************************************************************/
 
@@ -29,7 +29,7 @@
 #include "vectorclass.h"
 #endif
 
-#if VECTORCLASS_H < 20100
+#if VECTORCLASS_H < 20200
 #error Incompatible versions of vector class library mixed
 #endif
 
@@ -81,8 +81,7 @@ protected:
     __m256 ymm; // Float vector
 public:
     // Default constructor:
-    Vec8fb() {
-    }
+    Vec8fb() = default;
     // Constructor to build from all elements:
     Vec8fb(bool b0, bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7) {
 #if INSTRSET >= 8  // AVX2
@@ -158,12 +157,11 @@ public:
         return *this;
     }
     // Member function to change a bitfield to a boolean vector
-    // AVX version. Use float instructions, treating integers as subnormal values
+    // AVX version. Cannot use float instructions if subnormals are disabled
     Vec8fb & load_bits(uint8_t a) {
-        __m256 b1 = _mm256_castsi256_ps(_mm256_set1_epi32((int32_t)a));  // broadcast a
-        __m256 m2 = constant8f<1,2,4,8,0x10,0x20,0x40,0x80>();
-        __m256 d1 = _mm256_and_ps(b1, m2); // isolate one bit in each dword
-        ymm = _mm256_cmp_ps(d1, _mm256_setzero_ps(), 4);  // compare subnormal values with 0
+        Vec4fb y0 = Vec4fb().load_bits(a);
+        Vec4fb y1 = Vec4fb().load_bits(uint8_t(a >> 4u));
+        *this = Vec8fb(y0, y1);
         return *this;
     }
     // Type cast operator to convert to type Vec8ib used as Boolean for integer vectors
@@ -327,8 +325,7 @@ protected:
     __m256d ymm; // double vector
 public:
     // Default constructor:
-    Vec4db() {
-    }
+    Vec4db() = default;
     // Constructor to build from all elements:
     Vec4db(bool b0, bool b1, bool b2, bool b3) {
 #if INSTRSET >= 8  // AVX2
@@ -408,19 +405,19 @@ public:
         return Vec4q(_mm_castpd_si128(get_low()), _mm_castpd_si128(get_high()));
     }
     // Member function to change a bitfield to a boolean vector
-    // AVX version. Use float instructions, treating integers as subnormal values
+    // AVX version. Cannot use float instructions if subnormals are disabled
     Vec4db & load_bits(uint8_t a) {
-        __m256d b1 = _mm256_castsi256_pd(_mm256_set1_epi32((int32_t)a));  // broadcast a
-        __m256d m2 = _mm256_castps_pd(constant8f<1,0,2,0,4,0,8,0>());
-        __m256d d1 = _mm256_and_pd(b1, m2); // isolate one bit in each dword
-        ymm = _mm256_cmp_pd(d1, _mm256_setzero_pd(), 4);  // compare subnormal values with 0
+        Vec2db a0 = Vec2db().load_bits(a);
+        Vec2db a1 = Vec2db().load_bits(uint8_t(a>>2u));
+        *this = Vec4db(a0, a1);
         return *this;
     }
 #endif // AVX2
     // Member function to change a single element in vector
     Vec4db const insert(int index, bool value) {
         const int32_t maskl[16] = {0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0};
-        __m256d mask = _mm256_loadu_pd((double const*)(maskl+8-(index&3)*2)); // mask with FFFFFFFFFFFFFFFF at index position
+        const size_t two = 2;  // avoid silly warning from MS compiler
+        __m256d mask = _mm256_loadu_pd((double const*)(maskl+8-(index&3)*two)); // mask with FFFFFFFFFFFFFFFF at index position
         if (value) {
             ymm = _mm256_or_pd(ymm,mask);
         }
@@ -578,8 +575,7 @@ protected:
     __m256 ymm; // Float vector
 public:
     // Default constructor:
-    Vec8f() {
-    }
+    Vec8f() = default;
     // Constructor to broadcast the same value into all elements:
     Vec8f(float f) {
         ymm = _mm256_set1_ps(f);
@@ -891,7 +887,7 @@ static inline Vec8fb operator <= (Vec8f const a, Vec8f const b) {
 // vector operator > : returns true for elements for which a > b
 static inline Vec8fb operator > (Vec8f const a, Vec8f const b) {
 #if INSTRSET >= 10  // compact boolean vectors
-    return _mm256_cmp_ps_mask(a, b, 6);
+    return _mm256_cmp_ps_mask(a, b, 6+8);
 #else
     return b < a;
 #endif
@@ -900,7 +896,7 @@ static inline Vec8fb operator > (Vec8f const a, Vec8f const b) {
 // vector operator >= : returns true for elements for which a >= b
 static inline Vec8fb operator >= (Vec8f const a, Vec8f const b) {
 #if INSTRSET >= 10  // compact boolean vectors
-    return _mm256_cmp_ps_mask(a, b, 5);
+    return _mm256_cmp_ps_mask(a, b, 5+8);
 #else
     return b <= a;
 #endif
@@ -965,10 +961,6 @@ static inline Vec8fb operator ! (Vec8f const a) {
 *
 *****************************************************************************/
 
-static inline Vec8f zero_8f() {
-    return _mm256_setzero_ps();
-}
-
 // Select between two operands. Corresponds to this pseudocode:
 // for (int i = 0; i < 8; i++) result[i] = s[i] ? a[i] : b[i];
 static inline Vec8f select (Vec8fb const s, Vec8f const a, Vec8f const b) {
@@ -1047,7 +1039,7 @@ static inline Vec8f sign_combine(Vec8f const a, Vec8f const b) {
 
 // Categorization functions
 
-// Function is_finite: gives true for elements that are normal, denormal or zero,
+// Function is_finite: gives true for elements that are normal, subnormal or zero,
 // false for INF and NAN
 // (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
 static inline Vec8fb is_finite(Vec8f const a) {
@@ -1055,7 +1047,7 @@ static inline Vec8fb is_finite(Vec8f const a) {
     return __mmask8(~ _mm256_fpclass_ps_mask (a, 0x99));
 #elif INSTRSET >= 8  // 256 bit integer vectors are available, AVX2
     Vec8i t1 = _mm256_castps_si256(a);    // reinterpret as 32-bit integer
-    Vec8i t2 = t1 << 1;                // shift out sign bit
+    Vec8i t2 = t1 << 1;                   // shift out sign bit
     Vec8ib t3 = Vec8i(t2 & 0xFF000000) != 0xFF000000; // exponent field is not all 1s
     return t3;
 #else
@@ -1107,7 +1099,7 @@ static inline Vec8fb is_nan(Vec8f const a) {
 #endif
 
 
-// Function is_subnormal: gives true for elements that are denormal (subnormal)
+// Function is_subnormal: gives true for elements that are subnormal
 // false for finite numbers, zero, NAN and INF
 static inline Vec8fb is_subnormal(Vec8f const a) {
 #if INSTRSET >= 10  // compact boolean vectors
@@ -1124,7 +1116,7 @@ static inline Vec8fb is_subnormal(Vec8f const a) {
 #endif
 }
 
-// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal (denormal)
+// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal
 // false for finite numbers, NAN and INF
 static inline Vec8fb is_zero_or_subnormal(Vec8f const a) {
 #if INSTRSET >= 10  // compact boolean vectors
@@ -1234,6 +1226,7 @@ static inline Vec8f ceil(Vec8f const a) {
 // function roundi: round to nearest integer (even). (result as integer vector)
 static inline Vec8i roundi(Vec8f const a) {
     // Note: assume MXCSR control register is set to rounding
+    // Note: +INF gives 0x80000000
     return _mm256_cvtps_epi32(a);
 }
 
@@ -1363,14 +1356,6 @@ static inline Vec8f approx_recipr(Vec8f const a) {
 #endif
 }
 
-// Newton-Raphson refined approximate reciprocal (23 bit precision)
-static inline Vec8f rcp_nr(Vec8f const a) {
-    Vec8f nr = _mm256_rcp_ps(a);
-    Vec8f muls = nr * nr * a;
-    Vec8f dbl = nr + nr;
-    return dbl - muls;
-}
-
 // approximate reciprocal squareroot (Faster than 1.f / sqrt(a). Relative accuracy better than 2^-11)
 static inline Vec8f approx_rsqrt(Vec8f const a) {
 // use more accurate version if available. (none of these will raise exceptions on zero)
@@ -1423,7 +1408,7 @@ static inline Vec8f fraction(Vec8f const a) {
 // n  =    0 gives 1.0f
 // n >=  128 gives +INF
 // n <= -127 gives 0.0f
-// This function will never produce denormals, and never raise exceptions
+// This function will never produce subnormals, and never raise exceptions
 static inline Vec8f exp2(Vec8i const n) {
 #if INSTRSET >= 8  // 256 bit integer vectors are available, AVX2
     Vec8i t1 = max(n,  -0x7F);         // limit to allowed range
@@ -1450,8 +1435,7 @@ protected:
     __m256d ymm; // double vector
 public:
     // Default constructor:
-    Vec4d() {
-    }
+    Vec4d() = default;
     // Constructor to broadcast the same value into all elements:
     Vec4d(double d) {
         ymm = _mm256_set1_pd(d);
@@ -1753,7 +1737,7 @@ static inline Vec4db operator <= (Vec4d const a, Vec4d const b) {
 // vector operator > : returns true for elements for which a > b
 static inline Vec4db operator > (Vec4d const a, Vec4d const b) {
 #if INSTRSET >= 10  // compact boolean vectors
-    return _mm256_cmp_pd_mask(a, b, 6);
+    return _mm256_cmp_pd_mask(a, b, 6+8);
 #else
     return b < a;
 #endif
@@ -1762,7 +1746,7 @@ static inline Vec4db operator > (Vec4d const a, Vec4d const b) {
 // vector operator >= : returns true for elements for which a >= b
 static inline Vec4db operator >= (Vec4d const a, Vec4d const b) {
 #if INSTRSET >= 10  // compact boolean vectors
-    return _mm256_cmp_pd_mask(a, b, 5);
+    return _mm256_cmp_pd_mask(a, b, 5+8);
 #else
     return b <= a;
 #endif
@@ -1886,7 +1870,7 @@ static inline Vec4d sign_combine(Vec4d const a, Vec4d const b) {
 #endif
 }
 
-// Function is_finite: gives true for elements that are normal, denormal or zero,
+// Function is_finite: gives true for elements that are normal, subnormal or zero,
 // false for INF and NAN
 static inline Vec4db is_finite(Vec4d const a) {
 #if INSTRSET >= 10  // compact boolean vectors
@@ -1947,7 +1931,7 @@ static inline Vec4db is_nan(Vec4d const a) {
 #endif
 
 
-// Function is_subnormal: gives true for elements that are denormal (subnormal)
+// Function is_subnormal: gives true for elements that are subnormal
 // false for finite numbers, zero, NAN and INF
 static inline Vec4db is_subnormal(Vec4d const a) {
 #if INSTRSET >= 10  // compact boolean vectors
@@ -1964,7 +1948,7 @@ static inline Vec4db is_subnormal(Vec4d const a) {
 #endif
 }
 
-// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal (denormal)
+// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal
 // false for finite numbers, NAN and INF
 static inline Vec4db is_zero_or_subnormal(Vec4d const a) {
 #if INSTRSET >= 10  // compact boolean vectors
@@ -2256,7 +2240,7 @@ static inline Vec4d fraction(Vec4d const a) {
 // n  =     0 gives 1.0
 // n >=  1024 gives +INF
 // n <= -1023 gives 0.0
-// This function will never produce denormals, and never raise exceptions
+// This function will never produce subnormals, and never raise exceptions
 static inline Vec4d exp2(Vec4q const n) {
 #if INSTRSET >= 8  // 256 bit integer vectors are available
     Vec4q t1 = max(n,  -0x3FF);        // limit to allowed range
@@ -2309,6 +2293,10 @@ inline Vec4d change_sign(Vec4d const a) {
 
 #if INSTRSET >= 8  // AVX2
 
+#if defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION < 1004 && !defined(__clang__)
+#error Compiler ABI version must be at least 4
+#endif
+
 // ABI version 4 or later needed on Gcc for correct mangling of 256-bit intrinsic vectors.
 // If necessary, compile with -fabi-version=0 to get the latest abi version
 //#if !defined (GCC_VERSION) || (defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 1004)
@@ -2393,13 +2381,54 @@ static inline __m256d reinterpret_d (Vec256b const x) {
 
 #endif  // AVX2
 
+
+// extend vectors to double size by adding zeroes
+
+#if defined(__GNUC__) && __GNUC__ <= 9
+// GCC v. 9 is missing the _mm256_zextps128_ps256 intrinsic
+
+static inline Vec8f extend_z(Vec4f a) {
+    return Vec8f(a, Vec4f(0));
+}
+static inline Vec4d extend_z(Vec2d a) {
+    return Vec4d(a, Vec2d(0));
+}
+#if INSTRSET < 10 
+static inline Vec8fb extend_z(Vec4fb a) {
+    return Vec8fb(a, Vec4fb(false));
+}
+static inline Vec4db extend_z(Vec2db a) {
+    return Vec4db(a, Vec2db(false));
+}
+#endif // INSTRSET < 10 
+#else
+
+static inline Vec8f extend_z(Vec4f a) {
+    return _mm256_zextps128_ps256(a);
+}
+static inline Vec4d extend_z(Vec2d a) {
+    return _mm256_zextpd128_pd256(a);
+}
+
+#if INSTRSET < 10  // broad boolean vectors
+
+static inline Vec8fb extend_z(Vec4fb a) {
+    return _mm256_zextps128_ps256(a);
+}
+static inline Vec4db extend_z(Vec2db a) {
+    return _mm256_zextpd128_pd256(a);
+}
+
+#endif // INSTRSET
+#endif // __GNUC__
+
 // Function infinite4f: returns a vector where all elements are +INF
 static inline Vec8f infinite8f() {
     return reinterpret_f(Vec8i(0x7F800000));
 }
 
 // Function nan8f: returns a vector where all elements are +NAN (quiet)
-static inline Vec8f nan8f(int n = 0x10) {
+static inline Vec8f nan8f(uint32_t n = 0x10) {
     return nan_vec<Vec8f>(n);
 }
 
@@ -2409,7 +2438,7 @@ static inline Vec4d infinite4d() {
 }
 
 // Function nan4d: returns a vector where all elements are +NAN (quiet)
-static inline Vec4d nan4d(int n = 0x10) {
+static inline Vec4d nan4d(uint32_t n = 0x10) {
     return nan_vec<Vec4d>(n);
 }
 
@@ -2503,7 +2532,7 @@ static inline Vec4d permute4(Vec4d const a) {
 #if INSTRSET >= 10  // use compact mask
         y = _mm256_maskz_mov_pd(zero_mask<4>(indexs), y);
 #else               // use broad mask
-        const EList <int64_t, 4> bm = zero_mask_broad<Vec4q>(indexs);
+        constexpr EList <int64_t, 4> bm = zero_mask_broad<Vec4q>(indexs);
         //y = _mm256_and_pd(_mm256_castsi256_pd( Vec4q().load(bm.a) ), y);  // does not work with INSTRSET = 7
         __m256i bm1 = _mm256_loadu_si256((const __m256i*)(bm.a));
         y = _mm256_and_pd(_mm256_castsi256_pd(bm1), y);
@@ -2608,7 +2637,7 @@ static inline Vec8f permute8(Vec8f const a) {
 #if INSTRSET >= 10  // use compact mask
         y = _mm256_maskz_mov_ps(zero_mask<8>(indexs), y);
 #else  // use broad mask
-        const EList <int32_t, 8> bm = zero_mask_broad<Vec8i>(indexs);
+        constexpr EList <int32_t, 8> bm = zero_mask_broad<Vec8i>(indexs);
         __m256i bm1 = _mm256_loadu_si256((const __m256i*)(bm.a));
         y = _mm256_and_ps(_mm256_castsi256_ps(bm1), y);
 #endif
@@ -2682,7 +2711,7 @@ static inline Vec4d blend4(Vec4d const a, Vec4d const b) {
 #if INSTRSET >= 10  // use compact mask
         y = _mm256_maskz_mov_pd(zero_mask<4>(indexs), y);
 #else  // use broad mask
-        const EList <int64_t, 4> bm = zero_mask_broad<Vec4q>(indexs);
+        constexpr EList <int64_t, 4> bm = zero_mask_broad<Vec4q>(indexs);
         __m256i bm1 = _mm256_loadu_si256((const __m256i*)(bm.a));
         y = _mm256_and_pd(_mm256_castsi256_pd(bm1), y);
 #endif
@@ -2758,7 +2787,7 @@ static inline Vec8f blend8(Vec8f const a, Vec8f const b) {
 #if INSTRSET >= 10  // use compact mask
         y = _mm256_maskz_mov_ps(zero_mask<8>(indexs), y);
 #else  // use broad mask
-        const EList <int32_t, 8> bm = zero_mask_broad<Vec8i>(indexs);
+        constexpr EList <int32_t, 8> bm = zero_mask_broad<Vec8i>(indexs);
         __m256i bm1 = _mm256_loadu_si256((const __m256i*)(bm.a));
         y = _mm256_and_ps(_mm256_castsi256_ps(bm1), y);
 #endif
@@ -2815,7 +2844,10 @@ static inline Vec8f lookup(Vec8i const index, float const * table) {
 #endif
     // Limit index
     Vec8ui index1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        index1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         index1 = Vec8ui(index) & (n-1);
     }
@@ -2879,7 +2911,10 @@ static inline Vec4d lookup(Vec4q const index, double const * table) {
 #endif
     // Limit index
     Vec4uq index1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        index1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         index1 = Vec4uq(index) & Vec4uq(n-1);
     }
diff --git a/LGhost/VCL2/vectorf256e.h b/LGhost/VCL2/vectorf256e.h
index e8ce334..709c6d0 100644
--- a/LGhost/VCL2/vectorf256e.h
+++ b/LGhost/VCL2/vectorf256e.h
@@ -1,8 +1,8 @@
 /****************************  vectorf256e.h   *******************************
 * Author:        Agner Fog
 * Date created:  2012-05-30
-* Last modified: 2020-03-26
-* Version:       2.01.02
+* Last modified: 2023-07-04
+* Version:       2.02.02
 * Project:       vector class library
 * Description:
 * Header file defining 256-bit floating point vector classes
@@ -19,7 +19,7 @@
 * Each vector object is represented internally in the CPU as two 128-bit registers.
 * This header file defines operators and functions for these vectors.
 *
-* (c) Copyright 2012-2020 Agner Fog.
+* (c) Copyright 2012-2023 Agner Fog.
 * Apache License version 2.0 or later.
 *****************************************************************************/
 
@@ -30,7 +30,7 @@
 #include "vectorclass.h"
 #endif
 
-#if VECTORCLASS_H < 20100
+#if VECTORCLASS_H < 20200
 #error Incompatible versions of vector class library mixed
 #endif
 
@@ -55,7 +55,7 @@ protected:
     __m128 y0;                         // low half
     __m128 y1;                         // high half
 public:
-    Vec256fe(void) {};                 // default constructor
+    Vec256fe() = default;              // default constructor
     Vec256fe(__m128 x0, __m128 x1) {   // constructor to build from two __m128
         y0 = x0;  y1 = x1;
     }
@@ -70,7 +70,7 @@ public:
 // base class to replace __m256d when AVX is not supported
 class Vec256de {
 public:
-    Vec256de() {};                     // default constructor
+    Vec256de() = default;              // default constructor
     Vec256de(__m128d x0, __m128d x1) { // constructor to build from two __m128d
         y0 = x0;  y1 = x1;
     }
@@ -118,8 +118,7 @@ static inline Vec256de selectd (Vec256de const s, Vec256de const a, Vec256de con
 class Vec8fb : public Vec256fe {
 public:
     // Default constructor:
-    Vec8fb() {
-    }
+    Vec8fb() = default;
     // Constructor to build from all elements:
     Vec8fb(bool b0, bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7) {
         y0 = Vec4fb(b0, b1, b2, b3);
@@ -306,8 +305,7 @@ static inline bool horizontal_or (Vec8fb const a) {
 class Vec4db : public Vec256de {
 public:
     // Default constructor:
-    Vec4db() {
-    }
+    Vec4db() = default;
     // Constructor to build from all elements:
     Vec4db(bool b0, bool b1, bool b2, bool b3) {
         y0 = Vec2db(b0, b1);
@@ -494,8 +492,7 @@ static inline bool horizontal_or (Vec4db const a) {
 class Vec8f : public Vec256fe {
 public:
     // Default constructor:
-    Vec8f() {
-    }
+    Vec8f() = default;
     // Constructor to broadcast the same value into all elements:
     Vec8f(float f) {
         y1 = y0 = _mm_set1_ps(f);
@@ -1064,7 +1061,7 @@ static inline Vec8f infinite8f() {
 }
 
 // Function nan4f: returns a vector where all elements are +NAN (quiet)
-static inline Vec8f nan8f(int n = 0x10) {
+static inline Vec8f nan8f(uint32_t n = 0x10) {
     return Vec8f(nan4f(n), nan4f(n));
 }
 
@@ -1088,8 +1085,7 @@ inline Vec8f change_sign(Vec8f const a) {
 class Vec4d : public Vec256de {
 public:
     // Default constructor:
-    Vec4d() {
-    }
+    Vec4d() = default;
     // Constructor to broadcast the same value into all elements:
     Vec4d(double d) {
         y1 = y0 = _mm_set1_pd(d);
@@ -1684,7 +1680,7 @@ static inline Vec4d infinite4d() {
 }
 
 // Function nan2d: returns a vector where all elements are +NAN (quiet)
-static inline Vec4d nan4d(int n = 0x10) {
+static inline Vec4d nan4d(uint32_t n = 0x10) {
     return Vec4d(nan2d(n), nan2d(n));
 }
 
@@ -1741,6 +1737,21 @@ static inline Vec256de reinterpret_d (Vec256de const x) {
     return x;
 }
 
+// extend vectors to double size by adding zeroes
+static inline Vec8f extend_z(Vec4f a) {
+    return Vec8f(a, _mm_setzero_ps());
+}
+static inline Vec4d extend_z(Vec2d a) {
+    return Vec4d(a, _mm_setzero_pd());
+}
+
+static inline Vec8fb extend_z(Vec4fb a) {
+    return Vec8fb(a, Vec4fb(false));
+}
+static inline Vec4db extend_z(Vec2db a) {
+    return Vec4db(a, Vec2db(false));
+}
+
 
 /*****************************************************************************
 *
@@ -1816,7 +1827,10 @@ static inline Vec8f lookup(Vec8i const index, float const * table) {
     }
     // Limit index
     Vec8ui index1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        index1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         index1 = Vec8ui(index) & (n-1);
     }
@@ -1845,7 +1859,10 @@ static inline Vec4d lookup(Vec4q const index, double const * table) {
     }
     // Limit index
     Vec8ui index1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        index1 = Vec8ui(index);
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         index1 = Vec8ui(index) & Vec8ui(n-1, 0, n-1, 0, n-1, 0, n-1, 0);
     }
diff --git a/LGhost/VCL2/vectorf512.h b/LGhost/VCL2/vectorf512.h
index ea6d7b3..ce4e283 100644
--- a/LGhost/VCL2/vectorf512.h
+++ b/LGhost/VCL2/vectorf512.h
@@ -1,8 +1,8 @@
 /****************************  vectorf512.h   *******************************
 * Author:        Agner Fog
 * Date created:  2014-07-23
-* Last modified: 2020-03-26
-* Version:       2.01.02
+* Last modified: 2023-07-04
+* Version:       2.02.02
 * Project:       vector class library
 * Description:
 * Header file defining 512-bit floating point vector classes
@@ -18,7 +18,7 @@
 * Each vector object is represented internally in the CPU a 512-bit register.
 * This header file defines operators and functions for these vectors.
 *
-* (c) Copyright 2014-2020 Agner Fog.
+* (c) Copyright 2014-2023 Agner Fog.
 * Apache License version 2.0 or later.
 *****************************************************************************/
 
@@ -29,7 +29,7 @@
 #include "vectorclass.h"
 #endif
 
-#if VECTORCLASS_H < 20100
+#if VECTORCLASS_H < 20200
 #error Incompatible versions of vector class library mixed
 #endif
 
@@ -56,16 +56,16 @@ typedef Vec8b  Vec8db;
 
 #if INSTRSET == 9  // special cases of mixed compact and broad vectors
 inline Vec16b::Vec16b(Vec8ib const x0, Vec8ib const x1) {
-    mm = to_bits(x0) | uint16_t(to_bits(x1) << 8);
+    mm = uint16_t(to_bits(x0) | uint16_t(to_bits(x1) << 8));
 }
 inline Vec16b::Vec16b(Vec8fb const x0, Vec8fb const x1) {
-    mm = to_bits(x0) | uint16_t(to_bits(x1) << 8);
+    mm = uint16_t(to_bits(x0) | uint16_t(to_bits(x1) << 8));
 }
 inline Vec8b::Vec8b(Vec4qb const x0, Vec4qb const x1) {
-    mm = to_bits(x0) | (to_bits(x1) << 4);
+    mm = Vec8b_masktype(to_bits(x0) | (to_bits(x1) << 4));  // see definition of Vec8b_masktype in vectori128.h
 }
 inline Vec8b::Vec8b(Vec4db const x0, Vec4db const x1) {
-    mm = to_bits(x0) | (to_bits(x1) << 4);
+    mm = Vec8b_masktype(to_bits(x0) | (to_bits(x1) << 4));
 }
 
 inline Vec8ib Vec16b::get_low() const {
@@ -75,10 +75,10 @@ inline Vec8ib Vec16b::get_high() const {
     return Vec8ib().load_bits(uint8_t((uint16_t)mm >> 8u));
 }
 inline Vec4qb Vec8b::get_low() const {
-    return Vec4qb().load_bits(mm & 0xF);
+    return Vec4qb().load_bits(uint8_t(mm & 0xF));
 }
 inline Vec4qb Vec8b::get_high() const {
-    return Vec4qb().load_bits(mm >> 4u);
+    return Vec4qb().load_bits(uint8_t(mm >> 4u));
 }
 
 #endif
@@ -95,8 +95,7 @@ protected:
     __m512 zmm; // Float vector
 public:
     // Default constructor:
-    Vec16f() {
-    }
+    Vec16f() = default;
     // Constructor to broadcast the same value into all elements:
     Vec16f(float f) {
         zmm = _mm512_set1_ps(f);
@@ -336,12 +335,12 @@ static inline Vec16fb operator <= (Vec16f const a, Vec16f const b) {
 
 // vector operator > : returns true for elements for which a > b
 static inline Vec16fb operator > (Vec16f const a, Vec16f const b) {
-    return _mm512_cmp_ps_mask(a, b, 6);
+    return _mm512_cmp_ps_mask(a, b, 6+8);
 }
 
 // vector operator >= : returns true for elements for which a >= b
 static inline Vec16fb operator >= (Vec16f const a, Vec16f const b) {
-    return _mm512_cmp_ps_mask(a, b, 5);
+    return _mm512_cmp_ps_mask(a, b, 5+8);
 }
 
 // Bitwise logical operators
@@ -399,10 +398,6 @@ static inline Vec16fb operator ! (Vec16f const a) {
 *
 *****************************************************************************/
 
-static inline Vec16f zero_16f() {
-    return _mm512_setzero_ps();
-}
-
 // Select between two operands. Corresponds to this pseudocode:
 // for (int i = 0; i < 8; i++) result[i] = s[i] ? a[i] : b[i];
 static inline Vec16f select (Vec16fb const s, Vec16f const a, Vec16f const b) {
@@ -451,7 +446,7 @@ static inline Vec16f sign_combine(Vec16f const a, Vec16f const b) {
 
 // Categorization functions
 
-// Function is_finite: gives true for elements that are normal, denormal or zero,
+// Function is_finite: gives true for elements that are normal, subnormal or zero,
 // false for INF and NAN
 // (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
 static inline Vec16fb is_finite(Vec16f const a) {
@@ -508,7 +503,7 @@ static inline Vec16fb is_nan(Vec16f const a) {
 #endif
 
 
-// Function is_subnormal: gives true for elements that are denormal (subnormal)
+// Function is_subnormal: gives true for elements that are subnormal
 // false for finite numbers, zero, NAN and INF
 static inline Vec16fb is_subnormal(Vec16f const a) {
 #if INSTRSET >= 10  // __AVX512DQ__
@@ -523,7 +518,7 @@ static inline Vec16fb is_subnormal(Vec16f const a) {
 #endif
 }
 
-// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal (denormal)
+// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal
 // false for finite numbers, NAN and INF
 static inline Vec16fb is_zero_or_subnormal(Vec16f const a) {
 #if INSTRSET >= 10  // __AVX512DQ__
@@ -660,14 +655,6 @@ static inline Vec16f approx_recipr(Vec16f const a) {
 #endif
 }
 
-// Newton-Raphson refined approximate reciprocal (23 bit precision)
-static inline Vec16f rcp_nr(Vec16f const a) {
-    Vec16f nr = _mm512_rcp14_ps(a);
-    Vec16f muls = nr * nr * a;
-    Vec16f dbl = nr + nr;
-    return dbl - muls;
-}
-
 // approximate reciprocal squareroot (Faster than 1.f / sqrt(a).
 // Relative accuracy better than 2^-11 without AVX512, 2^-14 with AVX512F, full precision with AVX512ER)
 static inline Vec16f approx_rsqrt(Vec16f const a) {
@@ -728,7 +715,7 @@ static inline Vec16f fraction(Vec16f const a) {
 // n  =    0 gives 1.0f
 // n >=  128 gives +INF
 // n <= -127 gives 0.0f
-// This function will never produce denormals, and never raise exceptions
+// This function will never produce subnormals, and never raise exceptions
 static inline Vec16f exp2(Vec16i const n) {
     Vec16i t1 = max(n,  -0x7F);         // limit to allowed range
     Vec16i t2 = min(t1,  0x80);
@@ -750,8 +737,7 @@ protected:
     __m512d zmm; // double vector
 public:
     // Default constructor:
-    Vec8d() {
-    }
+    Vec8d() = default;
     // Constructor to broadcast the same value into all elements:
     Vec8d(double d) {
         zmm = _mm512_set1_pd(d);
@@ -994,12 +980,12 @@ static inline Vec8db operator <= (Vec8d const a, Vec8d const b) {
 
 // vector operator > : returns true for elements for which a > b
 static inline Vec8db operator > (Vec8d const a, Vec8d const b) {
-    return _mm512_cmp_pd_mask(a, b, 6);
+    return _mm512_cmp_pd_mask(a, b, 6+8);
 }
 
 // vector operator >= : returns true for elements for which a >= b
 static inline Vec8db operator >= (Vec8d const a, Vec8d const b) {
-    return _mm512_cmp_pd_mask(a, b, 5);
+    return _mm512_cmp_pd_mask(a, b, 5+8);
 }
 
 // Bitwise logical operators
@@ -1103,7 +1089,7 @@ static inline Vec8d sign_combine(Vec8d const a, Vec8d const b) {
 
 // Categorization functions
 
-// Function is_finite: gives true for elements that are normal, denormal or zero,
+// Function is_finite: gives true for elements that are normal, subnormal or zero,
 // false for INF and NAN
 static inline Vec8db is_finite(Vec8d const a) {
 #if INSTRSET >= 10 // __AVX512DQ__
@@ -1159,7 +1145,7 @@ static inline Vec8db is_nan(Vec8d const a) {
 #endif
 
 
-// Function is_subnormal: gives true for elements that are denormal (subnormal)
+// Function is_subnormal: gives true for elements that are subnormal
 // false for finite numbers, zero, NAN and INF
 static inline Vec8db is_subnormal(Vec8d const a) {
 #if INSTRSET >= 10  // __AVX512DQ__
@@ -1174,7 +1160,7 @@ static inline Vec8db is_subnormal(Vec8d const a) {
 #endif
 }
 
-// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal (denormal)
+// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal
 // false for finite numbers, NAN and INF
 static inline Vec8db is_zero_or_subnormal(Vec8d const a) {
 #if INSTRSET >= 10  // __AVX512DQ__
@@ -1414,7 +1400,7 @@ static inline Vec8d fraction(Vec8d const a) {
 // n  =     0 gives 1.0
 // n >=  1024 gives +INF
 // n <= -1023 gives 0.0
-// This function will never produce denormals, and never raise exceptions
+// This function will never produce subnormals, and never raise exceptions
 static inline Vec8d exp2(Vec8q const n) {
     Vec8q t1 = max(n,  -0x3FF);        // limit to allowed range
     Vec8q t2 = min(t1,  0x400);
@@ -1470,13 +1456,31 @@ static inline __m512d reinterpret_d (__m512d const x) {
     return x;
 }
 
+#if defined(__GNUC__) && __GNUC__ <= 9 // GCC v. 9 is missing the _mm512_zextps256_ps512 intrinsic
+// extend vectors to double size by adding zeroes
+static inline Vec16f extend_z(Vec8f a) {
+    return Vec16f(a, Vec8f(0));
+}
+static inline Vec8d extend_z(Vec4d a) {
+    return Vec8d(a, Vec4d(0));
+}
+#else
+// extend vectors to double size by adding zeroes
+static inline Vec16f extend_z(Vec8f a) {
+    return _mm512_zextps256_ps512(a);
+}
+static inline Vec8d extend_z(Vec4d a) {
+    return _mm512_zextpd256_pd512(a);
+}
+#endif
+
 // Function infinite4f: returns a vector where all elements are +INF
 static inline Vec16f infinite16f() {
     return reinterpret_f(Vec16i(0x7F800000));
 }
 
 // Function nan4f: returns a vector where all elements are +NAN (quiet)
-static inline Vec16f nan16f(int n = 0x100) {
+static inline Vec16f nan16f(uint32_t n = 0x100) {
     return nan_vec<Vec16f>(n);
 }
 
@@ -1486,7 +1490,7 @@ static inline Vec8d infinite8d() {
 }
 
 // Function nan8d: returns a vector where all elements are +NAN (quiet NAN)
-static inline Vec8d nan8d(int n = 0x10) {
+static inline Vec8d nan8d(uint32_t n = 0x10) {
     return nan_vec<Vec8d>(n);
 }
 
@@ -1559,7 +1563,7 @@ static inline Vec8d permute8(Vec8d const a) {
                     return _mm512_permutevar_pd(a, pmask);
                 }
                 else { // with zeroing. pshufb may be marginally better because it needs no extra zero mask
-                    const EList <int8_t, 64> bm = pshufb_mask<Vec8q>(indexs);
+                    constexpr EList <int8_t, 64> bm = pshufb_mask<Vec8q>(indexs);
                     return _mm512_castsi512_pd(_mm512_shuffle_epi8(_mm512_castpd_si512(y), Vec8q().load(bm.a)));
                 }
             }
@@ -1641,7 +1645,7 @@ static inline Vec16f permute16(Vec16f const a) {
                     return _mm512_permutevar_ps(a, pmask);
                 }
                 else { // with zeroing. pshufb may be marginally better because it needs no extra zero mask
-                    const EList <int8_t, 64> bm = pshufb_mask<Vec16i>(indexs);
+                    constexpr EList <int8_t, 64> bm = pshufb_mask<Vec16i>(indexs);
                     return _mm512_castsi512_ps(_mm512_shuffle_epi8(_mm512_castps_si512(a), Vec16i().load(bm.a)));
                 }
             }
@@ -1698,7 +1702,7 @@ static inline Vec8d blend8(Vec8d const a, Vec8d const b) {
             y = _mm512_shuffle_f64x2(b, a, shuf);
         }
         else {
-            const EList <int64_t, 8> bm = perm_mask_broad<Vec8q>(indexs);
+            constexpr EList <int64_t, 8> bm = perm_mask_broad<Vec8q>(indexs);
             y = _mm512_permutex2var_pd(a, Vec8q().load(bm.a), b);
         }
     }
@@ -1722,7 +1726,7 @@ static inline Vec8d blend8(Vec8d const a, Vec8d const b) {
         y = _mm512_shuffle_pd(b, a, uint8_t(flags >> blend_shufpattern));
     }
     else { // No special cases
-        const EList <int64_t, 8> bm = perm_mask_broad<Vec8q>(indexs);
+        constexpr EList <int64_t, 8> bm = perm_mask_broad<Vec8q>(indexs);
         y = _mm512_permutex2var_pd(a, Vec8q().load(bm.a), b);
     }
     if constexpr ((flags & blend_zeroing) != 0) {          // additional zeroing needed
@@ -1806,7 +1810,7 @@ static inline Vec16f blend16(Vec16f const a, Vec16f const b) {
         }
     }
     else { // No special cases
-        const EList <int32_t, 16> bm = perm_mask_broad<Vec16i>(indexs);
+        constexpr EList <int32_t, 16> bm = perm_mask_broad<Vec16i>(indexs);
         y = _mm512_permutex2var_ps(a, Vec16i().load(bm.a), b);
     }
     if constexpr ((flags & blend_zeroing) != 0) {          // additional zeroing needed
diff --git a/LGhost/VCL2/vectorf512e.h b/LGhost/VCL2/vectorf512e.h
index 66c1aaf..dec7dd5 100644
--- a/LGhost/VCL2/vectorf512e.h
+++ b/LGhost/VCL2/vectorf512e.h
@@ -1,8 +1,8 @@
 /****************************  vectorf512.h   *******************************
 * Author:        Agner Fog
 * Date created:  2014-07-23
-* Last modified: 2020-03-26
-* Version:       2.01.02
+* Last modified: 2023-07-04
+* Version:       2.02.02
 * Project:       vector class library
 * Description:
 * Header file defining 512-bit floating point vector classes
@@ -19,7 +19,7 @@
 * Each vector object is represented internally in the CPU as two 256-bit registers.
 * This header file defines operators and functions for these vectors.
 *
-* (c) Copyright 2014-2020 Agner Fog.
+* (c) Copyright 2014-2023 Agner Fog.
 * Apache License version 2.0 or later.
 *****************************************************************************/
 
@@ -30,7 +30,7 @@
 #include "vectorclass.h"
 #endif
 
-#if VECTORCLASS_H < 20100
+#if VECTORCLASS_H < 20200
 #error Incompatible versions of vector class library mixed
 #endif
 
@@ -52,8 +52,7 @@ namespace VCL_NAMESPACE {
 class Vec16fb : public Vec16b {
 public:
     // Default constructor:
-    Vec16fb () {
-    }
+    Vec16fb () = default;
     // Constructor to build from all elements:
     Vec16fb(bool x0, bool x1, bool x2, bool x3, bool x4, bool x5, bool x6, bool x7,
         bool x8, bool x9, bool x10, bool x11, bool x12, bool x13, bool x14, bool x15) :
@@ -171,8 +170,7 @@ static inline Vec16fb & operator ^= (Vec16fb & a, Vec16fb const b) {
 class Vec8db : public Vec512b {
 public:
     // Default constructor:
-    Vec8db () {
-    }
+    Vec8db () = default;
     // Constructor to build from all elements:
     Vec8db(bool x0, bool x1, bool x2, bool x3, bool x4, bool x5, bool x6, bool x7) {
         z0 = Vec4qb(x0, x1, x2, x3);
@@ -323,8 +321,7 @@ protected:
     Vec8f z1;
 public:
     // Default constructor:
-    Vec16f() {
-    }
+    Vec16f() = default;
     // Constructor to broadcast the same value into all elements:
     Vec16f(float f) {
         z0 = z1 = Vec8f(f);
@@ -933,7 +930,7 @@ static inline Vec16f infinite16f() {
 }
 
 // Function nan4f: returns a vector where all elements are +NAN (quiet)
-static inline Vec16f nan16f(int n = 0x10) {
+static inline Vec16f nan16f(uint32_t n = 0x10) {
     Vec8f nan = nan8f(n);
     return Vec16f(nan, nan);
 }
@@ -960,8 +957,7 @@ protected:
     Vec4d z1;
 public:
     // Default constructor:
-    Vec8d() {
-    }
+    Vec8d() = default;
     // Constructor to broadcast the same value into all elements:
     Vec8d(double d) {
         z0 = z1 = Vec4d(d);
@@ -1585,7 +1581,7 @@ static inline Vec8d infinite8d() {
 }
 
 // Function nan8d: returns a vector where all elements are +NAN (quiet NAN)
-static inline Vec8d nan8d(int n = 0x10) {
+static inline Vec8d nan8d(uint32_t n = 0x10) {
     Vec4d nan = nan4d(n);
     return Vec8d(nan, nan);
 }
@@ -1640,6 +1636,20 @@ static inline Vec8d reinterpret_d (Vec8d const x) {
     return x;
 }
 
+// extend vectors to double size by adding zeroes
+static inline Vec16f extend_z(Vec8f a) {
+    return Vec16f(a, Vec8f(0));
+}
+static inline Vec8d extend_z(Vec4d a) {
+    return Vec8d(a, Vec4d(0));
+} 
+static inline Vec16fb extend_z(Vec8fb a) {
+    return Vec16fb(a, Vec8fb(false));
+}
+static inline Vec8db extend_z(Vec4db a) {
+    return Vec8db(a, Vec4db(false));
+} 
+
 
 /*****************************************************************************
 *
diff --git a/LGhost/VCL2/vectorfp16.h b/LGhost/VCL2/vectorfp16.h
new file mode 100644
index 0000000..6178ef7
--- /dev/null
+++ b/LGhost/VCL2/vectorfp16.h
@@ -0,0 +1,2672 @@
+/****************************  vectorfp16.h   *******************************
+* Author:        Agner Fog
+* Date created:  2022-05-03
+* Last modified: 2023-11-07
+* Version:       2.02.02
+* Project:       vector class library
+* Description:
+* Header file defining half precision floating point vector classes
+* Instruction sets AVX512_FP16 and AVX512VL required
+*
+* Instructions: see vcl_manual.pdf
+*
+* The following vector classes are defined here:
+* Vec8h     Vector of  8 half precision floating point numbers in 128 bit vector
+* Vec16h    Vector of 16 half precision floating point numbers in 256 bit vector
+* Vec32h    Vector of 32 half precision floating point numbers in 512 bit vector
+*
+* This header file defines operators and functions for these vectors.
+*
+* You need a compiler supporting the AVX512_FP16 instruction to compile for this.
+* This code works with the following compilers:
+* clang++ version 14.0
+* g++ version 12.1 with binutils version 2.34
+* Intel c++ compiler version 2022.0
+*
+* (c) Copyright 2012-2023 Agner Fog.
+* Apache License version 2.0 or later.
+*****************************************************************************/
+
+#ifndef VECTORFP16_H
+#define VECTORFP16_H
+
+#ifndef VECTORCLASS_H
+#include "vectorclass.h"
+#endif
+
+#if VECTORCLASS_H < 20200
+#error Incompatible versions of vector class library mixed
+#endif
+
+#if INSTRSET < 10 || !defined(__AVX512FP16__)
+// half precision instructions not supported. Use emulation
+#include "vectorfp16e.h"
+#else
+
+#ifdef VCL_NAMESPACE
+namespace VCL_NAMESPACE {
+#endif
+
+// type Float16 emulates _Float16 in vectorfp16e.h if _Float16 not defined
+#ifdef __STDCPP_FLOAT16_T__
+typedef std::float16_t Float16; 
+#else
+typedef _Float16 Float16;
+#endif
+
+
+/*****************************************************************************
+*
+*          Vec8hb: Vector of 8 Booleans for use with Vec8h
+*
+*****************************************************************************/
+
+typedef Vec8b Vec8hb;  // compact boolean vector
+
+
+/*****************************************************************************
+*
+*          Vec8h: Vector of 8 half precision floating point values
+*
+*****************************************************************************/
+
+class Vec8h {
+protected:
+    __m128h xmm; // Float vector
+public:
+    // Default constructor:
+    Vec8h() = default;
+    // Constructor to broadcast the same value into all elements:
+    Vec8h(_Float16 f) {
+        xmm = _mm_set1_ph (f);
+    }
+    // Constructor to build from all elements:
+    Vec8h(_Float16 f0, _Float16 f1, _Float16 f2, _Float16 f3, _Float16 f4, _Float16 f5, _Float16 f6, _Float16 f7) {
+        xmm = _mm_setr_ph (f0, f1, f2, f3, f4, f5, f6, f7);
+    }
+    // Constructor to convert from type __m128 used in intrinsics:
+    Vec8h(__m128h const x) {
+        xmm = x;
+    }
+    // Assignment operator to convert from type __m128 used in intrinsics:
+    Vec8h & operator = (__m128h const x) {
+        xmm = x;
+        return *this;
+    }
+    // Type cast operator to convert to __m128 used in intrinsics
+    operator __m128h() const {
+        return xmm;
+    }
+    // Member function to load from array (unaligned)
+    Vec8h & load(void const * p) {
+        xmm = _mm_loadu_ph (p);
+        return *this;
+    }
+    // Member function to load from array, aligned by 16
+    // You may use load_a instead of load if you are certain that p points to an address
+    // divisible by 16. In most cases there is no difference in speed between load and load_a
+    Vec8h & load_a(void const * p) {
+        xmm = _mm_load_ph (p);
+        return *this;
+    }
+    // Member function to store into array (unaligned)
+    void store(void * p) const {
+        _mm_storeu_ph (p, xmm);
+    }
+    // Member function storing into array, aligned by 16
+    // You may use store_a instead of store if you are certain that p points to an address
+    // divisible by 16.
+    void store_a(void * p) const {
+        _mm_store_ph (p, xmm);
+    }
+    // Member function storing to aligned uncached memory (non-temporal store).
+    // This may be more efficient than store_a when storing large blocks of memory if it 
+    // is unlikely that the data will stay in the cache until it is read again.
+    // Note: Will generate runtime error if p is not aligned by 16
+    void store_nt(void * p) const {
+        _mm_stream_ps((float*)p, _mm_castph_ps(xmm));
+    }
+    // Partial load. Load n elements and set the rest to 0
+    Vec8h & load_partial(int n, void const * p) {
+        xmm = _mm_castsi128_ph(_mm_maskz_loadu_epi16(__mmask8((1u << n) - 1), p));
+        return *this;
+    }
+    // Partial store. Store n elements
+    void store_partial(int n, void * p) const {
+        _mm_mask_storeu_epi16(p, __mmask8((1u << n) - 1), _mm_castph_si128(xmm));
+    }
+    // cut off vector to n elements. The last 8-n elements are set to zero
+    Vec8h & cutoff(int n) {
+        xmm = _mm_castsi128_ph(_mm_maskz_mov_epi16(__mmask8((1u << n) - 1), _mm_castph_si128(xmm)));
+        return *this;
+    }
+    // Member function to change a single element in vector
+    Vec8h const insert(int index, _Float16 a) {
+        __m128h aa = _mm_set1_ph (a);
+        xmm = _mm_castsi128_ph(_mm_mask_mov_epi16(_mm_castph_si128(xmm), __mmask8(1u << index), _mm_castph_si128(aa)));
+        return *this;
+    }
+    // Member function extract a single element from vector
+    _Float16 extract(int index) const {
+#if INSTRSET >= 10 && defined (__AVX512VBMI2__)
+        __m128i x = _mm_maskz_compress_epi16(__mmask8(1u << index), _mm_castph_si128(xmm));
+        return _mm_cvtsh_h(_mm_castsi128_ph(x));
+#elif 0
+        union {
+            __m128h v;
+            _Float16 f[8];
+        } y;
+        y.v = xmm;
+        return y.f[index & 7];
+#else
+        Vec4ui x = _mm_maskz_compress_epi32(__mmask8(1u << (index >> 1)), _mm_castph_si128(xmm));  // extract int32_t
+        x >>= (index & 1) << 4;  // get upper 16 bits if index odd
+        return _mm_cvtsh_h(_mm_castsi128_ph(x));
+#endif
+    }
+    // Extract a single element. Use store function if extracting more than one element.
+    // Operator [] can only read an element, not write.
+    _Float16 operator [] (int index) const {
+        return extract(index);
+    }
+    static constexpr int size() {
+        return 8;
+    }
+    static constexpr int elementtype() {
+        return 15;
+    }
+    typedef __m128h registertype;
+};
+
+
+/*****************************************************************************
+*
+*          Operators for Vec8h
+*
+*****************************************************************************/
+
+// vector operator + : add element by element
+static inline Vec8h operator + (Vec8h const a, Vec8h const b) {
+    return _mm_add_ph(a, b);
+}
+
+// vector operator + : add vector and scalar
+static inline Vec8h operator + (Vec8h const a, _Float16 b) {
+    return a + Vec8h(b);
+}
+static inline Vec8h operator + (_Float16 a, Vec8h const b) {
+    return Vec8h(a) + b;
+}
+
+// vector operator += : add
+static inline Vec8h & operator += (Vec8h & a, Vec8h const b) {
+    a = a + b;
+    return a;
+}
+
+// postfix operator ++
+static inline Vec8h operator ++ (Vec8h & a, int) {
+    Vec8h a0 = a;
+    a = a + _Float16(1); // 1.0f16 not supported by g++ version 12.1
+    return a0;
+}
+
+// prefix operator ++
+static inline Vec8h & operator ++ (Vec8h & a) {
+    a = a +  _Float16(1);
+    return a;
+}
+
+// vector operator - : subtract element by element
+static inline Vec8h operator - (Vec8h const a, Vec8h const b) {
+    return _mm_sub_ph(a, b);
+}
+
+// vector operator - : subtract vector and scalar
+static inline Vec8h operator - (Vec8h const a, _Float16 b) {
+    return a - Vec8h(b);
+}
+static inline Vec8h operator - (_Float16 a, Vec8h const b) {
+    return Vec8h(a) - b;
+}
+
+// vector operator - : unary minus
+// Change sign bit, even for 0, INF and NAN
+static inline Vec8h operator - (Vec8h const a) {
+    return _mm_castps_ph(_mm_xor_ps(_mm_castph_ps(a), _mm_castsi128_ps(_mm_set1_epi32(0x80008000))));
+}
+
+// vector operator -= : subtract
+static inline Vec8h & operator -= (Vec8h & a, Vec8h const b) {
+    a = a - b;
+    return a;
+}
+
+// postfix operator --
+static inline Vec8h operator -- (Vec8h & a, int) {
+    Vec8h a0 = a;
+    a = a -  _Float16(1);
+    return a0;
+}
+
+// prefix operator --
+static inline Vec8h & operator -- (Vec8h & a) {
+    a = a -  _Float16(1);
+    return a;
+}
+
+// vector operator * : multiply element by element
+static inline Vec8h operator * (Vec8h const a, Vec8h const b) {
+    return _mm_mul_ph(a, b);
+}
+
+// vector operator * : multiply vector and scalar
+static inline Vec8h operator * (Vec8h const a, _Float16 b) {
+    return a * Vec8h(b);
+}
+static inline Vec8h operator * (_Float16 a, Vec8h const b) {
+    return Vec8h(a) * b;
+}
+
+// vector operator *= : multiply
+static inline Vec8h & operator *= (Vec8h & a, Vec8h const b) {
+    a = a * b;
+    return a;
+}
+
+// vector operator / : divide all elements by same integer
+static inline Vec8h operator / (Vec8h const a, Vec8h const b) {
+    return _mm_div_ph(a, b);
+}
+
+// vector operator / : divide vector and scalar
+static inline Vec8h operator / (Vec8h const a, _Float16 b) {
+    return a / Vec8h(b);
+}
+static inline Vec8h operator / (_Float16 a, Vec8h const b) {
+    return Vec8h(a) / b;
+}
+
+// vector operator /= : divide
+static inline Vec8h & operator /= (Vec8h & a, Vec8h const b) {
+    a = a / b;
+    return a;
+}
+
+// vector operator == : returns true for elements for which a == b
+static inline Vec8hb operator == (Vec8h const a, Vec8h const b) {
+    return _mm_cmp_ph_mask(a, b, 0);
+}
+
+// vector operator != : returns true for elements for which a != b
+static inline Vec8hb operator != (Vec8h const a, Vec8h const b) {
+    return _mm_cmp_ph_mask(a, b, 4);
+}
+
+// vector operator < : returns true for elements for which a < b
+static inline Vec8hb operator < (Vec8h const a, Vec8h const b) {
+    return _mm_cmp_ph_mask(a, b, 1);
+}
+
+// vector operator <= : returns true for elements for which a <= b
+static inline Vec8hb operator <= (Vec8h const a, Vec8h const b) {
+    return _mm_cmp_ph_mask(a, b, 2);
+}
+
+// vector operator > : returns true for elements for which a > b
+static inline Vec8hb operator > (Vec8h const a, Vec8h const b) {
+    return _mm_cmp_ph_mask(a, b, 6+8);
+}
+
+// vector operator >= : returns true for elements for which a >= b
+static inline Vec8hb operator >= (Vec8h const a, Vec8h const b) {
+    return _mm_cmp_ph_mask(a, b, 5+8);
+}
+
+// Bitwise logical operators
+
+// vector operator & : bitwise and
+static inline Vec8h operator & (Vec8h const a, Vec8h const b) {
+    return _mm_castps_ph(_mm_and_ps(_mm_castph_ps(a), _mm_castph_ps(b)));
+}
+
+// vector operator &= : bitwise and
+static inline Vec8h & operator &= (Vec8h & a, Vec8h const b) {
+    a = a & b;
+    return a;
+}
+
+// vector operator & : bitwise and of Vec8h and Vec8hb
+static inline Vec8h operator & (Vec8h const a, Vec8hb const b) {
+    return _mm_castsi128_ph(_mm_maskz_mov_epi16(b, _mm_castph_si128(a)));
+}
+static inline Vec8h operator & (Vec8hb const a, Vec8h const b) {
+    return b & a;
+}
+
+// vector operator | : bitwise or
+static inline Vec8h operator | (Vec8h const a, Vec8h const b) {
+    return _mm_castps_ph(_mm_or_ps(_mm_castph_ps(a), _mm_castph_ps(b)));
+}
+
+// vector operator |= : bitwise or
+static inline Vec8h & operator |= (Vec8h & a, Vec8h const b) {
+    a = a | b;
+    return a;
+}
+
+// vector operator ^ : bitwise xor
+static inline Vec8h operator ^ (Vec8h const a, Vec8h const b) {
+    return _mm_castps_ph(_mm_xor_ps(_mm_castph_ps(a), _mm_castph_ps(b)));
+}
+
+// vector operator ^= : bitwise xor
+static inline Vec8h & operator ^= (Vec8h & a, Vec8h const b) {
+    a = a ^ b;
+    return a;
+}
+
+// vector operator ! : logical not. Returns Boolean vector
+static inline Vec8hb operator ! (Vec8h const a) {
+    return a == Vec8h(0.0);
+}
+
+
+/*****************************************************************************
+*
+*          Functions for Vec8h
+*
+*****************************************************************************/
+
+// Select between two operands. Corresponds to this pseudocode:
+// for (int i = 0; i < 4; i++) result[i] = s[i] ? a[i] : b[i];
+static inline Vec8h select(Vec8hb const s, Vec8h const a, Vec8h const b) {
+    return _mm_castsi128_ph(_mm_mask_mov_epi16(_mm_castph_si128(b), s, _mm_castph_si128(a)));
+}
+
+// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]
+static inline Vec8h if_add(Vec8hb const f, Vec8h const a, Vec8h const b) {
+    return _mm_mask_add_ph (a, f, a, b);
+}
+
+// Conditional subtract: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]
+static inline Vec8h if_sub(Vec8hb const f, Vec8h const a, Vec8h const b) {
+    return _mm_mask_sub_ph (a, f, a, b);
+}
+
+// Conditional multiply: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]
+static inline Vec8h if_mul(Vec8hb const f, Vec8h const a, Vec8h const b) {
+    return _mm_mask_mul_ph (a, f, a, b);
+}
+
+// Conditional divide: For all vector elements i: result[i] = f[i] ? (a[i] / b[i]) : a[i]
+static inline Vec8h if_div(Vec8hb const f, Vec8h const a, Vec8h const b) {
+    return _mm_mask_div_ph (a, f, a, b);
+}
+
+// Sign functions
+
+// Function sign_bit: gives true for elements that have the sign bit set
+// even for -0.0f, -INF and -NAN
+// Note that sign_bit(Vec8h(-0.0f16)) gives true, while Vec8h(-0.0f16) < Vec8h(0.0f16) gives false
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec8hb sign_bit(Vec8h const a) {
+    Vec8s t1 = _mm_castph_si128(a);    // reinterpret as 16-bit integer
+    Vec8s t2 = t1 >> 15;               // extend sign bit
+    return t2 != 0;
+}
+
+// Function sign_combine: changes the sign of a when b has the sign bit set
+// same as select(sign_bit(b), -a, a)
+static inline Vec8h sign_combine(Vec8h const a, Vec8h const b) {
+    return a ^ (b & Vec8h(_Float16(-0.0)));
+}
+
+// Categorization functions
+
+// Function is_finite: gives true for elements that are normal, subnormal or zero,
+// false for INF and NAN
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec8hb is_finite(Vec8h const a) {
+    return __mmask8(_mm_fpclass_ph_mask(a, 0x99) ^ 0xFF);
+}
+
+// Function is_inf: gives true for elements that are +INF or -INF
+// false for finite numbers and NAN
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec8hb is_inf(Vec8h const a) {
+    return __mmask8(_mm_fpclass_ph_mask(a, 0x18));
+}
+
+// Function is_nan: gives true for elements that are +NAN or -NAN
+// false for finite numbers and +/-INF
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec8hb is_nan(Vec8h const a) {
+    // assume that compiler does not optimize this away with -ffinite-math-only:
+    return Vec4fb(_mm_fpclass_ph_mask(a, 0x81));
+}
+
+// Function is_subnormal: gives true for elements that are subnormal
+// false for finite numbers, zero, NAN and INF
+static inline Vec8hb is_subnormal(Vec8h const a) {
+    return Vec8hb(_mm_fpclass_ph_mask(a, 0x20));
+}
+
+// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal
+// false for finite numbers, NAN and INF
+static inline Vec8hb is_zero_or_subnormal(Vec8h const a) {
+    return Vec8hb(_mm_fpclass_ph_mask(a, 0x26));
+}
+
+// Function infinite8h: returns a vector where all elements are +INF
+static inline Vec8h infinite8h() {
+    return _mm_castsi128_ph(_mm_set1_epi16(0x7C00));
+}
+
+// template for producing quiet NAN
+template <>
+Vec8h nan_vec<Vec8h>(uint32_t payload) {
+    if constexpr (Vec8h::elementtype() == 15) {  // _Float16
+        union {
+            uint16_t i;
+            _Float16 f;
+        } uf;
+        uf.i = 0x7E00 | (payload & 0x01FF);
+        return Vec8h(uf.f);
+    }
+} 
+
+// Function nan8h: returns a vector where all elements are NAN (quiet)
+static inline Vec8h nan8h(uint32_t n = 0x10) {
+    return nan_vec<Vec8h>(n);
+}
+
+// This function returns the code hidden in a NAN. The sign bit is ignored
+static inline Vec8us nan_code(Vec8h const x) {
+    Vec8us a = Vec8us(_mm_castph_si128(x));
+    Vec8us const n = 0x3FF;
+    return select(is_nan(x), a & n, Vec8us(0));
+}
+
+
+// General arithmetic functions, etc.
+
+// Horizontal add: Calculates the sum of all vector elements.
+static inline _Float16 horizontal_add(Vec8h const a) {
+    //return _mm_reduce_add_ph(a);
+    __m128h b = _mm_castps_ph(_mm_movehl_ps(_mm_castph_ps(a), _mm_castph_ps(a)));
+    __m128h c = _mm_add_ph(a, b);
+    __m128h d = _mm_castps_ph(_mm_movehdup_ps( _mm_castph_ps(c)));    
+    __m128h e = _mm_add_ph(c, d);
+    __m128h f = _mm_castsi128_ph(_mm_shufflelo_epi16(_mm_castph_si128(e), 1));
+    __m128h g = _mm_add_sh(e, f);
+    return _mm_cvtsh_h(g);
+}
+
+#if MAX_VECTOR_SIZE >= 256
+// same, with high precision
+static inline float horizontal_add_x(Vec8h const a) {
+    //Vec8f b = _mm256_cvtph_ps(a); // declaration of _mm256_cvtph_ps has __m128i parameter because it was defined before __m128h was defined
+    Vec8f b = _mm256_cvtph_ps(_mm_castph_si128(a));
+    return horizontal_add(b);
+}
+#endif
+
+// function max: a > b ? a : b
+static inline Vec8h max(Vec8h const a, Vec8h const b) {
+    return _mm_max_ph(a, b);
+}
+
+// function min: a < b ? a : b
+static inline Vec8h min(Vec8h const a, Vec8h const b) {
+    return _mm_min_ph(a, b);
+}
+// NAN-safe versions of maximum and minimum are in vector_convert.h
+
+// function abs: absolute value
+static inline Vec8h abs(Vec8h const a) {
+    return _mm_abs_ph(a);
+}
+
+// function sqrt: square root
+static inline Vec8h sqrt(Vec8h const a) {
+    return _mm_sqrt_ph(a);
+}
+
+// function square: a * a
+static inline Vec8h square(Vec8h const a) {
+    return a * a;
+}
+
+// The purpose of this template is to prevent implicit conversion of a float
+// exponent to int when calling pow(vector, float) and vectormath_exp.h is not included
+template <typename TT> static Vec8h pow(Vec8h const a, TT const n);  // = delete
+
+// Raise floating point numbers to integer power n
+template <>
+inline Vec8h pow<int>(Vec8h const x0, int const n) {
+    return pow_template_i<Vec8h>(x0, n);
+}
+
+// allow conversion from unsigned int
+template <>
+inline Vec8h pow<uint32_t>(Vec8h const x0, uint32_t const n) {
+    return pow_template_i<Vec8h>(x0, (int)n);
+}
+
+// Raise floating point numbers to integer power n, where n is a compile-time constant:
+// Template in vectorf28.h is used
+//template <typename V, int n>
+//static inline V pow_n(V const a);
+
+// implement as function pow(vector, const_int)
+template <int n>
+static inline Vec8h pow(Vec8h const a, Const_int_t<n>) {
+    return pow_n<Vec8h, n>(a);
+}
+
+static inline Vec8h round(Vec8h const a) {
+    return _mm_roundscale_ph (a, 8);
+}
+
+// function truncate: round towards zero. (result as float vector)
+static inline Vec8h truncate(Vec8h const a) {
+    return _mm_roundscale_ph(a, 3 + 8);
+}
+
+// function floor: round towards minus infinity. (result as float vector)
+static inline Vec8h floor(Vec8h const a) {
+    return _mm_roundscale_ph(a, 1 + 8);
+}
+
+// function ceil: round towards plus infinity. (result as float vector)
+static inline Vec8h ceil(Vec8h const a) {
+    return _mm_roundscale_ph(a, 2 + 8);
+}
+
+// function roundi: round to nearest integer (even). (result as integer vector)
+static inline Vec8s roundi(Vec8h const a) {
+    // Note: assume MXCSR control register is set to rounding
+    return _mm_cvtph_epi16(a);
+}
+
+// function truncatei: round towards zero. (result as integer vector)
+static inline Vec8s truncatei(Vec8h const a) {
+    return _mm_cvttph_epi16(a);
+}
+
+// function to_float: convert integer vector to float vector
+static inline Vec8h to_float16(Vec8s const a) {
+    return _mm_cvtepi16_ph(a);
+}
+
+// function to_float: convert unsigned integer vector to float vector
+static inline Vec8h to_float16(Vec8us const a) {
+    return _mm_cvtepu16_ph(a);
+}
+
+// Approximate math functions
+
+// reciprocal (almost exact)
+static inline Vec8h approx_recipr(Vec8h const a) {
+    return _mm_rcp_ph (a);
+}
+
+// reciprocal squareroot (almost exact)
+static inline Vec8h approx_rsqrt(Vec8h const a) {
+    return _mm_rsqrt_ph(a);
+}
+
+// Fused multiply and add functions
+
+// Multiply and add. a*b+c
+static inline Vec8h mul_add(Vec8h const a, Vec8h const b, Vec8h const c) {
+    return _mm_fmadd_ph(a, b, c);
+}
+
+// Multiply and subtract. a*b-c
+static inline Vec8h mul_sub(Vec8h const a, Vec8h const b, Vec8h const c) {
+    return _mm_fmsub_ph(a, b, c);
+}
+
+// Multiply and inverse subtract
+static inline Vec8h nmul_add(Vec8h const a, Vec8h const b, Vec8h const c) {
+    return _mm_fnmadd_ph(a, b, c);
+}
+
+// Math functions using fast bit manipulation
+
+// Extract the exponent as an integer
+// exponent(a) = floor(log2(abs(a)));
+// exponent(1.0f) = 0, exponent(0.0f) = -127, exponent(INF) = +128, exponent(NAN) = +128
+static inline Vec8s exponent(Vec8h const a) {
+    Vec8us t1 = _mm_castph_si128(a);   // reinterpret as 16-bit integer
+    Vec8us t2 = t1 << 1;               // shift out sign bit
+    Vec8us t3 = t2 >> 11;              // shift down logical to position 0
+    Vec8s  t4 = Vec8s(t3) - 0x0F;      // subtract bias from exponent
+    return t4;
+}
+
+// Extract the fraction part of a floating point number
+// a = 2^exponent(a) * fraction(a), except for a = 0
+// fraction(1.0f) = 1.0f, fraction(5.0f) = 1.25f
+// NOTE: The name fraction clashes with an ENUM in MAC XCode CarbonCore script.h !
+static inline Vec8h fraction(Vec8h const a) {
+    return _mm_getmant_ph(a, _MM_MANT_NORM_1_2, _MM_MANT_SIGN_zero);
+}
+
+// Fast calculation of pow(2,n) with n integer
+// n  =    0 gives 1.0f
+// n >=  16 gives +INF
+// n <= -15 gives 0.0f
+// This function will never produce subnormals, and never raise exceptions
+static inline Vec8h exp2(Vec8s const n) {
+    Vec8s t1 = max(n, -15);            // limit to allowed range
+    Vec8s t2 = min(t1, 16);
+    Vec8s t3 = t2 + 15;                // add bias
+    Vec8s t4 = t3 << 10;               // put exponent into position 10
+    return _mm_castsi128_ph(t4);       // reinterpret as float
+}
+//static Vec8h exp2(Vec8h const x);    // defined in vectormath_exp.h ??
+
+
+// change signs on vectors Vec8h
+// Each index i0 - i7 is 1 for changing sign on the corresponding element, 0 for no change
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7>
+static inline Vec8h change_sign(Vec8h const a) {
+    if constexpr ((i0 | i1 | i2 | i3 | i4 | i5 | i6 | i7) == 0) return a;
+    __m128i mask = constant4ui<
+        (i0 ? 0x8000 : 0) | (i1 ? 0x80000000 : 0), 
+        (i2 ? 0x8000 : 0) | (i3 ? 0x80000000 : 0), 
+        (i4 ? 0x8000 : 0) | (i5 ? 0x80000000 : 0), 
+        (i6 ? 0x8000 : 0) | (i7 ? 0x80000000 : 0) >();
+    return  _mm_castps_ph(_mm_xor_ps(_mm_castph_ps(a), _mm_castsi128_ps(mask)));     // flip sign bits
+}
+
+/*****************************************************************************
+*
+*          conversion of precision
+*
+*****************************************************************************/
+
+// conversions Vec8h <-> Vec4f
+// extend precision: Vec8h -> Vec4f. upper half ignored
+static inline Vec4f convert8h_4f (Vec8h h) {
+    return _mm_cvtph_ps(_mm_castph_si128(h));
+}
+
+// reduce precision: Vec4f -> Vec8h. upper half zero
+static inline Vec8h convert4f_8h (Vec4f f) {
+    return _mm_castsi128_ph(_mm_cvtps_ph(f, 0));
+}
+
+#if MAX_VECTOR_SIZE >= 256
+// conversions Vec8h <-> Vec8f
+// extend precision: Vec8h -> Vec8f
+static inline Vec8f to_float (Vec8h h) {
+    return _mm256_cvtph_ps(_mm_castph_si128(h));
+}
+
+// reduce precision: Vec8f -> Vec8h
+static inline Vec8h to_float16 (Vec8f f) {
+    return _mm_castsi128_ph(_mm256_cvtps_ph(f, 0));
+} 
+#endif
+
+/*****************************************************************************
+*
+*          Functions for reinterpretation between vector types
+*
+*****************************************************************************/
+
+static inline __m128i reinterpret_i(__m128h const x) {
+    return _mm_castph_si128(x);
+}
+
+static inline __m128h  reinterpret_h(__m128i const x) {
+    return _mm_castsi128_ph(x);
+}
+
+static inline __m128  reinterpret_f(__m128h const x) {
+    return _mm_castph_ps(x);
+}
+
+static inline __m128d reinterpret_d(__m128h const x) {
+    return _mm_castph_pd(x);
+}
+
+
+
+
+/*****************************************************************************
+*
+*          Vector permute and blend functions
+*
+******************************************************************************
+*
+* The permute function can reorder the elements of a vector and optionally
+* set some elements to zero.
+*
+* See vectori128.h for details
+*
+*****************************************************************************/
+// permute vector Vec8h
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7>
+static inline Vec8h permute8(Vec8h const a) {
+    return _mm_castsi128_ph (permute8<i0, i1, i2, i3, i4, i5, i6, i7>(Vec8s(_mm_castph_si128(a))));
+}
+
+
+/*****************************************************************************
+*
+*          Vector blend functions
+*
+*****************************************************************************/
+
+// permute and blend Vec8h
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7>
+static inline Vec8h blend8(Vec8h const a, Vec8h const b) {
+    return _mm_castsi128_ph (blend8<i0, i1, i2, i3, i4, i5, i6, i7>(Vec8s(_mm_castph_si128(a)), Vec8s(_mm_castph_si128(b))));
+}
+
+
+/*****************************************************************************
+*
+*          Vector lookup functions
+*
+******************************************************************************
+*
+* These functions use vector elements as indexes into a table.
+* The table is given as one or more vectors or as an array.
+*
+*****************************************************************************/
+
+static inline Vec8h lookup8 (Vec8s const index, Vec8h const table) {
+    return _mm_castsi128_ph(lookup8(index, Vec8s(_mm_castph_si128(table))));
+}
+
+static inline Vec8h lookup16(Vec8s const index, Vec8h const table0, Vec8h const table1) {
+    return _mm_castsi128_ph(lookup16(index, Vec8s(_mm_castph_si128(table0)), Vec8s(_mm_castph_si128(table1))));
+}
+
+template <int n>
+static inline Vec8h lookup(Vec8s const index, void const * table) {
+    return _mm_castsi128_ph(lookup<n>(index, (void const *)(table)));
+}
+
+
+/*****************************************************************************
+*
+*          256 bit vectors
+*
+*****************************************************************************/
+
+#if MAX_VECTOR_SIZE >= 256
+
+
+/*****************************************************************************
+*
+*          Vec16hb: Vector of 16 Booleans for use with Vec16h
+*
+*****************************************************************************/
+
+typedef Vec16b Vec16hb;  // compact boolean vector
+
+
+/*****************************************************************************
+*
+*          Vec16h: Vector of 16 half precision floating point values
+*
+*****************************************************************************/
+
+class Vec16h {
+protected:
+    __m256h ymm; // Float vector
+public:
+    // Default constructor:
+    Vec16h() = default;
+    // Constructor to broadcast the same value into all elements:
+    Vec16h(_Float16 f) {
+        ymm = _mm256_set1_ph (f);
+    }
+    // Constructor to build from all elements:
+    Vec16h(_Float16 f0, _Float16 f1, _Float16 f2, _Float16 f3, _Float16 f4, _Float16 f5, _Float16 f6, _Float16 f7,
+    _Float16 f8, _Float16 f9, _Float16 f10, _Float16 f11, _Float16 f12, _Float16 f13, _Float16 f14, _Float16 f15) {
+        ymm = _mm256_setr_ph (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15);
+    }
+    // Constructor to build from two Vec8h:
+    Vec16h(Vec8h const a0, Vec8h const a1) {     
+        ymm = _mm256_castps_ph(_mm256_insertf128_ps(_mm256_castps128_ps256(_mm_castph_ps(a0)),_mm_castph_ps(a1),1));
+    }
+    // Constructor to convert from type __m256h used in intrinsics:
+    Vec16h(__m256h const x) {
+        ymm = x;
+    }
+    // Assignment operator to convert from type __m256h used in intrinsics:
+    Vec16h & operator = (__m256h const x) {
+        ymm = x;
+        return *this;
+    }
+    // Type cast operator to convert to __m256h used in intrinsics
+    operator __m256h() const {
+        return ymm;
+    }
+    // Member function to load from array (unaligned)
+    Vec16h & load(void const * p) {
+        ymm = _mm256_loadu_ph (p);
+        return *this;
+    }
+    // Member function to load from array, aligned by 32
+    // You may use load_a instead of load if you are certain that p points to an address
+    // divisible by 32. In most cases there is no difference in speed between load and load_a
+    Vec16h & load_a(void const * p) {
+        ymm = _mm256_load_ph (p);
+        return *this;
+    }
+    // Member function to store into array (unaligned)
+    void store(void * p) const {
+        _mm256_storeu_ph (p, ymm);
+    }
+    // Member function storing into array, aligned by 32
+    // You may use store_a instead of store if you are certain that p points to an address
+    // divisible by 32.
+    void store_a(void * p) const {
+        _mm256_store_ph (p, ymm);
+    }
+    // Member function storing to aligned uncached memory (non-temporal store).
+    // This may be more efficient than store_a when storing large blocks of memory if it 
+    // is unlikely that the data will stay in the cache until it is read again.
+    // Note: Will generate runtime error if p is not aligned by 32
+    void store_nt(void * p) const {
+        _mm256_stream_ps((float*)p, _mm256_castph_ps(ymm));
+    }
+    // Partial load. Load n elements and set the rest to 0
+    Vec16h & load_partial(int n, void const * p) {
+        ymm = _mm256_castsi256_ph(_mm256_maskz_loadu_epi16(__mmask16((1u << n) - 1), p));
+        return *this;
+    }
+    // Partial store. Store n elements
+    void store_partial(int n, void * p) const {
+        _mm256_mask_storeu_epi16(p, __mmask16((1u << n) - 1), _mm256_castph_si256(ymm));
+    }
+    // cut off vector to n elements. The last 8-n elements are set to zero
+    Vec16h & cutoff(int n) {
+        ymm = _mm256_castsi256_ph(_mm256_maskz_mov_epi16(__mmask16((1u << n) - 1), _mm256_castph_si256(ymm)));
+        return *this;
+    }
+    // Member function to change a single element in vector
+    Vec16h const insert(int index, _Float16 a) {
+        __m256h aa = _mm256_set1_ph (a);
+        ymm = _mm256_castsi256_ph(_mm256_mask_mov_epi16(_mm256_castph_si256(ymm), __mmask16(1u << index), _mm256_castph_si256(aa)));
+        return *this;
+    }
+    // Member function extract a single element from vector
+    _Float16 extract(int index) const {
+#if INSTRSET >= 10 && defined (__AVX512VBMI2__)
+        __m256i x = _mm256_maskz_compress_epi16(__mmask16(1u << index), _mm256_castph_si256(ymm));
+        return _mm256_cvtsh_h(_mm256_castsi256_ph(x));
+#elif 0
+        union {
+            __m256h v;
+            _Float16 f[16];
+        } y;
+        y.v = ymm;
+        return y.f[index & 15];
+#else
+        Vec8ui x = _mm256_maskz_compress_epi32(__mmask16(1u << (index >> 1)), _mm256_castph_si256(ymm));  // extract int32_t
+        x >>= uint32_t((index & 1) << 4);  // get upper 16 bits if index odd
+        return _mm256_cvtsh_h(_mm256_castsi256_ph(x));
+#endif
+    }
+    // Extract a single element. Use store function if extracting more than one element.
+    // Operator [] can only read an element, not write.
+    _Float16 operator [] (int index) const {
+        return extract(index);
+    }
+    Vec8h get_low() const {
+        return _mm256_castph256_ph128(ymm);
+    }
+    Vec8h get_high() const {
+        return _mm_castps_ph(_mm256_extractf128_ps(_mm256_castph_ps(ymm),1));
+    }
+    static constexpr int size() {
+        return 16;
+    }
+    static constexpr int elementtype() {
+        return 15;
+    }
+    typedef __m256h registertype;
+};
+
+
+/*****************************************************************************
+*
+*          Operators for Vec16h
+*
+*****************************************************************************/
+
+// vector operator + : add element by element
+static inline Vec16h operator + (Vec16h const a, Vec16h const b) {
+    return _mm256_add_ph(a, b);
+}
+
+// vector operator + : add vector and scalar
+static inline Vec16h operator + (Vec16h const a, _Float16 b) {
+    return a + Vec16h(b);
+}
+static inline Vec16h operator + (_Float16 a, Vec16h const b) {
+    return Vec16h(a) + b;
+}
+
+// vector operator += : add
+static inline Vec16h & operator += (Vec16h & a, Vec16h const b) {
+    a = a + b;
+    return a;
+}
+
+// postfix operator ++
+static inline Vec16h operator ++ (Vec16h & a, int) {
+    Vec16h a0 = a;
+    a = a +  _Float16(1);
+    return a0;
+}
+
+// prefix operator ++
+static inline Vec16h & operator ++ (Vec16h & a) {
+    a = a +  _Float16(1);
+    return a;
+}
+
+// vector operator - : subtract element by element
+static inline Vec16h operator - (Vec16h const a, Vec16h const b) {
+    return _mm256_sub_ph(a, b);
+}
+
+// vector operator - : subtract vector and scalar
+static inline Vec16h operator - (Vec16h const a, float b) {
+    return a - Vec16h(b);
+}
+static inline Vec16h operator - (float a, Vec16h const b) {
+    return Vec16h(a) - b;
+}
+
+// vector operator - : unary minus
+// Change sign bit, even for 0, INF and NAN
+static inline Vec16h operator - (Vec16h const a) {
+    return _mm256_castps_ph(_mm256_xor_ps(_mm256_castph_ps(a), _mm256_castsi256_ps(_mm256_set1_epi32(0x80008000))));
+}
+
+// vector operator -= : subtract
+static inline Vec16h & operator -= (Vec16h & a, Vec16h const b) {
+    a = a - b;
+    return a;
+}
+
+// postfix operator --
+static inline Vec16h operator -- (Vec16h & a, int) {
+    Vec16h a0 = a;
+    a = a -  _Float16(1);
+    return a0;
+}
+
+// prefix operator --
+static inline Vec16h & operator -- (Vec16h & a) {
+    a = a -  _Float16(1);
+    return a;
+}
+
+// vector operator * : multiply element by element
+static inline Vec16h operator * (Vec16h const a, Vec16h const b) {
+    return _mm256_mul_ph(a, b);
+}
+
+// vector operator * : multiply vector and scalar
+static inline Vec16h operator * (Vec16h const a, _Float16 b) {
+    return a * Vec16h(b);
+}
+static inline Vec16h operator * (_Float16 a, Vec16h const b) {
+    return Vec16h(a) * b;
+}
+
+// vector operator *= : multiply
+static inline Vec16h & operator *= (Vec16h & a, Vec16h const b) {
+    a = a * b;
+    return a;
+}
+
+// vector operator / : divide all elements by same integer
+static inline Vec16h operator / (Vec16h const a, Vec16h const b) {
+    return _mm256_div_ph(a, b);
+}
+
+// vector operator / : divide vector and scalar
+static inline Vec16h operator / (Vec16h const a, _Float16 b) {
+    return a / Vec16h(b);
+}
+static inline Vec16h operator / (_Float16 a, Vec16h const b) {
+    return Vec16h(a) / b;
+}
+
+// vector operator /= : divide
+static inline Vec16h & operator /= (Vec16h & a, Vec16h const b) {
+    a = a / b;
+    return a;
+}
+
+// vector operator == : returns true for elements for which a == b
+static inline Vec16hb operator == (Vec16h const a, Vec16h const b) {
+    return _mm256_cmp_ph_mask(a, b, 0);
+}
+
+// vector operator != : returns true for elements for which a != b
+static inline Vec16hb operator != (Vec16h const a, Vec16h const b) {
+    return _mm256_cmp_ph_mask(a, b, 4);
+}
+
+// vector operator < : returns true for elements for which a < b
+static inline Vec16hb operator < (Vec16h const a, Vec16h const b) {
+    return _mm256_cmp_ph_mask(a, b, 1);
+}
+
+// vector operator <= : returns true for elements for which a <= b
+static inline Vec16hb operator <= (Vec16h const a, Vec16h const b) {
+    return _mm256_cmp_ph_mask(a, b, 2);
+}
+
+// vector operator > : returns true for elements for which a > b
+static inline Vec16hb operator > (Vec16h const a, Vec16h const b) {
+    return _mm256_cmp_ph_mask(a, b, 6+8);
+}
+
+// vector operator >= : returns true for elements for which a >= b
+static inline Vec16hb operator >= (Vec16h const a, Vec16h const b) {
+    return _mm256_cmp_ph_mask(a, b, 5+8);
+}
+
+// Bitwise logical operators
+
+// vector operator & : bitwise and
+static inline Vec16h operator & (Vec16h const a, Vec16h const b) {
+    return _mm256_castps_ph(_mm256_and_ps(_mm256_castph_ps(a), _mm256_castph_ps(b)));
+}
+
+// vector operator &= : bitwise and
+static inline Vec16h & operator &= (Vec16h & a, Vec16h const b) {
+    a = a & b;
+    return a;
+}
+
+// vector operator & : bitwise and of Vec16h and Vec16hb
+static inline Vec16h operator & (Vec16h const a, Vec16hb const b) {
+    return _mm256_castsi256_ph(_mm256_maskz_mov_epi16(b, _mm256_castph_si256(a)));
+}
+static inline Vec16h operator & (Vec16hb const a, Vec16h const b) {
+    return b & a;
+}
+
+// vector operator | : bitwise or
+static inline Vec16h operator | (Vec16h const a, Vec16h const b) {
+    return _mm256_castps_ph(_mm256_or_ps(_mm256_castph_ps(a), _mm256_castph_ps(b)));
+}
+
+// vector operator |= : bitwise or
+static inline Vec16h & operator |= (Vec16h & a, Vec16h const b) {
+    a = a | b;
+    return a;
+}
+
+// vector operator ^ : bitwise xor
+static inline Vec16h operator ^ (Vec16h const a, Vec16h const b) {
+    return _mm256_castps_ph(_mm256_xor_ps(_mm256_castph_ps(a), _mm256_castph_ps(b)));
+}
+
+// vector operator ^= : bitwise xor
+static inline Vec16h & operator ^= (Vec16h & a, Vec16h const b) {
+    a = a ^ b;
+    return a;
+}
+
+// vector operator ! : logical not. Returns Boolean vector
+static inline Vec16hb operator ! (Vec16h const a) {
+    return a == Vec16h(0.0);
+}
+
+
+/*****************************************************************************
+*
+*          Functions for Vec16h
+*
+*****************************************************************************/
+
+// Select between two operands. Corresponds to this pseudocode:
+// for (int i = 0; i < 4; i++) result[i] = s[i] ? a[i] : b[i];
+static inline Vec16h select(Vec16hb const s, Vec16h const a, Vec16h const b) {
+    return _mm256_castsi256_ph(_mm256_mask_mov_epi16(_mm256_castph_si256(b), s, _mm256_castph_si256(a)));
+}
+
+// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]
+static inline Vec16h if_add(Vec16hb const f, Vec16h const a, Vec16h const b) {
+    return _mm256_mask_add_ph (a, f, a, b);
+}
+
+// Conditional subtract: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]
+static inline Vec16h if_sub(Vec16hb const f, Vec16h const a, Vec16h const b) {
+    return _mm256_mask_sub_ph (a, f, a, b);
+}
+
+// Conditional multiply: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]
+static inline Vec16h if_mul(Vec16hb const f, Vec16h const a, Vec16h const b) {
+    return _mm256_mask_mul_ph (a, f, a, b);
+}
+
+// Conditional divide: For all vector elements i: result[i] = f[i] ? (a[i] / b[i]) : a[i]
+static inline Vec16h if_div(Vec16hb const f, Vec16h const a, Vec16h const b) {
+    return _mm256_mask_div_ph (a, f, a, b);
+}
+
+// Sign functions
+
+// Function sign_bit: gives true for elements that have the sign bit set
+// even for -0.0f, -INF and -NAN
+// Note that sign_bit(Vec16h(-0.0f16)) gives true, while Vec16h(-0.0f16) < Vec16h(0.0f16) gives false
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec16hb sign_bit(Vec16h const a) {
+    Vec16s t1 = _mm256_castph_si256(a);    // reinterpret as 16-bit integer
+    Vec16s t2 = t1 >> 15;                  // extend sign bit
+    return t2 != 0;
+}
+
+// Function sign_combine: changes the sign of a when b has the sign bit set
+// same as select(sign_bit(b), -a, a)
+static inline Vec16h sign_combine(Vec16h const a, Vec16h const b) {
+    return a ^ (b & Vec16h(_Float16(-0.0)));
+}
+
+// Categorization functions
+
+// Function is_finite: gives true for elements that are normal, subnormal or zero,
+// false for INF and NAN
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec16hb is_finite(Vec16h const a) {
+    return __mmask16(_mm256_fpclass_ph_mask(a, 0x99) ^ 0xFFFF);
+}
+
+// Function is_inf: gives true for elements that are +INF or -INF
+// false for finite numbers and NAN
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec16hb is_inf(Vec16h const a) {
+    return __mmask16(_mm256_fpclass_ph_mask(a, 0x18));
+}
+
+// Function is_nan: gives true for elements that are +NAN or -NAN
+// false for finite numbers and +/-INF
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec16hb is_nan(Vec16h const a) {
+    // assume that compiler does not optimize this away with -ffinite-math-only:
+    return Vec16sb(_mm256_fpclass_ph_mask(a, 0x81));
+}
+
+// Function is_subnormal: gives true for elements that are subnormal
+// false for finite numbers, zero, NAN and INF
+static inline Vec16hb is_subnormal(Vec16h const a) {
+    return Vec16hb(_mm256_fpclass_ph_mask(a, 0x20));
+}
+
+// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal
+// false for finite numbers, NAN and INF
+static inline Vec16hb is_zero_or_subnormal(Vec16h const a) {
+    return Vec16hb(_mm256_fpclass_ph_mask(a, 0x26));
+}
+
+// Function infinite16h: returns a vector where all elements are +INF
+static inline Vec16h infinite16h() {
+    return _mm256_castsi256_ph(_mm256_set1_epi16(0x7C00));
+}
+
+// template for producing quiet NAN
+template <>
+Vec16h nan_vec<Vec16h>(uint32_t payload) {
+    if constexpr (Vec16h::elementtype() == 15) {  // _Float16
+        union {
+            uint16_t i;
+            _Float16 f;
+        } uf;
+        uf.i = 0x7E00 | (payload & 0x01FF);
+        return Vec16h(uf.f);
+    }
+} 
+
+// Function nan16h: returns a vector where all elements are NAN (quiet)
+static inline Vec16h nan16h(uint32_t n = 0x10) {
+    return nan_vec<Vec16h>(n);
+}
+
+// This function returns the code hidden in a NAN. The sign bit is ignored
+static inline Vec16us nan_code(Vec16h const x) {
+    Vec16us a = Vec16us(_mm256_castph_si256(x));
+    Vec16us const n = 0x3FF;
+    return select(is_nan(x), a & n, Vec16us(0));
+}
+
+
+// General arithmetic functions, etc.
+
+// Horizontal add: Calculates the sum of all vector elements.
+static inline _Float16 horizontal_add(Vec16h const a) {
+    return horizontal_add(a.get_low()+a.get_high());
+}
+#if MAX_VECTOR_SIZE >= 512
+// same, with high precision
+static inline float horizontal_add_x(Vec16h const a) {
+    Vec16f b =  _mm512_cvtph_ps(_mm256_castph_si256(a));
+    return horizontal_add(b);
+}
+#endif
+
+// function max: a > b ? a : b
+static inline Vec16h max(Vec16h const a, Vec16h const b) {
+    return _mm256_max_ph(a, b);
+}
+
+// function min: a < b ? a : b
+static inline Vec16h min(Vec16h const a, Vec16h const b) {
+    return _mm256_min_ph(a, b);
+}
+// NAN-safe versions of maximum and minimum are in vector_convert.h
+
+// function abs: absolute value
+static inline Vec16h abs(Vec16h const a) {
+    return _mm256_abs_ph(a);
+}
+
+// function sqrt: square root
+static inline Vec16h sqrt(Vec16h const a) {
+    return _mm256_sqrt_ph(a);
+}
+
+// function square: a * a
+static inline Vec16h square(Vec16h const a) {
+    return a * a;
+}
+
+// The purpose of this template is to prevent implicit conversion of a float
+// exponent to int when calling pow(vector, float) and vectormath_exp.h is not included
+template <typename TT> static Vec16h pow(Vec16h const a, TT const n);  // = delete
+
+// Raise floating point numbers to integer power n
+template <>
+inline Vec16h pow<int>(Vec16h const x0, int const n) {
+    return pow_template_i<Vec16h>(x0, n);
+}
+
+// allow conversion from unsigned int
+template <>
+inline Vec16h pow<uint32_t>(Vec16h const x0, uint32_t const n) {
+    return pow_template_i<Vec16h>(x0, (int)n);
+}
+
+// Raise floating point numbers to integer power n, where n is a compile-time constant:
+// Template in vectorf28.h is used
+//template <typename V, int n>
+//static inline V pow_n(V const a);
+
+// implement as function pow(vector, const_int)
+template <int n>
+Vec16h pow(Vec16h const a, Const_int_t<n>) {
+    return pow_n<Vec16h, n>(a);
+}
+
+
+static inline Vec16h round(Vec16h const a) {
+    return _mm256_roundscale_ph (a, 8);
+}
+
+// function truncate: round towards zero. (result as float vector)
+static inline Vec16h truncate(Vec16h const a) {
+    return _mm256_roundscale_ph(a, 3 + 8);
+}
+
+// function floor: round towards minus infinity. (result as float vector)
+static inline Vec16h floor(Vec16h const a) {
+    return _mm256_roundscale_ph(a, 1 + 8);
+}
+
+// function ceil: round towards plus infinity. (result as float vector)
+static inline Vec16h ceil(Vec16h const a) {
+    return _mm256_roundscale_ph(a, 2 + 8);
+}
+
+// function roundi: round to nearest integer (even). (result as integer vector)
+static inline Vec16s roundi(Vec16h const a) {
+    // Note: assume MXCSR control register is set to rounding
+    return _mm256_cvtph_epi16(a);
+}
+
+// function truncatei: round towards zero. (result as integer vector)
+static inline Vec16s truncatei(Vec16h const a) {
+    return _mm256_cvttph_epi16(a);
+}
+
+// function to_float: convert integer vector to float vector
+static inline Vec16h to_float16(Vec16s const a) {
+    return _mm256_cvtepi16_ph(a);
+}
+
+// function to_float: convert unsigned integer vector to float vector
+static inline Vec16h to_float16(Vec16us const a) {
+    return _mm256_cvtepu16_ph(a);
+}
+
+// Approximate math functions
+
+// reciprocal (almost exact)
+static inline Vec16h approx_recipr(Vec16h const a) {
+    return _mm256_rcp_ph (a);
+}
+
+// reciprocal squareroot (almost exact)
+static inline Vec16h approx_rsqrt(Vec16h const a) {
+    return _mm256_rsqrt_ph(a);
+}
+
+// Fused multiply and add functions
+
+// Multiply and add. a*b+c
+static inline Vec16h mul_add(Vec16h const a, Vec16h const b, Vec16h const c) {
+    return _mm256_fmadd_ph(a, b, c);
+}
+
+// Multiply and subtract. a*b-c
+static inline Vec16h mul_sub(Vec16h const a, Vec16h const b, Vec16h const c) {
+    return _mm256_fmsub_ph(a, b, c);
+}
+
+// Multiply and inverse subtract
+static inline Vec16h nmul_add(Vec16h const a, Vec16h const b, Vec16h const c) {
+    return _mm256_fnmadd_ph(a, b, c);
+}
+
+// Math functions using fast bit manipulation
+
+// Extract the exponent as an integer
+// exponent(a) = floor(log2(abs(a)));
+// exponent(1.0f) = 0, exponent(0.0f) = -127, exponent(INF) = +128, exponent(NAN) = +128
+static inline Vec16s exponent(Vec16h const a) {
+    Vec16us t1 = _mm256_castph_si256(a);   // reinterpret as 16-bit integer
+    Vec16us t2 = t1 << 1;                  // shift out sign bit
+    Vec16us t3 = t2 >> 11;                 // shift down logical to position 0
+    Vec16s  t4 = Vec16s(t3) - 0x0F;        // subtract bias from exponent
+    return t4;
+}
+
+// Extract the fraction part of a floating point number
+// a = 2^exponent(a) * fraction(a), except for a = 0
+// fraction(1.0f) = 1.0f, fraction(5.0f) = 1.25f
+// NOTE: The name fraction clashes with an ENUM in MAC XCode CarbonCore script.h !
+static inline Vec16h fraction(Vec16h const a) {
+    return _mm256_getmant_ph(a, _MM_MANT_NORM_1_2, _MM_MANT_SIGN_zero);
+}
+
+// Fast calculation of pow(2,n) with n integer
+// n  =    0 gives 1.0f
+// n >=  16 gives +INF
+// n <= -15 gives 0.0f
+// This function will never produce subnormals, and never raise exceptions
+static inline Vec16h exp2(Vec16s const n) {
+    Vec16s t1 = max(n, -15);            // limit to allowed range
+    Vec16s t2 = min(t1, 16);
+    Vec16s t3 = t2 + 15;                // add bias
+    Vec16s t4 = t3 << 10;               // put exponent into position 10
+    return _mm256_castsi256_ph(t4);     // reinterpret as float
+}
+//static Vec16h exp2(Vec16h const x);    // defined in vectormath_exp.h ??
+
+
+// change signs on vectors Vec16h
+// Each index i0 - i15 is 1 for changing sign on the corresponding element, 0 for no change
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, 
+int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15>
+Vec16h change_sign(Vec16h const a) {
+    if constexpr ((i0 | i1 | i2 | i3 | i4 | i5 | i6 | i7 | i8 | i9 | i10 | i11 | i12 | i13 | i14 | i15) == 0) return a;
+    __m256i mask = constant8ui<
+        (i0  ? 0x8000 : 0) | (i1  ? 0x80000000 : 0), 
+        (i2  ? 0x8000 : 0) | (i3  ? 0x80000000 : 0), 
+        (i4  ? 0x8000 : 0) | (i5  ? 0x80000000 : 0), 
+        (i6  ? 0x8000 : 0) | (i7  ? 0x80000000 : 0), 
+        (i8  ? 0x8000 : 0) | (i9  ? 0x80000000 : 0), 
+        (i10 ? 0x8000 : 0) | (i11 ? 0x80000000 : 0), 
+        (i12 ? 0x8000 : 0) | (i13 ? 0x80000000 : 0), 
+        (i14 ? 0x8000 : 0) | (i15 ? 0x80000000 : 0) >();
+    return  _mm256_castps_ph(_mm256_xor_ps(_mm256_castph_ps(a), _mm256_castsi256_ps(mask)));     // flip sign bits
+}
+
+/*****************************************************************************
+*
+*          conversions Vec16h <-> Vec16f
+*
+*****************************************************************************/
+#if MAX_VECTOR_SIZE >= 512
+// extend precision: Vec8h -> Vec8f
+static inline Vec16f to_float (Vec16h h) {
+    return _mm512_cvtph_ps(_mm256_castph_si256(h));
+}
+
+// reduce precision: Vec8f -> Vec8h
+static inline Vec16h to_float16 (Vec16f f) {
+    return _mm256_castsi256_ph(_mm512_cvtps_ph(f, 0));
+}
+#endif
+
+/*****************************************************************************
+*
+*          Functions for reinterpretation between vector types
+*
+*****************************************************************************/
+
+static inline __m256i reinterpret_i(__m256h const x) {
+    return _mm256_castph_si256(x);
+}
+
+static inline __m256h reinterpret_h(__m256i const x) {
+    return _mm256_castsi256_ph(x);
+}
+
+static inline __m256  reinterpret_f(__m256h const x) {
+    return _mm256_castph_ps(x);
+}
+
+static inline __m256d reinterpret_d(__m256h const x) {
+    return _mm256_castph_pd(x);
+}
+
+static inline Vec16h extend_z(Vec8h a) {
+    //return _mm256_zextsi128_si256(a);
+    return _mm256_zextph128_ph256(a);
+}
+
+
+/*****************************************************************************
+*
+*          Vector permute and blend functions
+*
+******************************************************************************
+*
+* The permute function can reorder the elements of a vector and optionally
+* set some elements to zero.
+*
+* See vectori128.h for details
+*
+*****************************************************************************/
+// permute vector Vec16h
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, 
+int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15>
+Vec16h permute16(Vec16h const a) {
+    return _mm256_castsi256_ph (
+    permute16<i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15> (
+    Vec16s(_mm256_castph_si256(a))));
+}
+
+
+/*****************************************************************************
+*
+*          Vector blend functions
+*
+*****************************************************************************/
+
+// permute and blend Vec16h
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, 
+int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15>
+Vec16h blend16(Vec16h const a, Vec16h const b) {
+    return _mm256_castsi256_ph (
+    blend16<i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15> (
+    Vec16s(_mm256_castph_si256(a)), Vec16s(_mm256_castph_si256(b))));
+}
+
+
+/*****************************************************************************
+*
+*          Vector lookup functions
+*
+******************************************************************************
+*
+* These functions use vector elements as indexes into a table.
+* The table is given as one or more vectors or as an array.
+*
+*****************************************************************************/
+
+static inline Vec16h lookup16 (Vec16s const index, Vec16h const table) {
+    return _mm256_castsi256_ph(lookup16(index, Vec16s(_mm256_castph_si256(table))));
+}
+
+template <int n>
+Vec16h lookup(Vec16s const index, void const * table) {
+    return _mm256_castsi256_ph(lookup<n>(index, (void const *)(table)));
+}
+
+
+#endif // MAX_VECTOR_SIZE >= 256
+
+
+
+/*****************************************************************************
+*
+*          512 bit vectors
+*
+*****************************************************************************/
+
+#if MAX_VECTOR_SIZE >= 512
+
+
+/*****************************************************************************
+*
+*          Vec32hb: Vector of 32 Booleans for use with Vec32h
+*
+*****************************************************************************/
+
+typedef Vec32b Vec32hb;  // compact boolean vector
+
+
+/*****************************************************************************
+*
+*          Vec32h: Vector of 32 half precision floating point values
+*
+*****************************************************************************/
+
+class Vec32h {
+protected:
+    __m512h zmm; // Float vector
+public:
+    // Default constructor:
+    Vec32h() = default;
+    // Constructor to broadcast the same value into all elements:
+    Vec32h(_Float16 f) {
+        zmm = _mm512_set1_ph (f);
+    }
+    // Constructor to build from all elements:
+    Vec32h(_Float16 f0, _Float16 f1, _Float16 f2, _Float16 f3, _Float16 f4, _Float16 f5, _Float16 f6, _Float16 f7,
+    _Float16 f8, _Float16 f9, _Float16 f10, _Float16 f11, _Float16 f12, _Float16 f13, _Float16 f14, _Float16 f15,
+    _Float16 f16, _Float16 f17, _Float16 f18, _Float16 f19, _Float16 f20, _Float16 f21, _Float16 f22, _Float16 f23,
+    _Float16 f24, _Float16 f25, _Float16 f26, _Float16 f27, _Float16 f28, _Float16 f29, _Float16 f30, _Float16 f31) {
+        zmm = _mm512_setr_ph (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15,
+        f16, f17, f18, f19, f20, f21, f22, f23, f24, f25, f26, f27, f28, f29, f30, f31);
+    }
+    // Constructor to build from two Vec16h:
+    Vec32h(Vec16h const a0, Vec16h const a1) {     
+        zmm = _mm512_castps_ph(_mm512_insertf32x8(_mm512_castps256_ps512(_mm256_castph_ps(a0)),_mm256_castph_ps(a1),1));
+    }
+    // Constructor to convert from type __m512h used in intrinsics:
+    Vec32h(__m512h const x) {
+        zmm = x;
+    }
+    // Assignment operator to convert from type __m512h used in intrinsics:
+    Vec32h & operator = (__m512h const x) {
+        zmm = x;
+        return *this;
+    }
+    // Type cast operator to convert to __m512h used in intrinsics
+    operator __m512h() const {
+        return zmm;
+    }
+    // Member function to load from array (unaligned)
+    Vec32h & load(void const * p) {
+        zmm = _mm512_loadu_ph (p);
+        return *this;
+    }
+    // Member function to load from array, aligned by 64
+    // You may use load_a instead of load if you are certain that p points to an address
+    // divisible by 64. In most cases there is no difference in speed between load and load_a
+    Vec32h & load_a(void const * p) {
+        zmm = _mm512_load_ph (p);
+        return *this;
+    }
+    // Member function to store into array (unaligned)
+    void store(void * p) const {
+        _mm512_storeu_ph (p, zmm);
+    }
+    // Member function storing into array, aligned by 64
+    // You may use store_a instead of store if you are certain that p points to an address
+    // divisible by 64.
+    void store_a(void * p) const {
+        _mm512_store_ph (p, zmm);
+    }
+    // Member function storing to aligned uncached memory (non-temporal store).
+    // This may be more efficient than store_a when storing large blocks of memory if it 
+    // is unlikely that the data will stay in the cache until it is read again.
+    // Note: Will generate runtime error if p is not aligned by 64
+    void store_nt(void * p) const {
+        _mm512_stream_ps((float*)p, _mm512_castph_ps(zmm));
+    }
+    // Partial load. Load n elements and set the rest to 0
+    Vec32h & load_partial(int n, void const * p) {
+        zmm = _mm512_castsi512_ph(_mm512_maskz_loadu_epi16(__mmask32((1u << n) - 1), p));
+        return *this;
+    }
+    // Partial store. Store n elements
+    void store_partial(int n, void * p) const {
+        _mm512_mask_storeu_epi16(p, __mmask32((1u << n) - 1), _mm512_castph_si512(zmm));
+    }
+    // cut off vector to n elements. The last 8-n elements are set to zero
+    Vec32h & cutoff(int n) {
+        zmm = _mm512_castsi512_ph(_mm512_maskz_mov_epi16(__mmask32((1u << n) - 1), _mm512_castph_si512(zmm)));
+        return *this;
+    }
+    // Member function to change a single element in vector
+    Vec32h const insert(int index, _Float16 a) {
+        __m512h aa = _mm512_set1_ph (a);
+        zmm = _mm512_castsi512_ph(_mm512_mask_mov_epi16(_mm512_castph_si512(zmm), __mmask32(1u << index), _mm512_castph_si512(aa)));
+        return *this;
+    }
+    // Member function extract a single element from vector
+    _Float16 extract(int index) const {
+#if INSTRSET >= 10 && defined (__AVX512VBMI2__)
+        __m512i x = _mm512_maskz_compress_epi16(__mmask32(1u << index), _mm512_castph_si512(zmm));
+        return _mm512_cvtsh_h(_mm512_castsi512_ph(x));
+#elif 0
+        union {
+            __m512h v;
+            _Float16 f[32];
+        } y;
+        y.v = zmm;
+        return y.f[index & 31];
+#else
+        Vec16ui x = _mm512_maskz_compress_epi32(__mmask16(1u << (index >> 1)), _mm512_castph_si512(zmm));  // extract int32_t
+        x >>= uint32_t((index & 1) << 4);  // get upper 16 bits if index odd
+        return _mm512_cvtsh_h(_mm512_castsi512_ph(x));
+#endif
+    }
+    // Extract a single element. Use store function if extracting more than one element.
+    // Operator [] can only read an element, not write.
+    _Float16 operator [] (int index) const {
+        return extract(index);
+    }
+    Vec16h get_low() const {
+        return _mm512_castph512_ph256(zmm);
+    }
+    Vec16h get_high() const {
+        return _mm256_castps_ph(_mm512_extractf32x8_ps(_mm512_castph_ps(zmm),1));
+    }
+    static constexpr int size() {
+        return 32;
+    }
+    static constexpr int elementtype() {
+        return 15;
+    }
+    typedef __m512h registertype;
+};
+
+
+/*****************************************************************************
+*
+*          Operators for Vec32h
+*
+*****************************************************************************/
+
+// vector operator + : add element by element
+static inline Vec32h operator + (Vec32h const a, Vec32h const b) {
+    return _mm512_add_ph(a, b);
+}
+
+// vector operator + : add vector and scalar
+static inline Vec32h operator + (Vec32h const a, _Float16 b) {
+    return a + Vec32h(b);
+}
+static inline Vec32h operator + (_Float16 a, Vec32h const b) {
+    return Vec32h(a) + b;
+}
+
+// vector operator += : add
+static inline Vec32h & operator += (Vec32h & a, Vec32h const b) {
+    a = a + b;
+    return a;
+}
+
+// postfix operator ++
+static inline Vec32h operator ++ (Vec32h & a, int) {
+    Vec32h a0 = a;
+    a = a +  _Float16(1);
+    return a0;
+}
+
+// prefix operator ++
+static inline Vec32h & operator ++ (Vec32h & a) {
+    a = a +  _Float16(1);
+    return a;
+}
+
+// vector operator - : subtract element by element
+static inline Vec32h operator - (Vec32h const a, Vec32h const b) {
+    return _mm512_sub_ph(a, b);
+}
+
+// vector operator - : subtract vector and scalar
+static inline Vec32h operator - (Vec32h const a, _Float16 b) {
+    return a - Vec32h(b);
+}
+static inline Vec32h operator - (_Float16 a, Vec32h const b) {
+    return Vec32h(a) - b;
+}
+
+// vector operator - : unary minus
+// Change sign bit, even for 0, INF and NAN
+static inline Vec32h operator - (Vec32h const a) {
+    return _mm512_castps_ph(_mm512_xor_ps(_mm512_castph_ps(a), _mm512_castsi512_ps(_mm512_set1_epi32(0x80008000))));
+}
+
+// vector operator -= : subtract
+static inline Vec32h & operator -= (Vec32h & a, Vec32h const b) {
+    a = a - b;
+    return a;
+}
+
+// postfix operator --
+static inline Vec32h operator -- (Vec32h & a, int) {
+    Vec32h a0 = a;
+    a = a -  _Float16(1);
+    return a0;
+}
+
+// prefix operator --
+static inline Vec32h & operator -- (Vec32h & a) {
+    a = a -  _Float16(1);
+    return a;
+}
+
+// vector operator * : multiply element by element
+static inline Vec32h operator * (Vec32h const a, Vec32h const b) {
+    return _mm512_mul_ph(a, b);
+}
+
+// vector operator * : multiply vector and scalar
+static inline Vec32h operator * (Vec32h const a, _Float16 b) {
+    return a * Vec32h(b);
+}
+static inline Vec32h operator * (_Float16 a, Vec32h const b) {
+    return Vec32h(a) * b;
+}
+
+// vector operator *= : multiply
+static inline Vec32h & operator *= (Vec32h & a, Vec32h const b) {
+    a = a * b;
+    return a;
+}
+
+// vector operator / : divide all elements by same integer
+static inline Vec32h operator / (Vec32h const a, Vec32h const b) {
+    return _mm512_div_ph(a, b);
+}
+
+// vector operator / : divide vector and scalar
+static inline Vec32h operator / (Vec32h const a, _Float16 b) {
+    return a / Vec32h(b);
+}
+static inline Vec32h operator / (_Float16 a, Vec32h const b) {
+    return Vec32h(a) / b;
+}
+
+// vector operator /= : divide
+static inline Vec32h & operator /= (Vec32h & a, Vec32h const b) {
+    a = a / b;
+    return a;
+}
+
+// vector operator == : returns true for elements for which a == b
+static inline Vec32hb operator == (Vec32h const a, Vec32h const b) {
+    return _mm512_cmp_ph_mask(a, b, 0);
+}
+
+// vector operator != : returns true for elements for which a != b
+static inline Vec32hb operator != (Vec32h const a, Vec32h const b) {
+    return _mm512_cmp_ph_mask(a, b, 4);
+}
+
+// vector operator < : returns true for elements for which a < b
+static inline Vec32hb operator < (Vec32h const a, Vec32h const b) {
+    return _mm512_cmp_ph_mask(a, b, 1);
+}
+
+// vector operator <= : returns true for elements for which a <= b
+static inline Vec32hb operator <= (Vec32h const a, Vec32h const b) {
+    return _mm512_cmp_ph_mask(a, b, 2);
+}
+
+// vector operator > : returns true for elements for which a > b
+static inline Vec32hb operator > (Vec32h const a, Vec32h const b) {
+    return _mm512_cmp_ph_mask(a, b, 6+8);
+}
+
+// vector operator >= : returns true for elements for which a >= b
+static inline Vec32hb operator >= (Vec32h const a, Vec32h const b) {
+    return _mm512_cmp_ph_mask(a, b, 5+8);
+}
+
+// Bitwise logical operators
+
+// vector operator & : bitwise and
+static inline Vec32h operator & (Vec32h const a, Vec32h const b) {
+    return _mm512_castps_ph(_mm512_and_ps(_mm512_castph_ps(a), _mm512_castph_ps(b)));
+}
+
+// vector operator &= : bitwise and
+static inline Vec32h & operator &= (Vec32h & a, Vec32h const b) {
+    a = a & b;
+    return a;
+}
+
+// vector operator & : bitwise and of Vec32h and Vec32hb
+static inline Vec32h operator & (Vec32h const a, Vec32hb const b) {
+    return _mm512_castsi512_ph(_mm512_maskz_mov_epi16(b, _mm512_castph_si512(a)));
+}
+static inline Vec32h operator & (Vec32hb const a, Vec32h const b) {
+    return b & a;
+}
+
+// vector operator | : bitwise or
+static inline Vec32h operator | (Vec32h const a, Vec32h const b) {
+    return _mm512_castps_ph(_mm512_or_ps(_mm512_castph_ps(a), _mm512_castph_ps(b)));
+}
+
+// vector operator |= : bitwise or
+static inline Vec32h & operator |= (Vec32h & a, Vec32h const b) {
+    a = a | b;
+    return a;
+}
+
+// vector operator ^ : bitwise xor
+static inline Vec32h operator ^ (Vec32h const a, Vec32h const b) {
+    return _mm512_castps_ph(_mm512_xor_ps(_mm512_castph_ps(a), _mm512_castph_ps(b)));
+}
+
+// vector operator ^= : bitwise xor
+static inline Vec32h & operator ^= (Vec32h & a, Vec32h const b) {
+    a = a ^ b;
+    return a;
+}
+
+// vector operator ! : logical not. Returns Boolean vector
+static inline Vec32hb operator ! (Vec32h const a) {
+    return a == Vec32h(0.0);
+}
+
+
+/*****************************************************************************
+*
+*          Functions for Vec32h
+*
+*****************************************************************************/
+
+// Select between two operands. Corresponds to this pseudocode:
+// for (int i = 0; i < 4; i++) result[i] = s[i] ? a[i] : b[i];
+static inline Vec32h select(Vec32hb const s, Vec32h const a, Vec32h const b) {
+    return _mm512_castsi512_ph(_mm512_mask_mov_epi16(_mm512_castph_si512(b), s, _mm512_castph_si512(a)));
+}
+
+// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]
+static inline Vec32h if_add(Vec32hb const f, Vec32h const a, Vec32h const b) {
+    return _mm512_mask_add_ph (a, f, a, b);
+}
+
+// Conditional subtract: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]
+static inline Vec32h if_sub(Vec32hb const f, Vec32h const a, Vec32h const b) {
+    return _mm512_mask_sub_ph (a, f, a, b);
+}
+
+// Conditional multiply: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]
+static inline Vec32h if_mul(Vec32hb const f, Vec32h const a, Vec32h const b) {
+    return _mm512_mask_mul_ph (a, f, a, b);
+}
+
+// Conditional divide: For all vector elements i: result[i] = f[i] ? (a[i] / b[i]) : a[i]
+static inline Vec32h if_div(Vec32hb const f, Vec32h const a, Vec32h const b) {
+    return _mm512_mask_div_ph (a, f, a, b);
+}
+
+// Sign functions
+
+// Function sign_bit: gives true for elements that have the sign bit set
+// even for -0.0f, -INF and -NAN
+// Note that sign_bit(Vec32h(-0.0f16)) gives true, while Vec32h(-0.0f16) < Vec32h(0.0f16) gives false
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec32hb sign_bit(Vec32h const a) {
+    Vec32s t1 = _mm512_castph_si512(a);    // reinterpret as 16-bit integer
+    Vec32s t2 = t1 >> 15;                  // extend sign bit
+    return t2 != 0;
+}
+
+// Function sign_combine: changes the sign of a when b has the sign bit set
+// same as select(sign_bit(b), -a, a)
+static inline Vec32h sign_combine(Vec32h const a, Vec32h const b) {
+    return a ^ (b & Vec32h(_Float16(-0.0)));
+}
+
+// Categorization functions
+
+// Function is_finite: gives true for elements that are normal, subnormal or zero,
+// false for INF and NAN
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec32hb is_finite(Vec32h const a) {
+    return __mmask32(~ _mm512_fpclass_ph_mask(a, 0x99));
+}
+
+// Function is_inf: gives true for elements that are +INF or -INF
+// false for finite numbers and NAN
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec32hb is_inf(Vec32h const a) {
+    return __mmask32(_mm512_fpclass_ph_mask(a, 0x18));
+}
+
+// Function is_nan: gives true for elements that are +NAN or -NAN
+// false for finite numbers and +/-INF
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec32hb is_nan(Vec32h const a) {
+    // assume that compiler does not optimize this away with -ffinite-math-only:
+    return Vec32sb(_mm512_fpclass_ph_mask(a, 0x81));
+}
+
+// Function is_subnormal: gives true for elements that are subnormal
+// false for finite numbers, zero, NAN and INF
+static inline Vec32hb is_subnormal(Vec32h const a) {
+    return Vec32hb(_mm512_fpclass_ph_mask(a, 0x20));
+}
+
+// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal
+// false for finite numbers, NAN and INF
+static inline Vec32hb is_zero_or_subnormal(Vec32h const a) {
+    return Vec32hb(_mm512_fpclass_ph_mask(a, 0x26));
+}
+
+// Function infinite32h: returns a vector where all elements are +INF
+static inline Vec32h infinite32h() {
+    return _mm512_castsi512_ph(_mm512_set1_epi16(0x7C00));
+}
+
+// template for producing quiet NAN
+template <>
+Vec32h nan_vec<Vec32h>(uint32_t payload) {
+    if constexpr (Vec32h::elementtype() == 15) {  // _Float16
+        union {
+            uint16_t i;
+            _Float16 f;
+        } uf;
+        uf.i = 0x7E00 | (payload & 0x01FF);
+        return Vec32h(uf.f);
+    }
+} 
+
+// Function nan32h: returns a vector where all elements are NAN (quiet)
+static inline Vec32h nan32h(uint32_t n = 0x10) {
+    return nan_vec<Vec32h>(n);
+}
+
+// This function returns the code hidden in a NAN. The sign bit is ignored
+static inline Vec32us nan_code(Vec32h const x) {
+    Vec32us a = Vec32us(_mm512_castph_si512(x));
+    Vec32us const n = 0x3FF;
+    return select(is_nan(x), a & n, Vec32us(0));
+} 
+
+
+// General arithmetic functions, etc.
+
+// Horizontal add: Calculates the sum of all vector elements.
+static inline _Float16 horizontal_add(Vec32h const a) {
+    return horizontal_add(a.get_low()+a.get_high());
+}
+// same, with high precision
+static inline float horizontal_add_x(Vec32h const a) {
+    Vec16f b1 = _mm512_cvtph_ps(_mm256_castph_si256(a.get_low()));   //_mm512_cvtph_ps(a.get_low());
+    Vec16f b2 = _mm512_cvtph_ps(_mm256_castph_si256(a.get_high()));
+    return horizontal_add(b1 + b2);
+}
+
+// function max: a > b ? a : b
+static inline Vec32h max(Vec32h const a, Vec32h const b) {
+    return _mm512_max_ph(a, b);
+}
+
+// function min: a < b ? a : b
+static inline Vec32h min(Vec32h const a, Vec32h const b) {
+    return _mm512_min_ph(a, b);
+}
+// NAN-safe versions of maximum and minimum are in vector_convert.h
+
+// function abs: absolute value
+static inline Vec32h abs(Vec32h const a) {
+    return _mm512_abs_ph(a);
+}
+
+// function sqrt: square root
+static inline Vec32h sqrt(Vec32h const a) {
+    return _mm512_sqrt_ph(a);
+}
+
+// function square: a * a
+static inline Vec32h square(Vec32h const a) {
+    return a * a;
+}
+
+// The purpose of this template is to prevent implicit conversion of a float
+// exponent to int when calling pow(vector, float) and vectormath_exp.h is not included
+template <typename TT> static Vec32h pow(Vec32h const a, TT const n);  // = delete
+
+// Raise floating point numbers to integer power n
+template <>
+inline Vec32h pow<int>(Vec32h const x0, int const n) {
+    return pow_template_i<Vec32h>(x0, n);
+}
+
+// allow conversion from unsigned int
+template <>
+inline Vec32h pow<uint32_t>(Vec32h const x0, uint32_t const n) {
+    return pow_template_i<Vec32h>(x0, (int)n);
+}
+
+// Raise floating point numbers to integer power n, where n is a compile-time constant:
+// Template in vectorf28.h is used
+//template <typename V, int n>
+//static inline V pow_n(V const a);
+
+// implement as function pow(vector, const_int)
+template <int n>
+Vec32h pow(Vec32h const a, Const_int_t<n>) {
+    return pow_n<Vec32h, n>(a);
+}
+
+static inline Vec32h round(Vec32h const a) {
+    return _mm512_roundscale_ph (a, 8);
+}
+
+// function truncate: round towards zero. (result as float vector)
+static inline Vec32h truncate(Vec32h const a) {
+    return _mm512_roundscale_ph(a, 3 + 8);
+}
+
+// function floor: round towards minus infinity. (result as float vector)
+static inline Vec32h floor(Vec32h const a) {
+    return _mm512_roundscale_ph(a, 1 + 8);
+}
+
+// function ceil: round towards plus infinity. (result as float vector)
+static inline Vec32h ceil(Vec32h const a) {
+    return _mm512_roundscale_ph(a, 2 + 8);
+}
+
+// function roundi: round to nearest integer (even). (result as integer vector)
+static inline Vec32s roundi(Vec32h const a) {
+    // Note: assume MXCSR control register is set to rounding
+    return _mm512_cvtph_epi16(a);
+}
+
+// function truncatei: round towards zero. (result as integer vector)
+static inline Vec32s truncatei(Vec32h const a) {
+    return _mm512_cvttph_epi16(a);
+}
+
+// function to_float: convert integer vector to float vector
+static inline Vec32h to_float16(Vec32s const a) {
+    return _mm512_cvtepi16_ph(a);
+}
+
+// function to_float: convert unsigned integer vector to float vector
+static inline Vec32h to_float16(Vec32us const a) {
+    return _mm512_cvtepu16_ph(a);
+}
+
+// Approximate math functions
+
+// reciprocal (almost exact)
+static inline Vec32h approx_recipr(Vec32h const a) {
+    return _mm512_rcp_ph(a);
+}
+
+// reciprocal squareroot (almost exact)
+static inline Vec32h approx_rsqrt(Vec32h const a) {
+    return _mm512_rsqrt_ph(a);
+}
+
+// Fused multiply and add functions
+
+// Multiply and add. a*b+c
+static inline Vec32h mul_add(Vec32h const a, Vec32h const b, Vec32h const c) {
+    return _mm512_fmadd_ph(a, b, c);
+}
+
+// Multiply and subtract. a*b-c
+static inline Vec32h mul_sub(Vec32h const a, Vec32h const b, Vec32h const c) {
+    return _mm512_fmsub_ph(a, b, c);
+}
+
+// Multiply and inverse subtract
+static inline Vec32h nmul_add(Vec32h const a, Vec32h const b, Vec32h const c) {
+    return _mm512_fnmadd_ph(a, b, c);
+}
+
+// Math functions using fast bit manipulation
+
+// Extract the exponent as an integer
+// exponent(a) = floor(log2(abs(a)));
+// exponent(1.0f) = 0, exponent(0.0f) = -127, exponent(INF) = +128, exponent(NAN) = +128
+static inline Vec32s exponent(Vec32h const a) {
+    Vec32us t1 = _mm512_castph_si512(a);   // reinterpret as 16-bit integer
+    Vec32us t2 = t1 << 1;                  // shift out sign bit
+    Vec32us t3 = t2 >> 11;                 // shift down logical to position 0
+    Vec32s  t4 = Vec32s(t3) - 0x0F;        // subtract bias from exponent
+    return t4;
+}
+
+// Extract the fraction part of a floating point number
+// a = 2^exponent(a) * fraction(a), except for a = 0
+// fraction(1.0f) = 1.0f, fraction(5.0f) = 1.25f
+// NOTE: The name fraction clashes with an ENUM in MAC XCode CarbonCore script.h !
+static inline Vec32h fraction(Vec32h const a) {
+    return _mm512_getmant_ph(a, _MM_MANT_NORM_1_2, _MM_MANT_SIGN_zero);
+}
+
+// Fast calculation of pow(2,n) with n integer
+// n  =    0 gives 1.0f
+// n >=  16 gives +INF
+// n <= -15 gives 0.0f
+// This function will never produce subnormals, and never raise exceptions
+static inline Vec32h exp2(Vec32s const n) {
+    Vec32s t1 = max(n, -15);            // limit to allowed range
+    Vec32s t2 = min(t1, 16);
+    Vec32s t3 = t2 + 15;                // add bias
+    Vec32s t4 = t3 << 10;               // put exponent into position 10
+    return _mm512_castsi512_ph(t4);     // reinterpret as float
+}
+//static Vec32h exp2(Vec32h const x);    // defined in vectormath_exp.h ??
+
+
+// change signs on vectors Vec32h
+// Each index i0 - i31 is 1 for changing sign on the corresponding element, 0 for no change
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, 
+int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15,
+int i16, int i17, int i18, int i19, int i20, int i21, int i22, int i23,
+int i24, int i25, int i26, int i27, int i28, int i29, int i30, int i31 >
+Vec32h change_sign(Vec32h const a) {
+    if constexpr ((i0 | i1 | i2 | i3 | i4 | i5 | i6 | i7 | i8 | i9 | i10 | i11 | i12 | i13 | i14 | i15 |
+    i16 | i17 | i18 | i19 | i20 | i21 | i22 | i23 | i24 | i25 | i26 | i27 | i28 | i29 | i30 | i31)
+    == 0) return a;
+    __m512i mask = constant16ui<
+        (i0  ? 0x8000 : 0) | (i1  ? 0x80000000 : 0), 
+        (i2  ? 0x8000 : 0) | (i3  ? 0x80000000 : 0), 
+        (i4  ? 0x8000 : 0) | (i5  ? 0x80000000 : 0), 
+        (i6  ? 0x8000 : 0) | (i7  ? 0x80000000 : 0), 
+        (i8  ? 0x8000 : 0) | (i9  ? 0x80000000 : 0), 
+        (i10 ? 0x8000 : 0) | (i11 ? 0x80000000 : 0), 
+        (i12 ? 0x8000 : 0) | (i13 ? 0x80000000 : 0), 
+        (i14 ? 0x8000 : 0) | (i15 ? 0x80000000 : 0),        
+        (i16 ? 0x8000 : 0) | (i17 ? 0x80000000 : 0), 
+        (i18 ? 0x8000 : 0) | (i19 ? 0x80000000 : 0), 
+        (i20 ? 0x8000 : 0) | (i21 ? 0x80000000 : 0), 
+        (i22 ? 0x8000 : 0) | (i23 ? 0x80000000 : 0), 
+        (i24 ? 0x8000 : 0) | (i25 ? 0x80000000 : 0), 
+        (i26 ? 0x8000 : 0) | (i27 ? 0x80000000 : 0), 
+        (i28 ? 0x8000 : 0) | (i29 ? 0x80000000 : 0), 
+        (i30 ? 0x8000 : 0) | (i31 ? 0x80000000 : 0) >();
+    return  _mm512_castps_ph(_mm512_xor_ps(_mm512_castph_ps(a), _mm512_castsi512_ps(mask)));     // flip sign bits
+}
+
+
+/*****************************************************************************
+*
+*          Functions for reinterpretation between vector types
+*
+*****************************************************************************/
+
+static inline __m512i reinterpret_i(__m512h const x) {
+    return _mm512_castph_si512(x);
+}
+
+static inline __m512h reinterpret_h(__m512i const x) {
+    return _mm512_castsi512_ph(x);
+}
+
+static inline __m512  reinterpret_f(__m512h const x) {
+    return _mm512_castph_ps(x);
+}
+
+static inline __m512d reinterpret_d(__m512h const x) {
+    return _mm512_castph_pd(x);
+}
+
+static inline Vec32h extend_z(Vec16h a) {
+    //return _mm512_zextsi256_si512(a);
+    return _mm512_zextph256_ph512(a);
+}
+
+/*****************************************************************************
+*
+*          Vector permute and blend functions
+*
+******************************************************************************
+*
+* The permute function can reorder the elements of a vector and optionally
+* set some elements to zero.
+*
+* See vectori128.h for details
+*
+*****************************************************************************/
+// permute vector Vec32h
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, 
+int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15,
+int i16, int i17, int i18, int i19, int i20, int i21, int i22, int i23,
+int i24, int i25, int i26, int i27, int i28, int i29, int i30, int i31 >
+Vec32h permute32(Vec32h const a) {
+    return _mm512_castsi512_ph (
+    permute32<i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
+    i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31 > (
+    Vec32s(_mm512_castph_si512(a))));
+}
+
+
+/*****************************************************************************
+*
+*          Vector blend functions
+*
+*****************************************************************************/
+
+// permute and blend Vec32h
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, 
+int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15,
+int i16, int i17, int i18, int i19, int i20, int i21, int i22, int i23,
+int i24, int i25, int i26, int i27, int i28, int i29, int i30, int i31 >
+Vec32h blend32(Vec32h const a, Vec32h const b) {
+    return _mm512_castsi512_ph (
+    blend32<i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
+    i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31 > (
+    Vec32s(_mm512_castph_si512(a)), Vec32s(_mm512_castph_si512(b))));
+}
+
+
+/*****************************************************************************
+*
+*          Vector lookup functions
+*
+******************************************************************************
+*
+* These functions use vector elements as indexes into a table.
+* The table is given as one or more vectors or as an array.
+*
+*****************************************************************************/
+
+static inline Vec32h lookup32 (Vec32s const index, Vec32h const table) {
+    return _mm512_castsi512_ph(lookup32(index, Vec32s(_mm512_castph_si512(table))));
+}
+
+template <int n>
+static inline Vec32h lookup(Vec32s const index, void const * table) {
+    return _mm512_castsi512_ph(lookup<n>(index, (void const *)(table)));
+}
+
+#endif // MAX_VECTOR_SIZE >= 512
+
+
+/***************************************************************************************
+*
+*                       Mathematical functions
+*
+* This code is designed to be independent of whether the vectormath files are included
+*
+***************************************************************************************/
+
+// pow(2,n)
+template <typename V>
+V vh_pow2n (V const n) {           
+    typedef decltype(roundi(n)) VI;              // corresponding integer vector type
+    const _Float16 pow2_10 = _Float16(1024);     // 2^10
+    const _Float16 bias = _Float16(15);          // bias in exponent
+    V  a = n + (bias + pow2_10);                 // put n + bias in least significant bits
+    VI b = reinterpret_i(a);                     // bit-cast to integer
+    VI c = b << 10;                              // shift left 10 places to get into exponent field
+    V  d = reinterpret_h(c);                     // bit-cast back to float16
+    return d;
+}
+
+// generate INF vector
+template <typename VTYPE>
+static inline VTYPE infinite_vech();
+
+template <>
+inline Vec8h infinite_vech<Vec8h>() {
+    return infinite8h();
+}
+#if MAX_VECTOR_SIZE >= 256
+template <>
+inline Vec16h infinite_vech<Vec16h>() {
+    return infinite16h();
+}
+#endif
+#if MAX_VECTOR_SIZE >= 512
+template <>
+inline Vec32h infinite_vech<Vec32h>() {
+    return infinite32h();
+}
+#endif
+
+
+// Template for exp function, half precision
+// The limit of abs(x) is defined by max_x below
+// Note on accuracy:
+// This function does not produce subnormal results
+// Max error is 7 ULP
+// The input range is slightly reduced. Inputs > 10.75 give INF. INputs < -10.75 give 0.
+// The emulated version without __AVX512FP16__ can produce subnormals, has full input range,
+// and a precision of 1 ULP
+
+// Template parameters:
+// VTYPE:  float vector type
+// M1: 0 for exp, 1 for expm1
+// BA: 0 for exp, 1 for 0.5*exp, 2 for pow(2,x), 10 for pow(10,x)
+
+template<typename VTYPE, int M1, int BA>
+VTYPE exp_h(VTYPE const initial_x) {
+
+    // Taylor coefficients
+    const _Float16 P0expf   =  _Float16(1.f/2.f);
+    const _Float16 P1expf   =  _Float16(1.f/6.f);
+    const _Float16 P2expf   =  _Float16(1.f/24.f);
+
+    VTYPE  x, r, x2, z, n2;                      // data vectors
+
+    // maximum abs(x), value depends on BA, defined below
+    // The lower limit of x is slightly more restrictive than the upper limit.
+    // We are specifying the lower limit, except for BA = 1 because it is not used for negative x
+    _Float16 max_x;
+
+    if constexpr (BA <= 1) {                     // exp(x)
+        const _Float16 ln2f  = _Float16(0.69314718f);   // ln(2)
+        const _Float16 log2e = _Float16(1.44269504089f); // log2(e)
+        x = initial_x;
+        r = round(initial_x*log2e);
+        x = nmul_add(r, VTYPE(ln2f), x);         //  x -= r * ln2f;
+        max_x = _Float16(10.75f);                // overflow limit
+    }
+    else if constexpr (BA == 2) {                // pow(2,x)
+        const _Float16 ln2 = _Float16(0.69314718f); // ln(2)
+        max_x = _Float16(15.5f);
+        r = round(initial_x);
+        x = initial_x - r;
+        x = x * ln2;
+    }
+    else if constexpr (BA == 10) {               // pow(10,x)
+        max_x = 4.667f;
+        const _Float16 log10_2 = _Float16(0.30102999566f); // log10(2)
+        x = initial_x;
+        r = round(initial_x*_Float16(3.32192809489f)); // VM_LOG2E*VM_LN10
+        x = nmul_add(r, VTYPE(log10_2), x);      //  x -= r * log10_2
+        x = x * _Float16(2.30258509299f);        // (float)VM_LN10;
+    }
+    else  {  // undefined value of BA
+        return 0.;
+    }
+    x2 = x * x;
+    // z = polynomial_2(x,P0expf,P1expf,P2expf);
+    z = mul_add(x2, P2expf, mul_add(x, P1expf, P0expf));
+    z = mul_add(z, x2, x);                       // z *= x2;  z += x;
+    if constexpr (BA == 1) r--;                  // 0.5 * exp(x)
+    n2 = vh_pow2n(r);                            // multiply by power of 2
+    if constexpr (M1 == 0) {                     // exp
+        z = (z + _Float16(1)) * n2;
+    }
+    else {                                       // expm1
+        z = mul_add(z, n2, n2 - _Float16(1));    //  z = z * n2 + (n2 - 1.0f);
+#ifdef SIGNED_ZERO                               // pedantic preservation of signed zero
+        z = select(initial_x == _Float16(0), initial_x, z);
+#endif
+    }
+    // check for overflow
+    auto inrange  = abs(initial_x) < VTYPE(max_x);// boolean vector
+    // check for INF and NAN
+    inrange &= is_finite(initial_x);
+    if (horizontal_and(inrange)) {               // fast normal path
+        return z;
+    }
+    else {                                       // overflow, underflow and NAN
+        VTYPE const inf = infinite_vech<VTYPE>();          // infinite
+        r = select(sign_bit(initial_x), _Float16(0.f-(M1&1)), inf);  // value in case of +/- overflow or INF
+        z = select(inrange, z, r);                         // +/- underflow
+        z = select(is_nan(initial_x), initial_x, z);       // NAN goes through
+        return z;
+    }
+}
+
+// dummy functions used for type definition in template sincos_h:
+static inline Vec8us  unsigned_int_type(Vec8h)  { return 0; }
+#if MAX_VECTOR_SIZE >= 256
+static inline Vec16us unsigned_int_type(Vec16h) { return 0; }
+#endif
+#if MAX_VECTOR_SIZE >= 512
+static inline Vec32us unsigned_int_type(Vec32h) { return 0; }
+#endif
+
+
+// Template for trigonometric functions.
+// Template parameters:
+// VTYPE:  vector type
+// SC:     1 = sin, 2 = cos, 3 = sincos, 4 = tan, 8 = multiply by pi
+// Parameters:
+// xx = input x (radians)
+// cosret = return pointer (only if SC = 3)
+template<typename VTYPE, int SC>
+VTYPE sincos_h(VTYPE * cosret, VTYPE const xx) {
+
+    // define constants
+    const _Float16 dp1h = _Float16(1.57031250f);           // pi/2 with lower bits of mantissa removed
+    const _Float16 dp2h = _Float16(1.57079632679489661923 - dp1h); // remaining bits
+
+    const _Float16 P0sinf = _Float16(-1.6666654611E-1f);   // Taylor coefficients
+    const _Float16 P1sinf = _Float16(8.3321608736E-3f);
+
+    const _Float16 P0cosf = _Float16(4.166664568298827E-2f);
+    const _Float16 P1cosf = _Float16(-1.388731625493765E-3f);
+
+    const float pi     = 3.14159265358979323846f;// pi
+    const _Float16 c2_pi  = _Float16(2./3.14159265358979323846);  // 2/pi
+
+    typedef decltype(roundi(xx)) ITYPE;          // integer vector type
+    typedef decltype(unsigned_int_type(xx)) UITYPE;// unsigned integer vector type
+    typedef decltype(xx < xx) BVTYPE;            // boolean vector type
+
+    VTYPE  xa, x, y, x2, s, c, sin1, cos1;       // data vectors
+    ITYPE  signsin, signcos;                     // integer vectors
+    UITYPE q;                                    // unsigned integer vector for quadrant
+    BVTYPE swap, overflow;                       // boolean vectors
+
+    xa = abs(xx);
+
+    // Find quadrant
+    if constexpr ((SC & 8) != 0) {               // sinpi
+        xa = select(xa > VTYPE(32000.f), VTYPE(0.f), xa); // avoid overflow when multiplying by 2
+        y = round(xa * VTYPE(2.0f)); 
+    }
+    else {                                       // sin
+        xa = select(xa > VTYPE(314.25f), VTYPE(0.f), xa); // avoid meaningless results for high x
+        y = round(xa * c2_pi);                   // quadrant, as float
+    }
+
+    q = UITYPE(roundi(y));                       // quadrant, as unsigned integer
+    //      0 -   pi/4 => 0
+    //   pi/4 - 3*pi/4 => 1
+    // 3*pi/4 - 5*pi/4 => 2
+    // 5*pi/4 - 7*pi/4 => 3
+    // 7*pi/4 - 8*pi/4 => 4
+
+    if constexpr ((SC & 8) != 0) {               // sinpi
+        // modulo 2: subtract 0.5*y
+        x = nmul_add(y, VTYPE(0.5f), xa) * VTYPE(pi);
+    }
+    else {                                       // sin
+        // Reduce by extended precision modular arithmetic    
+        x = nmul_add(y, dp2h, nmul_add(y, dp1h, xa)); 
+    }
+
+    // Taylor expansion of sin and cos, valid for -pi/4 <= x <= pi/4
+    x2 = x * x;
+
+    //x2 = select(is_inf(xx), reinterpret_h(UITYPE(0x7F00)), x2);  // return NAN rather than INF if INF input
+
+    s = mul_add(x2, P1sinf, P0sinf) * (x*x2) + x;
+    c = mul_add(x2, P1cosf, P0cosf) * (x2*x2) + nmul_add(_Float16(0.5), x2, _Float16(1.0f));
+    // s = P0sinf * (x*x2) + x;  // 2 ULP error
+    // c = P0cosf * (x2*x2) + nmul_add(0.5f, x2, 1.0f);  // 2 ULP error
+
+    // swap sin and cos if odd quadrant
+    swap = BVTYPE((q & 1) != 0);
+
+    if constexpr ((SC & 5) != 0) {               // get sin
+        sin1 = select(swap, c, s);
+        signsin = ((q << 14) ^ ITYPE(reinterpret_i(xx))); // sign
+        sin1 = sign_combine(sin1, VTYPE(reinterpret_h(signsin)));
+    }
+
+    if constexpr ((SC & 6) != 0) {               // get cos
+        cos1 = select(swap, s, c);
+        signcos = ((q + 1) & 2) << 14;           // sign
+        cos1 ^= reinterpret_h(signcos);
+    }
+    if      constexpr ((SC & 7) == 1) return sin1;
+    else if constexpr ((SC & 7) == 2) return cos1;
+    else if constexpr ((SC & 7) == 3) {          // both sin and cos. cos returned through pointer
+        *cosret = cos1;
+        return sin1;
+    }
+    else {                                       // (SC & 7) == 4. tan
+        if constexpr (SC == 12) {
+            // tanpi can give INF result, tan cannot. Get the right sign of INF result according to IEEE 754-2019
+            cos1 = select(cos1 == VTYPE(0.f), VTYPE(0.f), cos1); // remove sign of 0
+            // the sign of zero output is arbitrary. fixing it would be a waste of code
+        }
+        return sin1 / cos1;
+    }
+}
+
+// instantiations of math function templates
+
+static inline Vec8h exp(Vec8h const x) {
+    return exp_h<Vec8h, 0, 0>(x);
+} 
+static inline Vec8h exp2(Vec8h const x) {
+    return exp_h<Vec8h, 0, 2>(x);
+}
+static inline Vec8h exp10(Vec8h const x) {
+    return exp_h<Vec8h, 0, 10>(x);
+}
+static inline Vec8h expm1(Vec8h const x) {
+    return exp_h<Vec8h, 1, 0>(x);
+}
+static inline Vec8h sin(Vec8h const x) {
+    return sincos_h<Vec8h, 1>(0, x);
+}
+static inline Vec8h cos(Vec8h const x) {
+    return sincos_h<Vec8h, 2>(0, x);
+}
+static inline Vec8h sincos(Vec8h * cosret, Vec8h const x) {
+    return sincos_h<Vec8h, 3>(cosret, x);
+} 
+static inline Vec8h tan(Vec8h const x) {
+    return sincos_h<Vec8h, 4>(0, x);
+}
+
+static inline Vec8h sinpi(Vec8h const x) {
+    return sincos_h<Vec8h, 9>(0, x);
+}
+static inline Vec8h cospi(Vec8h const x) {
+    return sincos_h<Vec8h, 10>(0, x);
+}
+static inline Vec8h sincospi(Vec8h * cosret, Vec8h const x) {
+    return sincos_h<Vec8h, 11>(cosret, x);
+}
+static inline Vec8h tanpi(Vec8h const x) {
+    return sincos_h<Vec8h, 12>(0, x);
+}
+
+#if MAX_VECTOR_SIZE >= 256
+
+static inline Vec16h exp(Vec16h const x) {
+    return exp_h<Vec16h, 0, 0>(x);
+}
+static inline Vec16h exp2(Vec16h const x) {
+    return exp_h<Vec16h, 0, 2>(x);
+}
+static inline Vec16h exp10(Vec16h const x) {
+    return exp_h<Vec16h, 0, 10>(x);
+}
+static inline Vec16h expm1(Vec16h const x) {
+    return exp_h<Vec16h, 1, 0>(x);
+} 
+static inline Vec16h sin(Vec16h const x) {
+    return sincos_h<Vec16h, 1>(0, x);
+}
+static inline Vec16h cos(Vec16h const x) {
+    return sincos_h<Vec16h, 2>(0, x);
+}
+static inline Vec16h sincos(Vec16h * cosret, Vec16h const x) {
+    return sincos_h<Vec16h, 3>(cosret, x);
+} 
+static inline Vec16h tan(Vec16h const x) {
+    return sincos_h<Vec16h, 4>(0, x);
+}
+static inline Vec16h sinpi(Vec16h const x) {
+    return sincos_h<Vec16h, 9>(0, x);
+}
+static inline Vec16h cospi(Vec16h const x) {
+    return sincos_h<Vec16h, 10>(0, x);
+}
+static inline Vec16h sincospi(Vec16h * cosret, Vec16h const x) {
+    return sincos_h<Vec16h, 11>(cosret, x);
+} 
+static inline Vec16h tanpi(Vec16h const x) {
+    return sincos_h<Vec16h, 12>(0, x);
+}
+
+#endif  // MAX_VECTOR_SIZE >= 256
+
+#if MAX_VECTOR_SIZE >= 512
+
+static inline Vec32h exp(Vec32h const x) {
+    return exp_h<Vec32h, 0, 0>(x);
+}
+static inline Vec32h exp2(Vec32h const x) {
+    return exp_h<Vec32h, 0, 2>(x);
+}
+static inline Vec32h exp10(Vec32h const x) {
+    return exp_h<Vec32h, 0, 10>(x);
+}
+static inline Vec32h expm1(Vec32h const x) {
+    return exp_h<Vec32h, 1, 0>(x);
+}
+static inline Vec32h sin(Vec32h const x) {
+    return sincos_h<Vec32h, 1>(0, x);
+}
+static inline Vec32h cos(Vec32h const x) {
+    return sincos_h<Vec32h, 2>(0, x);
+}
+static inline Vec32h sincos(Vec32h * cosret, Vec32h const x) {
+    return sincos_h<Vec32h, 3>(cosret, x);
+} 
+static inline Vec32h tan(Vec32h const x) {
+    return sincos_h<Vec32h, 4>(0, x);
+}
+static inline Vec32h sinpi(Vec32h const x) {
+    return sincos_h<Vec32h, 9>(0, x);
+}
+static inline Vec32h cospi(Vec32h const x) {
+    return sincos_h<Vec32h, 10>(0, x);
+}
+static inline Vec32h sincospi(Vec32h * cosret, Vec32h const x) {
+    return sincos_h<Vec32h, 11>(cosret, x);
+} 
+static inline Vec32h tanpi(Vec32h const x) {
+    return sincos_h<Vec32h, 12>(0, x);
+}
+
+#endif  // MAX_VECTOR_SIZE >= 512
+
+
+#ifdef VCL_NAMESPACE
+}
+#endif
+
+#endif // defined(__AVX512FP16__)
+
+#endif // VECTORFP16_H
diff --git a/LGhost/VCL2/vectorfp16e.h b/LGhost/VCL2/vectorfp16e.h
new file mode 100644
index 0000000..5664017
--- /dev/null
+++ b/LGhost/VCL2/vectorfp16e.h
@@ -0,0 +1,3248 @@
+/****************************  vectorfp16e.h   *******************************
+* Author:        Agner Fog
+* Date created:  2022-05-03
+* Last modified: 2023-10-19
+* Version:       2.02.01
+* Project:       vector class library
+* Description:
+* Header file emulating half precision floating point vector classes
+* when instruction set AVX512_FP16 is not defined
+*
+* Instructions: see vcl_manual.pdf
+*
+* The following vector classes are defined here:
+* Vec8h     Vector of 8 half precision floating point numbers in 128 bit vector
+* Vec16h    Vector of 16 half precision floating point numbers in 256 bit vector
+* Vec32h    Vector of 32 half precision floating point numbers in 512 bit vector
+*
+* This header file defines operators and functions for these vectors.
+*
+* (c) Copyright 2012-2023 Agner Fog.
+* Apache License version 2.0 or later.
+*****************************************************************************/
+
+#ifndef VECTORFP16E_H
+#define VECTORFP16E_H
+
+#ifndef VECTORCLASS_H
+#include "vectorclass.h"
+#endif
+
+#if VECTORCLASS_H < 20200
+#error Incompatible versions of vector class library mixed
+#endif
+
+#if MAX_VECTOR_SIZE < 256
+#error Emulation of half precision floating point not supported for MAX_VECTOR_SIZE < 256
+#endif
+
+#ifdef VCL_NAMESPACE
+namespace VCL_NAMESPACE {
+#endif
+
+
+/*****************************************************************************
+*
+*        Float16: Use _Float16 if it is defined, or emulate it if not
+*
+*****************************************************************************/
+
+
+// test if _Float16 is defined
+#if defined(FLT16_MAX) || defined(__FLT16_MAX__)
+    // _Float16 is defined. 
+    typedef _Float16 Float16;
+    
+    // Define bit-casting between uint16_t <-> Float16
+    static inline uint16_t castfp162s(Float16 x) {
+        union {
+            Float16 f;
+            uint16_t i;
+        } u;
+        u.f = x;
+        return u.i;
+    }
+    static inline Float16 casts2fp16(uint16_t x) {
+        union {
+            uint16_t i;
+            Float16 f;
+        } u;
+        u.i = x;
+        return u.f;
+    }
+#else
+    // _Float16 is not defined
+    // define Float16 as a class with constructor, operators, etc. to avoid operators like + from treating Float16 like integer
+    class Float16 {
+    protected:
+        uint16_t x;
+    public:
+    // Default constructor:
+        Float16() = default;
+#ifdef __F16C__   // F16C instruction set includes conversion instructions
+    Float16(float f) { // Constructor to convert float to fp16
+        //x = uint16_t(_mm_cvtsi128_si32(_mm_cvtps_ph(_mm_set1_ps(f), _MM_FROUND_NO_EXC))); // requires __AVX512FP16__
+        x = uint16_t(_mm_cvtsi128_si32(_mm_cvtps_ph(_mm_set1_ps(f), 0)));
+    }
+    operator float() const {                     // Type cast operator to convert fp16 to float
+        return _mm_cvtss_f32(_mm_cvtph_ps(_mm_set1_epi32(x)));
+    }
+
+#else  // F16C instruction set not supported. Make conversion functions
+    Float16(float f) {                           // Constructor to convert float to fp16
+        union {                                  // single precision float as bitfield
+            float f;
+            struct {
+                uint32_t mant : 23;
+                uint32_t expo : 8;
+                uint32_t sign : 1;
+            };
+        } u;
+        union {                                  // half precision float as bitfield
+            uint16_t h;
+            struct {
+                uint16_t mant : 10;
+                uint16_t expo : 5;
+                uint16_t sign : 1;
+            };
+        } v;
+        u.f = f;
+        v.expo = u.expo - 0x70;                  // convert exponent
+        v.mant = u.mant >> 13;                   // get upper part of mantissa
+        if (u.mant & (1 << 12)) {                // round to nearest or even
+            if ((u.mant & ((1 << 12) - 1)) || (v.mant & 1)) { // round up if odd or remaining bits are nonzero
+                v.h++;                           // overflow here will give infinity
+            }
+        }
+        v.sign = u.sign;                         // copy sign bit
+        if (u.expo == 0xFF) {                    // infinity or nan
+            v.expo = 0x1F;
+            if (u.mant != 0) {                   // Nan
+                v.mant = u.mant >> 13;           // NAN payload is left-justified
+            }
+        }
+        else if (u.expo > 0x8E) {
+            v.expo = 0x1F;  v.mant = 0;          // overflow -> inf
+        }
+        else if (u.expo < 0x71) {
+            v.expo = 0;                          // subnormals are always supported
+            u.expo += 24;
+            u.sign = 0;
+            //v.mant = int(u.f) & 0x3FF;
+            int mants = _mm_cvt_ss2si(_mm_load_ss(&u.f));
+            v.mant = mants & 0x3FF; // proper rounding of subnormal
+            if (mants == 0x400) v.expo = 1;
+        }
+        x = v.h;                                 // store result
+    }    
+    operator float() const {                     // Type cast operator to convert fp16 to float
+        union {
+            uint32_t hhh;
+            float fff;
+            struct {
+                uint32_t mant : 23;
+                uint32_t expo : 8;
+                uint32_t sign : 1;
+            };
+        } u;
+        u.hhh = (x & 0x7fff) << 13;              // Exponent and mantissa
+        u.hhh += 0x38000000;                     // Adjust exponent bias
+        if ((x & 0x7C00) == 0) {                 // Subnormal or zero
+            u.hhh = 0x3F800000 - (24 << 23);     // 2^-24
+            u.fff *= int(x & 0x3FF);             // subnormal value = mantissa * 2^-24
+        }
+        if ((x & 0x7C00) == 0x7C00) {            // infinity or nan
+            u.expo = 0xFF;
+            if (x & 0x3FF) {                     // nan
+                u.mant = (x & 0x3FF) << 13;      // NAN payload is left-justified
+            }
+        }
+        u.hhh |= (x & 0x8000) << 16;             // copy sign bit
+        return u.fff;
+    } 
+#endif  // F16C supported
+
+    void setBits(uint16_t a) {
+        x = a;
+    }
+    uint16_t getBits() const {
+        return x;
+    }
+    };
+
+    static inline int16_t castfp162s(Float16 a) {
+        return a.getBits();
+    }
+    static inline Float16 casts2fp16(int16_t a) {
+        Float16 f;
+        f.setBits(a);
+        return f;
+    }
+
+    // Define operators for Float16 emulation class
+
+    static inline Float16 operator + (Float16 const a, Float16 const b) {
+        return Float16(float(a) + float(b));
+    }
+    static inline Float16 operator - (Float16 const a, Float16 const b) {
+        return Float16(float(a) - float(b));
+    }
+    static inline Float16 operator * (Float16 const a, Float16 const b) {
+        return Float16(float(a) * float(b));
+    }
+    static inline Float16 operator / (Float16 const a, Float16 const b) {
+        return Float16(float(a) / float(b));
+    }
+    static inline Float16 operator - (Float16 const a) {
+        return casts2fp16(castfp162s(a) ^ 0x8000);
+    }
+    static inline bool operator == (Float16 const a, Float16 const b) {
+        return float(a) == float(b);
+    }
+    static inline bool operator != (Float16 const a, Float16 const b) {
+        return float(a) != float(b);
+    }
+    static inline bool operator < (Float16 const a, Float16 const b) {
+        return float(a) < float(b);
+    }
+    static inline bool operator <= (Float16 const a, Float16 const b) {
+        return float(a) <= float(b);
+    }
+    static inline bool operator > (Float16 const a, Float16 const b) {
+        return float(a) > float(b);
+    }
+    static inline bool operator >= (Float16 const a, Float16 const b) {
+        return float(a) >= float(b);
+    }
+
+#endif  // Float16 defined
+
+
+/*****************************************************************************
+*
+*          Vec8hb: Vector of 8 Booleans for use with Vec8h
+*
+*****************************************************************************/
+
+#if INSTRSET >= 10
+typedef Vec8b Vec8hb;   // compact boolean vector
+static inline Vec8hb Vec8fb2hb (Vec8fb const a) {
+    return a;
+}
+#else
+typedef Vec8sb Vec8hb;  // broad boolean vector
+static inline Vec8hb Vec8fb2hb (Vec8fb const a) {
+    // boolean vector needs compression from 32 bits to 16 bits per element
+    Vec4ib lo = reinterpret_i(a.get_low());
+    Vec4ib hi = reinterpret_i(a.get_high());
+    return _mm_packs_epi32(lo, hi);
+}
+#endif
+
+
+/*****************************************************************************
+*
+*          Vec8h: Vector of 8 half precision floating point values
+*
+*****************************************************************************/
+
+class Vec8h {
+protected:
+    __m128i xmm; // Float vector
+public:
+    // Default constructor:
+    Vec8h() = default;
+    // Constructor to broadcast the same value into all elements:
+    Vec8h(Float16 f) {
+        xmm = _mm_set1_epi16 (castfp162s(f));
+    }
+    // Constructor to build from all elements:
+    Vec8h(Float16 f0, Float16 f1, Float16 f2, Float16 f3, Float16 f4, Float16 f5, Float16 f6, Float16 f7) {
+        xmm = _mm_setr_epi16 (castfp162s(f0), castfp162s(f1), castfp162s(f2), castfp162s(f3), castfp162s(f4), castfp162s(f5), castfp162s(f6), castfp162s(f7));
+    }
+    // Constructor to convert from type __m128i used in intrinsics:
+    Vec8h(__m128i const x) {
+        xmm = x;
+    }
+    // Assignment operator to convert from type __m128i used in intrinsics:
+    Vec8h & operator = (__m128i const x) {
+        xmm = x;
+        return *this;
+    }
+    // Type cast operator to convert to __m128i used in intrinsics
+    operator __m128i() const {
+        return xmm;
+    }
+    // Member function to load from array (unaligned)
+    Vec8h & load(void const * p) {
+        xmm = _mm_loadu_si128 ((const __m128i *)p);
+        return *this;
+    }
+    // Member function to load from array, aligned by 16
+    // You may use load_a instead of load if you are certain that p points to an address
+    // divisible by 16. In most cases there is no difference in speed between load and load_a
+    Vec8h & load_a(void const * p) {
+        xmm = _mm_load_si128 ((const __m128i *)p);
+        return *this;
+    }
+    // Member function to store into array (unaligned)
+    void store(void * p) const {
+        _mm_storeu_si128 ((__m128i *)p, xmm);
+    }
+    // Member function storing into array, aligned by 16
+    // You may use store_a instead of store if you are certain that p points to an address
+    // divisible by 16.
+    void store_a(void * p) const {
+        _mm_store_si128 ((__m128i *)p, xmm);
+    }
+    // Member function storing to aligned uncached memory (non-temporal store).
+    // This may be more efficient than store_a when storing large blocks of memory if it 
+    // is unlikely that the data will stay in the cache until it is read again.
+    // Note: Will generate runtime error if p is not aligned by 16
+    void store_nt(void * p) const {
+        _mm_stream_si128((__m128i*)p, xmm);
+    }
+    // Partial load. Load n elements and set the rest to 0
+    Vec8h & load_partial(int n, void const * p) {
+        xmm = Vec8s().load_partial(n, p);
+        return *this;
+    }
+    // Partial store. Store n elements
+    void store_partial(int n, void * p) const {
+        Vec8s(xmm).store_partial(n, p);
+    }
+    // cut off vector to n elements. The last 8-n elements are set to zero
+    Vec8h & cutoff(int n) {
+        xmm = Vec8s(xmm).cutoff(n);
+        return *this;
+    }
+    // Member function to change a single element in vector
+    Vec8h const insert(int index, Float16 a) {
+        xmm = Vec8s(xmm).insert(index, castfp162s(a));
+        return *this;
+    }
+    // Member function extract a single element from vector
+    Float16 extract(int index) const {
+        Float16 y;
+        y = casts2fp16(Vec8s(xmm).extract(index));
+        return y;
+    }
+    // Extract a single element. Use store function if extracting more than one element.
+    // Operator [] can only read an element, not write.
+    Float16 operator [] (int index) const {
+        return extract(index);
+    }
+    static constexpr int size() {
+        return 8;
+    }
+    static constexpr int elementtype() {
+        return 15;
+    }
+    typedef __m128i registertype;
+};
+
+/*****************************************************************************
+*
+*          conversions Vec8h <-> Vec4f
+*
+*****************************************************************************/
+
+#ifdef __F16C__    // F16C instruction set has conversion instructions
+
+// extend precision: Vec8h -> Vec4f. upper half ignored
+static inline Vec4f convert8h_4f (Vec8h h) {
+    return _mm_cvtph_ps(h);
+}
+
+// reduce precision: Vec4f -> Vec8h. upper half zero
+static inline Vec8h convert4f_8h (Vec4f f) {
+    return _mm_cvtps_ph(f, 0);
+}
+
+#else
+
+// extend precision: Vec8h -> Vec4f. upper half ignored
+static Vec4f convert8h_4f (Vec8h x) {
+    // __m128i a = _mm_cvtepu16_epi32(x);                            // SSE4.1
+    __m128i a = _mm_unpacklo_epi16(x, _mm_setzero_si128 ());         // zero extend
+    __m128i b = _mm_slli_epi32(a, 16);                               // left-justify
+    __m128i c = _mm_and_si128(b, _mm_set1_epi32(0x80000000));        // isolate sign bit
+    __m128i d = _mm_andnot_si128(_mm_set1_epi32(0x80000000),b);      // remove sign bit
+    __m128i e = _mm_srli_epi32(d, 3);                                // put exponent and mantissa in place
+    __m128i f = _mm_add_epi32(e, _mm_set1_epi32(0x38000000));        // adjust exponent bias
+    // check for subnormal, INF, and NAN
+    __m128i xx = _mm_set1_epi32(0x7C00);                             // exponent field in fp16
+    __m128i g  = _mm_and_si128(a, xx);                               // isolate exponent (low position)
+    __m128i zd = _mm_cmpeq_epi32(g, _mm_setzero_si128());            // -1 if x is zero or subnormal
+    __m128i in = _mm_cmpeq_epi32(g, xx);                             // -1 if x is INF or NAN
+    __m128i ma = _mm_and_si128(a, _mm_set1_epi32(0x3FF));            // isolate mantissa
+    __m128  sn = _mm_mul_ps(_mm_cvtepi32_ps(ma), _mm_set1_ps(1.f/16777216.f)); // converted subnormal = mantissa * 2^-24
+    __m128i snm = _mm_and_si128(_mm_castps_si128(sn), zd);           // converted subnormal, masked
+    __m128i inm = _mm_and_si128(in,_mm_set1_epi32(0x7F800000));      // INF or NAN exponent field, masked off if not INF or NAN
+    __m128i fm = _mm_andnot_si128(zd, f);                            // normal result, masked off if zero or subnormal
+    __m128i r = _mm_or_si128(fm, c);                                 // insert sign bit
+    __m128i s = _mm_or_si128(snm, inm);                              // combine branches
+    __m128i t = _mm_or_si128(r, s);                                  // combine branches
+    return _mm_castsi128_ps(t);                                      // cast result to float
+}
+
+// reduce precision: Vec4f -> Vec8h. upper half zero
+static Vec8h convert4f_8h (Vec4f x) {
+    __m128i a = _mm_castps_si128(x);                                 // bit-cast to integer
+    // 23 bit mantissa rounded to 10 bits - nearest or even
+    __m128i r = _mm_srli_epi32(a, 12);                               // get first discarded mantissa bit
+    __m128i s = _mm_and_si128(a, _mm_set1_epi32(0x2FFF));            // 0x2000 indicates if odd, 0x0FFF if remaining bits are nonzero
+    __m128i u = _mm_cmpeq_epi32(s, _mm_setzero_si128());             // false if odd or remaining bits nonzero
+    __m128i v = _mm_andnot_si128(u, r);                              // bit 0 = 1 if we have to round up
+    __m128i w = _mm_and_si128(v, _mm_set1_epi32(1));                 // = 1 if we need to round up
+    __m128i m = _mm_srli_epi32(a, 13);                               // get mantissa in place
+    __m128i n = _mm_and_si128(m, _mm_set1_epi32(0x3FF));             // mantissa isolated
+    __m128i e = _mm_and_si128(a, _mm_set1_epi32(0x7FFFFFFF));        // remove sign bit
+    __m128i f = _mm_sub_epi32(e, _mm_set1_epi32(0x70 << 23));        // adjust exponent bias (underflow will be caught by uu below)
+    __m128i g = _mm_srli_epi32(f, 13);                               // shift exponent into new place
+    __m128i h = _mm_and_si128(g, _mm_set1_epi32(0x3FC00));           // isolate exponent 
+    __m128i i = _mm_or_si128(n, h);                                  // combine exponent and mantissa
+    Vec4i   j = _mm_add_epi32(i, w);                                 // round mantissa. Overflow will carry into exponent
+    // check for overflow and underflow
+    Vec4ib  k  = j > 0x7BFF;                                         // overflow
+    Vec4i   ee = _mm_srli_epi32(e, 23);                              // exponent at position 0
+    Vec4ib  ii = ee == 0xFF;                                         // check for INF and NAN
+    Vec4ib  uu = ee < 0x71;                                          // check for exponent underflow
+    __m128i pp = _mm_or_si128(j, _mm_set1_epi32(0x7C00));            // insert exponent if INF or NAN
+    // compute potential subnormal result
+    __m128i ss = _mm_add_epi32(e, _mm_set1_epi32(24 << 23));         // add 24 to exponent
+    __m128i tt = _mm_cvtps_epi32(_mm_castsi128_ps(ss));              // convert float to int with rounding
+    __m128i vv = _mm_and_si128(tt, _mm_set1_epi32(0x3FF));           // mantissa of subnormal number
+    // combine results   
+    Vec4i  bb = select(k, 0x7C00, j);                                // select INF if overflow
+    Vec4i  dd = select(ii, pp, bb);                                  // select INF or NAN    
+    Vec4i  cc = select(uu, vv, dd);                                  // select if subnormal or zero or exponent underflow
+    // get sign bit
+    Vec4i  sa = Vec4i(a) >> 16;                                      // extend sign bit to avoid saturation in pack instruction below
+    Vec4i  const smask = 0xFFFF8000;                                 // extended sign mask
+    Vec4i  sb = sa & smask;                                          // isolate sign
+    Vec4i  sc = _mm_andnot_si128(smask, cc);                         // isolate exponent and mantissa
+    Vec4i  rr = sb | sc;                                             // combine with sign
+    Vec4i  rc  = _mm_packs_epi32(rr, _mm_setzero_si128());           // pack into 16-bit words (words are sign extended so they will not saturate)
+    return (__m128i)rc;                                              // return as Vec8h
+} 
+
+#endif
+
+/*****************************************************************************
+*
+*          conversions Vec8h <-> Vec8f
+*
+*****************************************************************************/
+#if defined (__F16C__) && INSTRSET >= 8  // F16C instruction set has conversion instructions
+
+// extend precision: Vec8h -> Vec8f
+static inline Vec8f to_float (Vec8h h) {
+    return _mm256_cvtph_ps(h);
+}
+
+// reduce precision: Vec8f -> Vec8h
+static inline Vec8h to_float16 (Vec8f f) {
+    return _mm256_cvtps_ph(f, 0);
+}
+
+#elif INSTRSET >= 8 // __F16C__ not defined, AVX2 supported
+
+// extend precision: Vec8h -> Vec8f
+static Vec8f to_float (Vec8h x) {
+    __m256i a = _mm256_cvtepu16_epi32(x);                            // zero-extend each element to 32 bits
+    __m256i b = _mm256_slli_epi32(a, 16);                            // left-justify
+    __m256i c = _mm256_and_si256(b, _mm256_set1_epi32(0x80000000));  // isolate sign bit
+    __m256i d = _mm256_andnot_si256(_mm256_set1_epi32(0x80000000),b);// remove sign bit
+    __m256i e = _mm256_srli_epi32(d, 3);                             // put exponent and mantissa in place
+    __m256i f = _mm256_add_epi32(e, _mm256_set1_epi32(0x38000000));  // adjust exponent bias
+    // check for subnormal, INF, and NAN
+    __m256i xx = _mm256_set1_epi32(0x7C00);                          // exponent field in fp16
+    __m256i g  = _mm256_and_si256(a, xx);                            // isolate exponent (low position)
+    __m256i zd = _mm256_cmpeq_epi32(g, _mm256_setzero_si256());      // -1 if x is zero or subnormal
+    __m256i in = _mm256_cmpeq_epi32(g, xx);                          // -1 if x is INF or NAN
+    __m256i ma = _mm256_and_si256(a, _mm256_set1_epi32(0x3FF));      // isolate mantissa
+    __m256  sn = _mm256_mul_ps(_mm256_cvtepi32_ps(ma), _mm256_set1_ps(1.f/16777216.f)); // converted subnormal = mantissa * 2^-24
+    __m256i snm = _mm256_and_si256(_mm256_castps_si256(sn), zd);     // converted subnormal, masked
+    __m256i inm = _mm256_and_si256(in,_mm256_set1_epi32(0x7F800000));// INF or NAN exponent field, masked off if not INF or NAN
+    __m256i fm = _mm256_andnot_si256(zd, f);                         // normal result, masked off if zero or subnormal
+    __m256i r = _mm256_or_si256(fm, c);                              // insert sign bit
+    __m256i s = _mm256_or_si256(snm, inm);                           // combine branches
+    __m256i t = _mm256_or_si256(r, s);                               // combine branches
+    return _mm256_castsi256_ps(t);                                   // cast result to float
+}
+
+// reduce precision: Vec8f -> Vec8h
+static Vec8h to_float16 (Vec8f x) {
+    __m256i a = _mm256_castps_si256(x);                              // bit-cast to integer
+    // 23 bit mantissa rounded to 10 bits - nearest or even
+    __m256i r = _mm256_srli_epi32(a, 12);                            // get first discarded mantissa bit
+    __m256i s = _mm256_and_si256(a, _mm256_set1_epi32(0x2FFF));      // 0x2000 indicates if odd, 0x0FFF if remaining bits are nonzero
+    __m256i u = _mm256_cmpeq_epi32(s, _mm256_setzero_si256());       // false if odd or remaining bits nonzero
+    __m256i v = _mm256_andnot_si256(u, r);                           // bit 0 = 1 if we have to round up
+    __m256i w = _mm256_and_si256(v, _mm256_set1_epi32(1));           // = 1 if we need to round up
+    __m256i m = _mm256_srli_epi32(a, 13);                            // get mantissa in place
+    __m256i n = _mm256_and_si256(m, _mm256_set1_epi32(0x3FF));       // mantissa isolated
+    __m256i e = _mm256_and_si256(a, _mm256_set1_epi32(0x7FFFFFFF));  // remove sign bit
+    __m256i f = _mm256_sub_epi32(e, _mm256_set1_epi32(0x70 << 23));  // adjust exponent bias (underflow will be caught by uu below)
+    __m256i g = _mm256_srli_epi32(f, 13);                            // shift exponent into new place
+    __m256i h = _mm256_and_si256(g, _mm256_set1_epi32(0x3FC00));     // isolate exponent 
+    __m256i i = _mm256_or_si256(n, h);                               // combine exponent and mantissa
+    __m256i j = _mm256_add_epi32(i, w);                              // round mantissa. Overflow will carry into exponent
+    // check for overflow and underflow
+    __m256i k = _mm256_cmpgt_epi32(j, _mm256_set1_epi32(0x7BFF));    // overflow
+    __m256i ee = _mm256_srli_epi32(e, 23);                           // exponent at position 0
+    __m256i ii = _mm256_cmpeq_epi32(ee, _mm256_set1_epi32(0xFF));    // check for INF and NAN
+    __m256i uu = _mm256_cmpgt_epi32(_mm256_set1_epi32(0x71), ee);    // check for exponent underflow
+    __m256i pp = _mm256_or_si256(j, _mm256_set1_epi32(0x7C00));      // insert exponent if INF or NAN
+    // compute potential subnormal result
+    __m256i ss = _mm256_add_epi32(e, _mm256_set1_epi32(24 << 23));   // add 24 to exponent
+    __m256i tt = _mm256_cvtps_epi32(_mm256_castsi256_ps(ss));        // convert float to int with rounding
+    __m256i vv = _mm256_and_si256(tt, _mm256_set1_epi32(0x7FF));     // mantissa of subnormal number (possible overflow to normal)
+    // combine results
+    __m256i bb = _mm256_blendv_epi8(j, _mm256_set1_epi32(0x7C00), k);// select INF if overflow
+    __m256i dd = _mm256_blendv_epi8(bb, pp, ii);                     // select INF or NAN    
+    __m256i cc = _mm256_blendv_epi8(dd, vv, uu);                     // select if subnormal or zero or exponent underflow
+    __m256i sa = _mm256_srai_epi32(a, 16);                           // extend sign bit to avoid saturation in pack instruction below
+    __m256i sb = _mm256_and_si256(sa, _mm256_set1_epi32(0xFFFF8000));// isolate sign
+    __m256i sc = _mm256_andnot_si256(_mm256_set1_epi32(0xFFFF8000), cc);// isolate exponent and mantissa
+    __m256i rr = _mm256_or_si256(sb, sc);                            // combine with sign
+    __m128i rl = _mm256_castsi256_si128(rr);                         // low half of results
+    __m128i rh = _mm256_extractf128_si256(rr, 1);                    // high half of results
+    __m128i rc = _mm_packs_epi32(rl, rh);                            // pack into 16-bit words (words are sign extended so they will not saturate)
+    return  rc;                                                      // return as Vec8h
+} 
+
+#else // __F16C__ not defined, AVX2 not supported 
+
+// extend precision: Vec8h -> Vec8f
+static Vec8f to_float (Vec8h x) {
+    Vec8s  xx = __m128i(x);
+    Vec4ui a1 = _mm_unpacklo_epi16(xx, _mm_setzero_si128 ());
+    Vec4ui a2 = _mm_unpackhi_epi16(xx, _mm_setzero_si128 ());
+    Vec4ui b1 = a1 << 16;                        // left-justify
+    Vec4ui b2 = a2 << 16;
+    Vec4ui c1 = b1 & 0x80000000;                 // isolate sign bit
+    Vec4ui c2 = b2 & 0x80000000;
+    Vec4ui d1 = _mm_andnot_si128(Vec4ui(0x80000000), b1); // remove sign bit
+    Vec4ui d2 = _mm_andnot_si128(Vec4ui(0x80000000), b2);
+    Vec4ui e1 = d1 >> 3;                         // put exponent and mantissa in place
+    Vec4ui e2 = d2 >> 3;
+    Vec4ui f1 = e1 + 0x38000000;                 // adjust exponent bias
+    Vec4ui f2 = e2 + 0x38000000;
+    Vec4ui g1 = a1 & 0x7C00;                     // isolate exponent (low position)
+    Vec4ui g2 = a2 & 0x7C00;
+    Vec4ib z1 = g1 == 0;                         // true if x is zero or subnormal (broad boolean vector)
+    Vec4ib z2 = g2 == 0;
+    Vec4ib i1 = g1 == 0x7C00;                    // true if x is INF or NAN
+    Vec4ib i2 = g2 == 0x7C00;
+    Vec4ui m1 = a1 & 0x3FF;                      // isolate mantissa (low position)
+    Vec4ui m2 = a2 & 0x3FF;
+    Vec4f  s1 = to_float(m1) * (1.f/16777216.f); // converted subnormal = mantissa * 2^-24
+    Vec4f  s2 = to_float(m2) * (1.f/16777216.f);
+    Vec4ui sm1 = Vec4ui(reinterpret_i(s1)) & Vec4ui(z1); // converted subnormal, masked
+    Vec4ui sm2 = Vec4ui(reinterpret_i(s2)) & Vec4ui(z2);
+    Vec4ui inm1 = Vec4ui(i1) & Vec4ui(0x7F800000); // INF or NAN exponent field, masked off if not INF or NAN 
+    Vec4ui inm2 = Vec4ui(i2) & Vec4ui(0x7F800000);
+    Vec4ui fm1 = _mm_andnot_si128(Vec4ui(z1), f1); // normal result, masked off if zero or subnormal
+    Vec4ui fm2 = _mm_andnot_si128(Vec4ui(z2), f2);
+    Vec4ui r1 = fm1 | c1;                        // insert sign bit
+    Vec4ui r2 = fm2 | c2;
+    Vec4ui q1 = sm1 | inm1;                      // combine branches
+    Vec4ui q2 = sm2 | inm2;
+    Vec4ui t1 = r1  | q1;                        // combine branches
+    Vec4ui t2 = r2  | q2;
+    Vec4f  u1 = reinterpret_f(t1);               // bit-cast to float
+    Vec4f  u2 = reinterpret_f(t2);
+    return Vec8f(u1, u2);                        // combine low and high part
+} 
+
+// reduce precision: Vec8f -> Vec8h
+static Vec8h to_float16 (Vec8f x) {              
+    Vec4ui a1 = _mm_castps_si128(x.get_low());             // low half
+    Vec4ui a2 = _mm_castps_si128(x.get_high());            // high half
+    Vec4ui r1 = a1 >> 12;                                  // get first discarded mantissa bit
+    Vec4ui r2 = a2 >> 12;
+    Vec4ui s1 = a1 & 0x2FFF;                               // 0x2000 indicates if odd, 0x0FFF if remaining bits are nonzero
+    Vec4ui s2 = a2 & 0x2FFF;
+    Vec4ib u1 = s1 == 0;                                   // false if odd or remaining bits nonzero
+    Vec4ib u2 = s2 == 0;
+    Vec4ui v1 = _mm_andnot_si128(u1, r1);                  // bit 0 = 1 if we have to round up
+    Vec4ui v2 = _mm_andnot_si128(u2, r2);
+    Vec4ui w1 = v1 & 1;                                    // = 1 if we need to round up
+    Vec4ui w2 = v2 & 1;
+    Vec4ui m1 = a1 >> 13;                                  // get mantissa in place
+    Vec4ui m2 = a2 >> 13;
+    Vec4ui n1 = m1 & 0x3FF;                                // mantissa isolated
+    Vec4ui n2 = m2 & 0x3FF;
+    Vec4ui e1 = a1 & 0x7FFFFFFF;                           // remove sign bit
+    Vec4ui e2 = a2 & 0x7FFFFFFF;
+    Vec4ui f1 = e1 - (0x70 << 23);                         // adjust exponent bias
+    Vec4ui f2 = e2 - (0x70 << 23);
+    Vec4ui g1 = f1 >> 13;                                  // shift exponent into new place
+    Vec4ui g2 = f2 >> 13;
+    Vec4ui h1 = g1 & 0x3FC00;                              // isolate exponent 
+    Vec4ui h2 = g2 & 0x3FC00;
+    Vec4ui i1 = n1 | h1;                                   // combine exponent and mantissa
+    Vec4ui i2 = n2 | h2;
+    Vec4ui j1 = i1 + w1;                                   // round mantissa. Overflow will carry into exponent
+    Vec4ui j2 = i2 + w2;
+    // check for overflow and underflow
+    Vec4ib k1 = j1 > 0x7BFF;                               // overflow
+    Vec4ib k2 = j2 > 0x7BFF;
+    Vec4ui ee1 = e1 >> 23;                                 // exponent at position 0
+    Vec4ui ee2 = e2 >> 23;
+    Vec4ib ii1 = ee1 == 0xFF;                              // check for INF and NAN
+    Vec4ib ii2 = ee2 == 0xFF;
+    Vec4ib uu1 = ee1 < 0x71;                               // exponent underflow
+    Vec4ib uu2 = ee2 < 0x71;
+    Vec4i  pp1 = Vec4i(0x7C00) | j1;                       // insert exponent if INF or NAN
+    Vec4i  pp2 = Vec4i(0x7C00) | j2;
+    // compute potential subnormal result
+    Vec4ui ss1 = e1 + (24 << 23);                          // add 24 to exponent
+    Vec4ui ss2 = e2 + (24 << 23);
+    Vec4ui tt1 = _mm_cvtps_epi32(_mm_castsi128_ps(ss1));   // convert float to int with rounding
+    Vec4ui tt2 = _mm_cvtps_epi32(_mm_castsi128_ps(ss2));
+    Vec4ui vv1 = tt1 & 0x7FF;                              // mantissa of subnormal number (possible overflow to normal)
+    Vec4ui vv2 = tt2 & 0x7FF;
+    // combine results
+    Vec4i  bb1 = select(k1, 0x7C00, j1);                   // select INF if overflow
+    Vec4i  bb2 = select(k2, 0x7C00, j2);
+    Vec4i  dd1 = select(ii1, pp1, bb1);                    // select INF or NAN    
+    Vec4i  dd2 = select(ii2, pp2, bb2);
+    Vec4i  cc1 = select(uu1, vv1, dd1);                    // select if subnormal or zero or exponent underflow
+    Vec4i  cc2 = select(uu2, vv2, dd2);
+    // get sign bit
+    Vec4i  sa1 = Vec4i(a1) >> 16;                          // extend sign bit to avoid saturation in pack instruction below
+    Vec4i  sa2 = Vec4i(a2) >> 16;
+    Vec4i  const smask = 0xFFFF8000;                       // extended sign mask
+    Vec4i  sb1 = sa1 & smask;                              // isolate sign
+    Vec4i  sb2 = sa2 & smask;
+    Vec4i  sc1 = _mm_andnot_si128(smask, cc1);             // isolate exponent and mantissa
+    Vec4i  sc2 = _mm_andnot_si128(smask, cc2);
+    Vec4i  rr1 = sb1 | sc1;                                // combine with sign
+    Vec4i  rr2 = sb2 | sc2;
+    Vec4i  rc  = _mm_packs_epi32(rr1, rr2);                // pack into 16-bit words (words are sign extended so they will not saturate)
+    return (__m128i)rc;                                    // return as Vec8h
+}
+
+#endif  // __F16C__
+
+
+/*****************************************************************************
+*
+*          Operators for Vec8h
+*
+*****************************************************************************/
+
+// vector operator + : add element by element
+static inline Vec8h operator + (Vec8h const a, Vec8h const b) {
+    return to_float16(to_float(a) + to_float(b));
+}
+
+// vector operator + : add vector and scalar
+static inline Vec8h operator + (Vec8h const a, Float16 b) {
+    return a + Vec8h(b);
+}
+static inline Vec8h operator + (Float16 a, Vec8h const b) {
+    return Vec8h(a) + b;
+}
+
+// vector operator += : add
+static inline Vec8h & operator += (Vec8h & a, Vec8h const b) {
+    a = a + b;
+    return a;
+}
+
+// postfix operator ++
+static inline Vec8h operator ++ (Vec8h & a, int) {
+    Vec8h a0 = a;
+    a = a + Float16(1.f); // 1.0f16 not supported by g++ version 12.1
+    return a0;
+}
+
+// prefix operator ++
+static inline Vec8h & operator ++ (Vec8h & a) {
+    a = a +  Float16(1.f);
+    return a;
+}
+
+// vector operator - : subtract element by element
+static inline Vec8h operator - (Vec8h const a, Vec8h const b) {
+    return to_float16(to_float(a) - to_float(b));
+}
+
+// vector operator - : subtract vector and scalar
+static inline Vec8h operator - (Vec8h const a, Float16 b) {
+    return a - Vec8h(b);
+}
+static inline Vec8h operator - (Float16 a, Vec8h const b) {
+    return Vec8h(a) - b;
+}
+
+// vector operator - : unary minus
+// Change sign bit, even for 0, INF and NAN
+static inline Vec8h operator - (Vec8h const a) {
+    return _mm_xor_si128(__m128i(a), _mm_set1_epi32(0x80008000));
+}
+
+// vector operator -= : subtract
+static inline Vec8h & operator -= (Vec8h & a, Vec8h const b) {
+    a = a - b;
+    return a;
+}
+
+// postfix operator --
+static inline Vec8h operator -- (Vec8h & a, int) {
+    Vec8h a0 = a;
+    a = a - Vec8h(Float16(1.f));
+    return a0;
+}
+
+// prefix operator --
+static inline Vec8h & operator -- (Vec8h & a) {
+    a = a - Vec8h(Float16(1.f));
+    return a;
+}
+
+// vector operator * : multiply element by element
+static inline Vec8h operator * (Vec8h const a, Vec8h const b) {
+    return to_float16(to_float(a) * to_float(b));
+}
+
+// vector operator * : multiply vector and scalar
+static inline Vec8h operator * (Vec8h const a, Float16 b) {
+    return a * Vec8h(b);
+}
+static inline Vec8h operator * (Float16 a, Vec8h const b) {
+    return Vec8h(a) * b;
+}
+
+// vector operator *= : multiply
+static inline Vec8h & operator *= (Vec8h & a, Vec8h const b) {
+    a = a * b;
+    return a;
+}
+
+// vector operator / : divide all elements by same integer
+static inline Vec8h operator / (Vec8h const a, Vec8h const b) {
+    return to_float16(to_float(a) / to_float(b));
+}
+
+// vector operator / : divide vector and scalar
+static inline Vec8h operator / (Vec8h const a, Float16 b) {
+    return a / Vec8h(b);
+}
+static inline Vec8h operator / (Float16 a, Vec8h const b) {
+    return Vec8h(a) / b;
+}
+
+// vector operator /= : divide
+static inline Vec8h & operator /= (Vec8h & a, Vec8h const b) {
+    a = a / b;
+    return a;
+}
+
+// vector operator == : returns true for elements for which a == b
+static inline Vec8hb operator == (Vec8h const a, Vec8h const b) {
+    return Vec8fb2hb(to_float(a) == to_float(b));
+}
+
+// vector operator != : returns true for elements for which a != b
+static inline Vec8hb operator != (Vec8h const a, Vec8h const b) {
+    return Vec8fb2hb(to_float(a) != to_float(b));
+}
+
+// vector operator < : returns true for elements for which a < b
+static inline Vec8hb operator < (Vec8h const a, Vec8h const b) {
+    return Vec8fb2hb(to_float(a) < to_float(b));
+}
+
+// vector operator <= : returns true for elements for which a <= b
+static inline Vec8hb operator <= (Vec8h const a, Vec8h const b) {
+    return Vec8fb2hb(to_float(a) <= to_float(b));
+}
+
+// vector operator > : returns true for elements for which a > b
+static inline Vec8hb operator > (Vec8h const a, Vec8h const b) {
+    return Vec8fb2hb(to_float(a) > to_float(b));
+}
+
+// vector operator >= : returns true for elements for which a >= b
+static inline Vec8hb operator >= (Vec8h const a, Vec8h const b) {
+    return Vec8fb2hb(to_float(a) >= to_float(b));
+}
+
+// Bitwise logical operators
+
+// vector operator & : bitwise and
+static inline Vec8h operator & (Vec8h const a, Vec8h const b) {
+    return _mm_and_si128(__m128i(a), __m128i(b));
+}
+
+// vector operator &= : bitwise and
+static inline Vec8h & operator &= (Vec8h & a, Vec8h const b) {
+    a = a & b;
+    return a;
+}
+
+// vector operator & : bitwise and of Vec8h and Vec8hb
+static inline Vec8h operator & (Vec8h const a, Vec8hb const b) {
+#if INSTRSET >= 10  // compact boolean vector
+    return _mm_maskz_mov_epi16(b, a);
+#else               // broad boolean vector
+    return _mm_and_si128(__m128i(a), __m128i(b));
+#endif
+}
+static inline Vec8h operator & (Vec8hb const a, Vec8h const b) {
+    return b & a;
+}
+
+// vector operator | : bitwise or
+static inline Vec8h operator | (Vec8h const a, Vec8h const b) {
+    return _mm_or_si128(__m128i(a), __m128i(b));
+}
+
+// vector operator |= : bitwise or
+static inline Vec8h & operator |= (Vec8h & a, Vec8h const b) {
+    a = a | b;
+    return a;
+}
+
+// vector operator ^ : bitwise xor
+static inline Vec8h operator ^ (Vec8h const a, Vec8h const b) {
+    return _mm_xor_si128(__m128i(a), __m128i(b));
+}
+
+// vector operator ^= : bitwise xor
+static inline Vec8h & operator ^= (Vec8h & a, Vec8h const b) {
+    a = a ^ b;
+    return a;
+}
+
+// vector operator ! : logical not. Returns Boolean vector
+static inline Vec8hb operator ! (Vec8h const a) {
+    return a == Vec8h(0.0);
+}
+
+
+/*****************************************************************************
+*
+*          Functions for Vec8h
+*
+*****************************************************************************/
+
+// Select between two operands. Corresponds to this pseudocode:
+// for (int i = 0; i < 4; i++) result[i] = s[i] ? a[i] : b[i];
+static inline Vec8h select(Vec8hb const s, Vec8h const a, Vec8h const b) {
+    return __m128i(select(Vec8sb(s), Vec8s(__m128i(a)), Vec8s(__m128i(b))));
+}
+
+// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]
+static inline Vec8h if_add(Vec8hb const f, Vec8h const a, Vec8h const b) {
+    return a + (b & f);
+}
+
+// Conditional subtract: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]
+static inline Vec8h if_sub(Vec8hb const f, Vec8h const a, Vec8h const b) {
+    return a - (b & f);
+}
+
+// Conditional multiply: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]
+static inline Vec8h if_mul(Vec8hb const f, Vec8h const a, Vec8h const b) {
+    return select(f, a*b, a);
+}
+
+// Conditional divide: For all vector elements i: result[i] = f[i] ? (a[i] / b[i]) : a[i]
+static inline Vec8h if_div(Vec8hb const f, Vec8h const a, Vec8h const b) {
+    return select(f, a/b, a);
+}
+
+// Sign functions
+
+// Function sign_bit: gives true for elements that have the sign bit set
+// even for -0.0f, -INF and -NAN
+// Note that sign_bit(Vec8h(-0.0f16)) gives true, while Vec8h(-0.0f16) < Vec8h(0.0f16) gives false
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec8hb sign_bit(Vec8h const a) {
+    Vec8s t1 = __m128i(a);             // reinterpret as 16-bit integer
+    Vec8s t2 = t1 >> 15;               // extend sign bit
+    return t2 != 0;
+}
+
+// Function sign_combine: changes the sign of a when b has the sign bit set
+// same as select(sign_bit(b), -a, a)
+static inline Vec8h sign_combine(Vec8h const a, Vec8h const b) {
+    return a ^ (b & Vec8h(Float16(-0.0)));
+}
+
+// Categorization functions
+
+// Function is_finite: gives true for elements that are normal, subnormal or zero,
+// false for INF and NAN
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec8hb is_finite(Vec8h const a) {
+    Vec8s b = __m128i(a);
+    return (b & 0x7C00) != 0x7C00;
+}
+
+// Function is_inf: gives true for elements that are +INF or -INF
+// false for finite numbers and NAN
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec8hb is_inf(Vec8h const a) {
+    Vec8s b = __m128i(a);
+    return (b & 0x7FFF) == 0x7C00;
+}
+
+// Function is_nan: gives true for elements that are +NAN or -NAN
+// false for finite numbers and +/-INF
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec8hb is_nan(Vec8h const a) {
+    Vec8s b = __m128i(a);
+    return (b & 0x7FFF) > 0x7C00;
+}
+
+// Function is_subnormal: gives true for elements that are subnormal
+// false for finite numbers, zero, NAN and INF
+static inline Vec8hb is_subnormal(Vec8h const a) {
+    Vec8s b = __m128i(a);
+    return (b & 0x7C00) == 0 && (b & 0x3FF) != 0;
+}
+
+// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal
+// false for finite numbers, NAN and INF
+static inline Vec8hb is_zero_or_subnormal(Vec8h const a) {
+    Vec8s b = __m128i(a);
+    return (b & 0x7C00) == 0;
+}
+
+// Function infinite8h: returns a vector where all elements are +INF
+static inline Vec8h infinite8h() {
+    return Vec8h(_mm_set1_epi16(0x7C00));
+}
+
+// template for producing quiet NAN
+template <>
+Vec8h nan_vec<Vec8h>(uint32_t payload) {
+    if constexpr (Vec8h::elementtype() == 15) {  // Float16
+        return Vec8h(_mm_set1_epi16(0x7E00 | (payload & 0x01FF)));
+    }
+} 
+
+// Function nan8h: returns a vector where all elements are NAN (quiet)
+static inline Vec8h nan8h(int n = 0x10) {
+    return nan_vec<Vec8h>(n);
+}
+
+// This function returns the code hidden in a NAN. The sign bit is ignored
+static inline Vec8us nan_code(Vec8h const x) {
+    Vec8us a = Vec8us(reinterpret_i(x));
+    Vec8us const n = 0x3FF;
+    return select(is_nan(x), a & n, Vec8us(0));
+}
+
+// General arithmetic functions, etc.
+
+// Horizontal add: Calculates the sum of all vector elements.
+static inline Float16 horizontal_add(Vec8h const a) {
+    return Float16(horizontal_add(to_float(a)));
+}
+// same, with high precision
+static inline float horizontal_add_x(Vec8h const a) {
+    return horizontal_add(to_float(a));
+}
+
+// function max: a > b ? a : b
+static inline Vec8h max(Vec8h const a, Vec8h const b) {
+    return to_float16(max(to_float(a), to_float(b)));
+}
+
+// function min: a < b ? a : b
+static inline Vec8h min(Vec8h const a, Vec8h const b) {
+    return to_float16(min(to_float(a), to_float(b)));
+}
+// NAN-safe versions of maximum and minimum are in vector_convert.h
+
+// function abs: absolute value
+static inline Vec8h abs(Vec8h const a) {
+    return _mm_and_si128(a, _mm_set1_epi16(0x7FFF));
+}
+
+// function sqrt: square root
+static inline Vec8h sqrt(Vec8h const a) {
+    return to_float16(sqrt(to_float(a)));
+}
+
+// function square: a * a
+static inline Vec8h square(Vec8h const a) {
+    return a * a;
+}
+
+// The purpose of this template is to prevent implicit conversion of a float
+// exponent to int when calling pow(vector, float) and vectormath_exp.h is not included
+template <typename TT> static Vec8h pow(Vec8h const a, TT const n);  // = delete
+
+// Raise floating point numbers to integer power n
+// To do: Optimize pow<int>(Vec8h/Vec16h/Vec32h, n) to do calculations with float precision
+template <>
+inline Vec8h pow<int>(Vec8h const x0, int const n) {
+    return to_float16(pow_template_i<Vec8f>(to_float(x0), n));
+}
+
+// allow conversion from unsigned int
+template <>
+inline Vec8h pow<uint32_t>(Vec8h const x0, uint32_t const n) {
+    return to_float16(pow_template_i<Vec8f>(to_float(x0), (int)n));
+}
+
+// Raise floating point numbers to integer power n, where n is a compile-time constant:
+// Template in vectorf128.h is used
+//template <typename V, int n>
+//static inline V pow_n(V const a);
+
+// implement as function pow(vector, const_int)
+template <int n>
+static inline Vec8h pow(Vec8h const a, Const_int_t<n>) {
+    return to_float16(pow_n<Vec8f, n>(to_float(a)));
+}
+
+
+static inline Vec8h round(Vec8h const a) {
+    return to_float16(round(to_float(a)));
+}
+
+// function truncate: round towards zero. (result as float vector)
+static inline Vec8h truncate(Vec8h const a) {
+    return to_float16(truncate(to_float(a)));
+}
+
+// function floor: round towards minus infinity. (result as float vector)
+static inline Vec8h floor(Vec8h const a) {
+    return to_float16(floor(to_float(a)));
+}
+
+// function ceil: round towards plus infinity. (result as float vector)
+static inline Vec8h ceil(Vec8h const a) {
+    return to_float16(ceil(to_float(a)));
+}
+
+// function roundi: round to nearest integer (even). (result as integer vector)
+static inline Vec8s roundi(Vec8h const a) {
+    return compress_saturated(roundi(to_float(a)));
+}
+
+// function truncatei: round towards zero. (result as integer vector)
+static inline Vec8s truncatei(Vec8h const a) {
+    //return compress(truncatei(to_float(a)));
+    return compress_saturated(truncatei(to_float(a)));
+}
+
+// function to_float: convert integer vector to float vector
+static inline Vec8h to_float16(Vec8s const a) {
+    return to_float16(to_float(extend(a)));
+}
+
+// function to_float: convert unsigned integer vector to float vector
+static inline Vec8h to_float16(Vec8us const a) {
+    return to_float16(to_float(extend(a)));
+}
+
+// Approximate math functions
+
+// reciprocal (almost exact)
+static inline Vec8h approx_recipr(Vec8h const a) {
+    return to_float16(approx_recipr(to_float(a)));
+}
+
+// reciprocal squareroot (almost exact)
+static inline Vec8h approx_rsqrt(Vec8h const a) {
+    return to_float16(approx_rsqrt(to_float(a)));
+}
+
+// Fused multiply and add functions
+
+// Multiply and add. a*b+c
+static inline Vec8h mul_add(Vec8h const a, Vec8h const b, Vec8h const c) {
+    return to_float16(mul_add(to_float(a),to_float(b),to_float(c)));
+}
+
+// Multiply and subtract. a*b-c
+static inline Vec8h mul_sub(Vec8h const a, Vec8h const b, Vec8h const c) {
+    return to_float16(mul_sub(to_float(a),to_float(b),to_float(c)));
+}
+
+// Multiply and inverse subtract
+static inline Vec8h nmul_add(Vec8h const a, Vec8h const b, Vec8h const c) {
+    return to_float16(nmul_add(to_float(a),to_float(b),to_float(c)));
+}
+
+// Math functions using fast bit manipulation
+
+// Extract the exponent as an integer
+// exponent(a) = floor(log2(abs(a)));
+// exponent(1.0f) = 0, exponent(0.0f) = -127, exponent(INF) = +128, exponent(NAN) = +128
+static inline Vec8s exponent(Vec8h const a) {
+    Vec8us t1 = __m128i(a);            // reinterpret as 16-bit integer
+    Vec8us t2 = t1 << 1;               // shift out sign bit
+    Vec8us t3 = t2 >> 11;              // shift down logical to position 0
+    Vec8s  t4 = Vec8s(t3) - 0x0F;      // subtract bias from exponent
+    return t4;
+}
+
+// Extract the fraction part of a floating point number
+// a = 2^exponent(a) * fraction(a), except for a = 0
+// fraction(1.0f) = 1.0f, fraction(5.0f) = 1.25f
+// NOTE: The name fraction clashes with an ENUM in MAC XCode CarbonCore script.h !
+static inline Vec8h fraction(Vec8h const a) {
+    Vec8us t1 = __m128i(a);   // reinterpret as 16-bit integer
+    Vec8us t2 = Vec8us((t1 & 0x3FF) | 0x3C00); // set exponent to 0 + bias
+    return __m128i(t2);
+}
+
+// Fast calculation of pow(2,n) with n integer
+// n  =    0 gives 1.0f
+// n >=  16 gives +INF
+// n <= -15 gives 0.0f
+// This function will never produce subnormals, and never raise exceptions
+static inline Vec8h exp2(Vec8s const n) {
+    Vec8s t1 = max(n, -15);            // limit to allowed range
+    Vec8s t2 = min(t1, 16);
+    Vec8s t3 = t2 + 15;                // add bias
+    Vec8s t4 = t3 << 10;               // put exponent into position 10
+    return __m128i(t4);                // bit-cast to float
+}
+
+// change signs on vectors Vec8h
+// Each index i0 - i7 is 1 for changing sign on the corresponding element, 0 for no change
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7>
+Vec8h change_sign(Vec8h const a) {
+    if constexpr ((i0 | i1 | i2 | i3 | i4 | i5 | i6 | i7) == 0) return a;
+    __m128i mask = constant4ui<
+        (i0 ? 0x8000 : 0) | (i1 ? 0x80000000 : 0), 
+        (i2 ? 0x8000 : 0) | (i3 ? 0x80000000 : 0), 
+        (i4 ? 0x8000 : 0) | (i5 ? 0x80000000 : 0), 
+        (i6 ? 0x8000 : 0) | (i7 ? 0x80000000 : 0) >();
+    return _mm_xor_si128(a, mask);
+}
+
+
+/*****************************************************************************
+*
+*          Functions for reinterpretation between vector types
+*
+*****************************************************************************/
+static inline __m128i reinterpret_h(__m128i const x) {
+    return x;
+}
+/* Defined in vectorf128.h:
+ __m128i reinterpret_i(__m128i const x)
+ __m128  reinterpret_f(__m128i const x)
+ __m128d reinterpret_d(__m128i const x)
+*/
+
+
+/*****************************************************************************
+*
+*          Vector permute and blend functions
+*
+******************************************************************************
+*
+* The permute function can reorder the elements of a vector and optionally
+* set some elements to zero.
+*
+* See vectori128.h for details
+*
+*****************************************************************************/
+// permute vector Vec8h
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7>
+Vec8h permute8(Vec8h const a) {
+    return __m128i(permute8<i0, i1, i2, i3, i4, i5, i6, i7>(Vec8s(__m128i(a))));
+}
+
+
+/*****************************************************************************
+*
+*          Vector blend functions
+*
+*****************************************************************************/
+
+// permute and blend Vec8h
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7>
+static inline Vec8h blend8(Vec8h const a, Vec8h const b) {
+    return __m128i (blend8<i0, i1, i2, i3, i4, i5, i6, i7>(Vec8s(__m128i(a)), Vec8s(__m128i(b))));
+}
+
+
+/*****************************************************************************
+*
+*          Vector lookup functions
+*
+******************************************************************************
+*
+* These functions use vector elements as indexes into a table.
+* The table is given as one or more vectors or as an array.
+*
+*****************************************************************************/
+
+static inline Vec8h lookup8 (Vec8s const index, Vec8h const table) {
+    return __m128i(lookup8(index, Vec8s(__m128i(table))));
+}
+
+static inline Vec8h lookup16(Vec8s const index, Vec8h const table0, Vec8h const table1) {
+    return __m128i(lookup16(index, Vec8s(__m128i(table0)), Vec8s(__m128i(table1))));
+}
+
+template <int n>
+Vec8h lookup(Vec8s const index, void const * table) {
+    return __m128i(lookup<n>(index, (void const *)(table)));
+}
+
+
+
+/*****************************************************************************
+*
+*          256 bit vectors
+*
+*****************************************************************************/
+
+#if MAX_VECTOR_SIZE >= 512
+
+
+/*****************************************************************************
+*
+*          Vec16hb: Vector of 16 Booleans for use with Vec16h
+*
+*****************************************************************************/
+
+#if INSTRSET >= 10
+typedef Vec16b Vec16hb;   // compact boolean vector
+
+#if MAX_VECTOR_SIZE >= 512
+static inline Vec16hb Vec16fb2hb (Vec16fb const a) {
+    return a;
+}
+#endif
+
+#else
+
+typedef Vec16sb Vec16hb;  // broad boolean vector
+
+static inline Vec16hb Vec16fb2hb (Vec16fb const a) {
+    // boolean vector needs compression from 32 bits to 16 bits per element
+    Vec8fb lo = a.get_low();           // (cannot use _mm256_packs_epi32)
+    Vec8fb hi = a.get_high();
+    return Vec16hb(Vec8fb2hb(lo), Vec8fb2hb(hi));
+}
+
+#endif
+
+
+/*****************************************************************************
+*
+*          Vec16h: Vector of 16 single precision floating point values
+*
+*****************************************************************************/
+
+class Vec16h : public Vec16s {
+public:
+    // Default constructor:
+    Vec16h() = default;
+    // Constructor to broadcast the same value into all elements:
+    Vec16h(Float16 f) : Vec16s(castfp162s(f)) {}
+    Vec16h(float f) : Vec16s(castfp162s(Float16(f))) {}
+
+    // Constructor to build from all elements:
+    Vec16h(Float16 f0, Float16 f1, Float16 f2, Float16 f3, Float16 f4, Float16 f5, Float16 f6, Float16 f7,
+    Float16 f8, Float16 f9, Float16 f10, Float16 f11, Float16 f12, Float16 f13, Float16 f14, Float16 f15) :
+        Vec16s(castfp162s(f0), castfp162s(f1), castfp162s(f2), castfp162s(f3), castfp162s(f4), castfp162s(f5), castfp162s(f6), castfp162s(f7), 
+            castfp162s(f8), castfp162s(f9), castfp162s(f10), castfp162s(f11), castfp162s(f12), castfp162s(f13), castfp162s(f14), castfp162s(f15)) {}
+
+    // Constructor to build from two Vec8h:
+    Vec16h(Vec8h const a0, Vec8h const a1) : Vec16s(Vec8s(a0), Vec8s(a1)) {};
+
+#if INSTRSET >= 8
+    // Constructor to convert from type __m256i used in intrinsics:
+    Vec16h(__m256i const x) {
+        ymm = x;
+    }
+    // Assignment operator to convert from type __m256i used in intrinsics:
+    Vec16h & operator = (__m256i const x) {
+        ymm = x;
+        return *this;
+    }
+    // Type cast operator to convert to __m256i used in intrinsics
+    operator __m256i() const {
+        return ymm;
+    }
+#else
+    // Constructor to convert from type Vec16s. This may cause undesired implicit conversions and ambiguities
+    //Vec16h(Vec16s const x) : Vec16s(x) {}
+#endif
+    // Member function to load from array (unaligned)
+    Vec16h & load(void const * p) {
+        Vec16s::load(p);
+        return *this;
+    }
+    // Member function to load from array, aligned by 32
+    // You may use load_a instead of load if you are certain that p points to an address
+    // divisible by 32. In most cases there is no difference in speed between load and load_a
+    Vec16h & load_a(void const * p) {
+        Vec16s::load_a(p);
+        return *this;
+    }
+    // Member function to store into array (unaligned)
+    // void store(void * p) const // inherited from Vec16s
+
+    // Member function storing into array, aligned by 32
+    // You may use store_a instead of store if you are certain that p points to an address
+    // divisible by 32.
+    // void store_a(void * p) const // inherited from Vec16s 
+
+    // Member function storing to aligned uncached memory (non-temporal store).
+    // This may be more efficient than store_a when storing large blocks of memory if it 
+    // is unlikely that the data will stay in the cache until it is read again.
+    // Note: Will generate runtime error if p is not aligned by 32
+    // void store_nt(void * p) const // inherited from Vec16s 
+
+    // Partial load. Load n elements and set the rest to 0
+    Vec16h & load_partial(int n, void const * p) {
+        Vec16s::load_partial(n, p);
+        return *this;
+    }
+    // Partial store. Store n elements
+    // void store_partial(int n, void * p) const // inherited from Vec16s 
+
+    // cut off vector to n elements. The last 8-n elements are set to zero
+    Vec16h & cutoff(int n) {
+        Vec16s::cutoff(n);
+        return *this;
+    }
+    // Member function to change a single element in vector
+    Vec16h const insert(int index, Float16 a) {
+        Vec16s::insert(index, castfp162s(a));
+        return *this;
+    }
+    // Member function extract a single element from vector
+    Float16 extract(int index) const {
+        return casts2fp16(Vec16s::extract(index));
+    }
+    // Extract a single element. Use store function if extracting more than one element.
+    // Operator [] can only read an element, not write.
+    Float16 operator [] (int index) const {
+        return extract(index);
+    }
+    Vec8h get_low() const {
+        return __m128i(Vec16s::get_low());
+    }
+    Vec8h get_high() const {
+        return __m128i(Vec16s::get_high());
+    }
+    static constexpr int size() {
+        return 16;
+    }
+    static constexpr int elementtype() {
+        return 15;
+    }
+};
+
+/*****************************************************************************
+*
+*          conversions Vec16h <-> Vec16f
+*
+*****************************************************************************/
+#if INSTRSET >= 9    // AVX512F instruction set has conversion instructions
+
+// extend precision: Vec16h -> Vec16f
+Vec16f to_float (Vec16h h) {
+    return _mm512_cvtph_ps(h);
+}
+
+// reduce precision: Vec16f -> Vec16h
+Vec16h to_float16 (Vec16f f) {
+    return _mm512_cvtps_ph(f, 0);
+}
+
+#else
+
+// extend precision: Vec16h -> Vec16f
+Vec16f to_float (Vec16h h) {
+    return Vec16f(to_float(h.get_low()), to_float(h.get_high()));
+}
+
+// reduce precision: Vec16f -> Vec16h
+Vec16h to_float16 (Vec16f f) {
+    return Vec16h(to_float16(f.get_low()), to_float16(f.get_high()));
+}
+
+#endif
+
+/*****************************************************************************
+*
+*          Operators for Vec16h
+*
+*****************************************************************************/
+
+// vector operator + : add element by element
+static inline Vec16h operator + (Vec16h const a, Vec16h const b) {
+    return to_float16(to_float(a) + to_float(b));
+}
+
+
+static inline Vec16h operator + (Float16 a, Vec16h const b) {
+    return Vec16h(a) + b;
+}
+
+// vector operator += : add
+static inline Vec16h & operator += (Vec16h & a, Vec16h const b) {
+    a = a + b;
+    return a;
+}
+
+// postfix operator ++
+static inline Vec16h operator ++ (Vec16h & a, int) {
+    Vec16h a0 = a;
+    a = a + Float16(1.f);
+    return a0;
+}
+
+// prefix operator ++
+static inline Vec16h & operator ++ (Vec16h & a) {
+    a = a + Float16(1.f);
+    return a;
+}
+
+// vector operator - : subtract element by element
+static inline Vec16h operator - (Vec16h const a, Vec16h const b) {
+    return to_float16(to_float(a) - to_float(b));
+}
+
+// vector operator - : subtract vector and scalar
+static inline Vec16h operator - (Vec16h const a, Float16 b) {
+    return a - Vec16h(b);
+}
+static inline Vec16h operator - (Float16 a, Vec16h const b) {
+    return Vec16h(a) - b;
+}
+
+// vector operator - : unary minus
+// Change sign bit, even for 0, INF and NAN
+static inline Vec16h operator - (Vec16h const a) {
+#if INSTRSET >= 8  // AVX2
+    return _mm256_xor_si256(a, _mm256_set1_epi32(0x80008000));
+#else
+    return Vec16h(-a.get_low(), -a.get_high());
+#endif
+}
+
+// vector operator -= : subtract
+static inline Vec16h & operator -= (Vec16h & a, Vec16h const b) {
+    a = a - b;
+    return a;
+}
+
+// postfix operator --
+static inline Vec16h operator -- (Vec16h & a, int) {
+    Vec16h a0 = a;
+    a = a - Vec16h(Float16(1.f));
+    return a0;
+}
+
+// prefix operator --
+static inline Vec16h & operator -- (Vec16h & a) {
+    a = a - Vec16h(Float16(1.f));
+    return a;
+}
+
+// vector operator * : multiply element by element
+static inline Vec16h operator * (Vec16h const a, Vec16h const b) {
+    return to_float16(to_float(a) * to_float(b));
+}
+
+// vector operator * : multiply vector and scalar
+static inline Vec16h operator * (Vec16h const a, Float16 b) {
+    return a * Vec16h(b);
+}
+static inline Vec16h operator * (Float16 a, Vec16h const b) {
+    return Vec16h(a) * b;
+}
+
+// vector operator *= : multiply
+static inline Vec16h & operator *= (Vec16h & a, Vec16h const b) {
+    a = a * b;
+    return a;
+}
+
+// vector operator / : divide all elements by same integer
+static inline Vec16h operator / (Vec16h const a, Vec16h const b) {
+    return to_float16(to_float(a) / to_float(b));
+}
+
+// vector operator / : divide vector and scalar
+static inline Vec16h operator / (Vec16h const a, Float16 b) {
+    return a / Vec16h(b);
+}
+static inline Vec16h operator / (Float16 a, Vec16h const b) {
+    return Vec16h(a) / b;
+}
+
+// vector operator /= : divide
+static inline Vec16h & operator /= (Vec16h & a, Vec16h const b) {
+    a = a / b;
+    return a;
+}
+
+// vector operator == : returns true for elements for which a == b
+static inline Vec16hb operator == (Vec16h const a, Vec16h const b) {
+    return Vec16fb2hb(to_float(a) == to_float(b));
+}
+
+// vector operator != : returns true for elements for which a != b
+static inline Vec16hb operator != (Vec16h const a, Vec16h const b) {
+    return Vec16fb2hb(to_float(a) != to_float(b));
+}
+
+// vector operator < : returns true for elements for which a < b
+static inline Vec16hb operator < (Vec16h const a, Vec16h const b) {
+    return Vec16fb2hb(to_float(a) < to_float(b));
+}
+
+// vector operator <= : returns true for elements for which a <= b
+static inline Vec16hb operator <= (Vec16h const a, Vec16h const b) {
+    return Vec16fb2hb(to_float(a) <= to_float(b));
+}
+
+// vector operator > : returns true for elements for which a > b
+static inline Vec16hb operator > (Vec16h const a, Vec16h const b) {
+    return Vec16fb2hb(to_float(a) > to_float(b));
+}
+
+// vector operator >= : returns true for elements for which a >= b
+static inline Vec16hb operator >= (Vec16h const a, Vec16h const b) {
+    return Vec16fb2hb(to_float(a) >= to_float(b));
+}
+
+
+// Bitwise logical operators
+
+// vector operator & : bitwise and
+static inline Vec16h operator & (Vec16h const a, Vec16h const b) {
+#if INSTRSET >= 8         
+    return _mm256_and_si256(__m256i(a), __m256i(b));
+#else
+    return Vec16h(a.get_low() & b.get_low(), a.get_high() & b.get_high());
+#endif
+}
+
+// vector operator &= : bitwise and
+static inline Vec16h & operator &= (Vec16h & a, Vec16h const b) {
+    a = a & b;
+    return a;
+}
+
+// vector operator & : bitwise and of Vec16h and Vec16hb
+static inline Vec16h operator & (Vec16h const a, Vec16hb const b) {
+#if INSTRSET >= 10         
+    return __m256i(_mm256_maskz_mov_epi16(b, __m256i(a)));
+#elif INSTRSET >= 8
+    return _mm256_and_si256(__m256i(a), __m256i(b));
+#else
+    return Vec16h(a.get_low() & b.get_low(), a.get_high() & b.get_high());
+#endif
+}
+static inline Vec16h operator & (Vec16hb const a, Vec16h const b) {
+    return b & a;
+}
+
+// vector operator | : bitwise or
+static inline Vec16h operator | (Vec16h const a, Vec16h const b) {
+#if INSTRSET >= 8         
+    return _mm256_or_si256(__m256i(a), __m256i(b));
+#else
+    return Vec16h(a.get_low() | b.get_low(), a.get_high() | b.get_high());
+#endif
+}
+
+// vector operator |= : bitwise or
+static inline Vec16h & operator |= (Vec16h & a, Vec16h const b) {
+    a = a | b;
+    return a;
+}
+
+// vector operator ^ : bitwise xor
+static inline Vec16h operator ^ (Vec16h const a, Vec16h const b) {
+#if INSTRSET >= 8         
+    return _mm256_xor_si256(__m256i(a), __m256i(b));
+#else
+    return Vec16h(a.get_low() ^ b.get_low(), a.get_high() ^ b.get_high());
+#endif
+}
+
+// vector operator ^= : bitwise xor
+static inline Vec16h & operator ^= (Vec16h & a, Vec16h const b) {
+    a = a ^ b;
+    return a;
+}
+
+// vector operator ! : logical not. Returns Boolean vector
+static inline Vec16hb operator ! (Vec16h const a) {
+    return a == Vec16h(Float16(0.0f));
+}
+
+/*****************************************************************************
+*
+*          Functions for reinterpretation between vector types
+*
+*****************************************************************************/
+#if INSTRSET >= 8
+static inline __m256i reinterpret_h(__m256i const x) {
+    return x;
+}
+
+#if defined(__GNUC__) && __GNUC__ <= 9 // GCC v. 9 is missing the _mm256_zextsi128_si256 intrinsic
+static inline Vec16h extend_z(Vec8h a) {
+    return Vec16h(a, Vec8h(Float16(0.f)));
+}
+
+#else
+static inline Vec16h extend_z(Vec8h a) {
+    return _mm256_zextsi128_si256(a);
+}
+#endif
+
+#else // INSTRSET
+
+static inline Vec16h reinterpret_h(Vec16s const x) {
+    return Vec16h(Vec8h(x.get_low()), Vec8h(x.get_high()));
+}
+
+static inline Vec16s reinterpret_i(Vec16h const x) {
+    return Vec16s(Vec8s(x.get_low()), Vec8s(x.get_high()));
+}
+
+static inline Vec16h extend_z(Vec8h a) {
+    return Vec16h(a, Vec8h(0));
+}
+
+#endif  // INSTRSET
+
+
+/*****************************************************************************
+*
+*          Functions for Vec16h
+*
+*****************************************************************************/
+
+// Select between two operands. Corresponds to this pseudocode:
+// for (int i = 0; i < 4; i++) result[i] = s[i] ? a[i] : b[i];
+static inline Vec16h select(Vec16hb const s, Vec16h const a, Vec16h const b) {
+#if INSTRSET >= 10
+    return __m256i(_mm256_mask_mov_epi16(__m256i(b), s, __m256i(a)));
+#elif INSTRSET >= 8
+    return __m256i(select(Vec16sb(s), Vec16s(__m256i(a)), Vec16s(__m256i(b))));
+#else
+    return Vec16h(select(s.get_low(), a.get_low(), b.get_low()), select(s.get_high(), a.get_high(), b.get_high()));
+#endif
+}
+
+// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]
+static inline Vec16h if_add(Vec16hb const f, Vec16h const a, Vec16h const b) {
+#if INSTRSET >= 8
+    return a + (b & f);
+#else
+    return select(f, a+b, a);
+#endif
+}
+
+// Conditional subtract: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]
+static inline Vec16h if_sub(Vec16hb const f, Vec16h const a, Vec16h const b) {
+#if INSTRSET >= 8
+    return a - (b & f);
+#else
+    return select(f, a-b, a);
+#endif
+}
+
+// Conditional multiply: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]
+static inline Vec16h if_mul(Vec16hb const f, Vec16h const a, Vec16h const b) {
+    return select(f, a*b, a);
+}
+
+// Conditional divide: For all vector elements i: result[i] = f[i] ? (a[i] / b[i]) : a[i]
+static inline Vec16h if_div(Vec16hb const f, Vec16h const a, Vec16h const b) {
+    return select(f, a/b, a);
+}
+
+// Sign functions
+
+// Function sign_bit: gives true for elements that have the sign bit set
+// even for -0.0f, -INF and -NAN
+// Note that sign_bit(Vec16h(-0.0f16)) gives true, while Vec16h(-0.0f16) < Vec16h(0.0f16) gives false
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec16hb sign_bit(Vec16h const a) {
+    Vec16s t1 = reinterpret_i(a);                // reinterpret as 16-bit integer
+    Vec16s t2 = t1 >> 15;                        // extend sign bit
+    return t2 != 0;
+}
+
+// Function sign_combine: changes the sign of a when b has the sign bit set
+// same as select(sign_bit(b), -a, a)
+static inline Vec16h sign_combine(Vec16h const a, Vec16h const b) {
+    return a ^ (b & Vec16h(Float16(-0.0)));
+}
+
+// Categorization functions
+
+// Function is_finite: gives true for elements that are normal, subnormal or zero,
+// false for INF and NAN
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec16hb is_finite(Vec16h const a) {
+    return (Vec16s(reinterpret_i(a)) & 0x7C00) != 0x7C00;
+}
+
+// Function is_inf: gives true for elements that are +INF or -INF
+// false for finite numbers and NAN
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec16hb is_inf(Vec16h const a) {
+    return (Vec16s(reinterpret_i(a)) & 0x7FFF) == 0x7C00;
+}
+
+// Function is_nan: gives true for elements that are +NAN or -NAN
+// false for finite numbers and +/-INF
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec16hb is_nan(Vec16h const a) {
+    return (Vec16s(reinterpret_i(a)) & 0x7FFF) > 0x7C00;
+}
+
+// Function is_subnormal: gives true for elements that are subnormal
+// false for finite numbers, zero, NAN and INF
+static inline Vec16hb is_subnormal(Vec16h const a) {
+    return (Vec16s(reinterpret_i(a)) & 0x7C00) == 0 && (Vec16s(reinterpret_i(a)) & 0x03FF) != 0;
+}
+
+// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal
+// false for finite numbers, NAN and INF
+static inline Vec16hb is_zero_or_subnormal(Vec16h const a) {
+    return (Vec16s(reinterpret_i(a)) & 0x7C00) == 0;
+} 
+
+// Function infinite16h: returns a vector where all elements are +INF
+static inline Vec16h infinite16h() {
+    return reinterpret_h(Vec16s(0x7C00));
+}
+
+// template for producing quiet NAN
+template <>
+Vec16h nan_vec<Vec16h>(uint32_t payload) {
+    if constexpr (Vec16h::elementtype() == 15) {  // Float16
+        return reinterpret_h(Vec16s(0x7E00 | (payload & 0x01FF)));
+    }
+} 
+
+// Function nan16h: returns a vector where all elements are NAN (quiet)
+static inline Vec16h nan16h(int n = 0x10) {
+    return nan_vec<Vec16h>(n);
+}
+
+// This function returns the code hidden in a NAN. The sign bit is ignored
+static inline Vec16us nan_code(Vec16h const x) {
+    Vec16us a = Vec16us(reinterpret_i(x));
+    Vec16us const n = 0x3FF;
+    return select(is_nan(x), a & n, Vec16us(0));
+}
+
+
+// General arithmetic functions, etc.
+
+// Horizontal add: Calculates the sum of all vector elements.
+static inline Float16 horizontal_add(Vec16h const a) {
+    return horizontal_add(a.get_low()+a.get_high());
+}
+// same, with high precision
+static inline float horizontal_add_x(Vec16h const a) {
+    return horizontal_add(to_float(a));
+}
+
+// function max: a > b ? a : b
+static inline Vec16h max(Vec16h const a, Vec16h const b) {
+    return to_float16(max(to_float(a), to_float(b)));
+}
+
+// function min: a < b ? a : b
+static inline Vec16h min(Vec16h const a, Vec16h const b) {
+    return to_float16(min(to_float(a), to_float(b)));
+}
+// NAN-safe versions of maximum and minimum are in vector_convert.h
+
+// function abs: absolute value
+static inline Vec16h abs(Vec16h const a) {
+    return reinterpret_h(Vec16s(reinterpret_i(a)) & 0x7FFF);
+}
+
+// function sqrt: square root
+static inline Vec16h sqrt(Vec16h const a) {
+    return to_float16(sqrt(to_float(a)));
+}
+
+// function square: a * a
+static inline Vec16h square(Vec16h const a) {
+    return a * a;
+}
+
+// The purpose of this template is to prevent implicit conversion of a float
+// exponent to int when calling pow(vector, float) and vectormath_exp.h is not included
+template <typename TT> static Vec16h pow(Vec16h const a, TT const n);  // = delete
+
+// Raise floating point numbers to integer power n
+template <>
+inline Vec16h pow<int>(Vec16h const x0, int const n) {
+    return pow_template_i<Vec16h>(x0, n);
+}
+
+// allow conversion from unsigned int
+template <>
+inline Vec16h pow<uint32_t>(Vec16h const x0, uint32_t const n) {
+    return pow_template_i<Vec16h>(x0, (int)n);
+}
+
+// Raise floating point numbers to integer power n, where n is a compile-time constant:
+// Template in vectorf28.h is used
+//template <typename V, int n>
+//static inline V pow_n(V const a);
+
+// implement as function pow(vector, const_int)
+template <int n>
+static inline Vec16h pow(Vec16h const a, Const_int_t<n>) {
+    return pow_n<Vec16h, n>(a);
+} 
+
+
+static inline Vec16h round(Vec16h const a) {
+    return to_float16(round(to_float(a)));
+}
+
+// function truncate: round towards zero. (result as float vector)
+static inline Vec16h truncate(Vec16h const a) {
+    return to_float16(truncate(to_float(a)));
+}
+
+// function floor: round towards minus infinity. (result as float vector)
+static inline Vec16h floor(Vec16h const a) {
+    return to_float16(floor(to_float(a)));
+}
+
+// function ceil: round towards plus infinity. (result as float vector)
+static inline Vec16h ceil(Vec16h const a) {
+    return to_float16(ceil(to_float(a)));
+}
+
+
+// function roundi: round to nearest integer (even). (result as integer vector)
+static inline Vec16s roundi(Vec16h const a) {
+    // Note: assume MXCSR control register is set to rounding
+    return compress_saturated(roundi(to_float(a)));
+}
+
+// function truncatei: round towards zero. (result as integer vector)
+static inline Vec16s truncatei(Vec16h const a) {
+    return compress_saturated(truncatei(to_float(a)));
+}
+
+// function to_float: convert integer vector to float vector
+static inline Vec16h to_float16(Vec16s const a) {
+    return to_float16(to_float(extend(a)));
+}
+
+// function to_float: convert unsigned integer vector to float vector
+static inline Vec16h to_float16(Vec16us const a) {
+    return to_float16(to_float(extend(a)));
+}
+
+
+// Approximate math functions
+
+// reciprocal (almost exact)
+static inline Vec16h approx_recipr(Vec16h const a) {
+    return to_float16(approx_recipr(to_float(a)));
+}
+
+// reciprocal squareroot (almost exact)
+static inline Vec16h approx_rsqrt(Vec16h const a) {
+    return to_float16(approx_rsqrt(to_float(a)));
+}
+
+// Fused multiply and add functions
+
+// Multiply and add. a*b+c
+static inline Vec16h mul_add(Vec16h const a, Vec16h const b, Vec16h const c) {
+    return to_float16(mul_add(to_float(a),to_float(b),to_float(c)));
+}
+
+// Multiply and subtract. a*b-c
+static inline Vec16h mul_sub(Vec16h const a, Vec16h const b, Vec16h const c) {
+    return to_float16(mul_sub(to_float(a),to_float(b),to_float(c)));
+}
+
+// Multiply and inverse subtract
+static inline Vec16h nmul_add(Vec16h const a, Vec16h const b, Vec16h const c) {
+    return to_float16(nmul_add(to_float(a),to_float(b),to_float(c)));
+}
+
+// Math functions using fast bit manipulation
+
+// Extract the exponent as an integer
+// exponent(a) = floor(log2(abs(a)));
+// exponent(1.0f) = 0, exponent(0.0f) = -127, exponent(INF) = +128, exponent(NAN) = +128
+static inline Vec16s exponent(Vec16h const a) {
+    Vec16us t1 = reinterpret_i(a);         // reinterpret as 16-bit integer
+    Vec16us t2 = t1 << 1;                  // shift out sign bit
+    Vec16us t3 = t2 >> 11;                 // shift down logical to position 0
+    Vec16s  t4 = Vec16s(t3) - 0x0F;        // subtract bias from exponent
+    return t4;
+}
+
+// Extract the fraction part of a floating point number
+// a = 2^exponent(a) * fraction(a), except for a = 0
+// fraction(1.0f) = 1.0f, fraction(5.0f) = 1.25f
+// NOTE: The name fraction clashes with an ENUM in MAC XCode CarbonCore script.h !
+static inline Vec16h fraction(Vec16h const a) {
+    Vec16us t1 = reinterpret_i(a);   // reinterpret as 16-bit integer
+    Vec16us t2 = Vec16us((t1 & 0x3FF) | 0x3C00); // set exponent to 0 + bias
+    return reinterpret_h(t2);
+}
+
+// Fast calculation of pow(2,n) with n integer
+// n  =    0 gives 1.0f
+// n >=  16 gives +INF
+// n <= -15 gives 0.0f
+// This function will never produce subnormals, and never raise exceptions
+static inline Vec16h exp2(Vec16s const n) {
+    Vec16s t1 = max(n, -15);            // limit to allowed range
+    Vec16s t2 = min(t1, 16);
+    Vec16s t3 = t2 + 15;                // add bias
+    Vec16s t4 = t3 << 10;               // put exponent into position 10
+    return reinterpret_h(t4);           // reinterpret as float
+}
+
+// change signs on vectors Vec16h
+// Each index i0 - i15 is 1 for changing sign on the corresponding element, 0 for no change
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, 
+int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15>
+Vec16h change_sign(Vec16h const a) {
+#if INSTRSET >= 8
+    if constexpr ((i0 | i1 | i2 | i3 | i4 | i5 | i6 | i7 | i8 | i9 | i10 | i11 | i12 | i13 | i14 | i15) == 0) return a;
+    __m256i mask = constant8ui<
+        (i0  ? 0x8000 : 0) | (i1  ? 0x80000000 : 0), 
+        (i2  ? 0x8000 : 0) | (i3  ? 0x80000000 : 0), 
+        (i4  ? 0x8000 : 0) | (i5  ? 0x80000000 : 0), 
+        (i6  ? 0x8000 : 0) | (i7  ? 0x80000000 : 0), 
+        (i8  ? 0x8000 : 0) | (i9  ? 0x80000000 : 0), 
+        (i10 ? 0x8000 : 0) | (i11 ? 0x80000000 : 0), 
+        (i12 ? 0x8000 : 0) | (i13 ? 0x80000000 : 0), 
+        (i14 ? 0x8000 : 0) | (i15 ? 0x80000000 : 0) >();
+    return Vec16h(_mm256_xor_si256(a, mask));     // flip sign bits
+#else
+    return Vec16h(change_sign<i0,i1,i2,i3,i4,i5,i6,i7>(a.get_low()), change_sign<i8,i9,i10,i11,i12,i13,i14,i15>(a.get_high()));
+#endif
+}
+
+
+/*****************************************************************************
+*
+*          Vector permute and blend functions
+*
+******************************************************************************
+*
+* The permute function can reorder the elements of a vector and optionally
+* set some elements to zero.
+*
+* See vectori128.h for details
+*
+*****************************************************************************/
+// permute vector Vec16h
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, 
+int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15>
+Vec16h permute16(Vec16h const a) {
+    return reinterpret_h (
+    permute16<i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15> (
+    Vec16s(reinterpret_i(a))));
+}
+
+/*****************************************************************************
+*
+*          Vector blend functions
+*
+*****************************************************************************/
+
+// permute and blend Vec16h
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, 
+int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15>
+static inline Vec16h blend16(Vec16h const a, Vec16h const b) {
+    return reinterpret_h (
+    blend16<i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15> (
+    Vec16s(reinterpret_i(a)), Vec16s(reinterpret_i(b))));
+}
+
+
+/*****************************************************************************
+*
+*          Vector lookup functions
+*
+******************************************************************************
+*
+* These functions use vector elements as indexes into a table.
+* The table is given as one or more vectors or as an array.
+*
+*****************************************************************************/
+
+static inline Vec16h lookup16 (Vec16s const index, Vec16h const table) {
+    return reinterpret_h(lookup16(index, Vec16s(reinterpret_i(table))));
+}
+
+template <int n>
+static inline Vec16h lookup(Vec16s const index, void const * table) {
+    return reinterpret_h(lookup<n>(index, (void const *)(table)));
+}
+
+// prevent implicit type conversions
+bool horizontal_and(Vec16h x) = delete;
+bool horizontal_or(Vec16h x) = delete;
+
+#endif // MAX_VECTOR_SIZE >= 256
+
+
+
+/*****************************************************************************
+*
+*          512 bit vectors
+*
+*****************************************************************************/
+
+#if MAX_VECTOR_SIZE >= 512
+
+
+/*****************************************************************************
+*
+*          Vec32hb: Vector of 32 Booleans for use with Vec32h
+*
+*****************************************************************************/
+
+#if INSTRSET >= 10
+typedef Vec32b Vec32hb;   // compact boolean vector
+
+#else
+
+typedef Vec32sb Vec32hb;  // broad boolean vector
+
+#endif
+
+ 
+/*****************************************************************************
+*
+*          Vec32h: Vector of 4 single precision floating point values
+*
+*****************************************************************************/
+
+class Vec32h : public Vec32s {
+public:
+    // Default constructor:
+    Vec32h() = default;
+    // Constructor to broadcast the same value into all elements:
+    Vec32h(Float16 f) : Vec32s(castfp162s(f)) {}   
+    Vec32h(float f) : Vec32s(castfp162s(Float16(f))) {} 
+
+    // Copy constructor
+    Vec32h (Vec32h const &x) = default;
+
+    // Copy assignment operator
+    Vec32h & operator = (Vec32h const& x) = default;
+
+    // Constructor to build from all elements:
+    Vec32h(Float16 f0, Float16 f1, Float16 f2, Float16 f3, Float16 f4, Float16 f5, Float16 f6, Float16 f7,
+    Float16 f8, Float16 f9, Float16 f10, Float16 f11, Float16 f12, Float16 f13, Float16 f14, Float16 f15,
+    Float16 f16, Float16 f17, Float16 f18, Float16 f19, Float16 f20, Float16 f21, Float16 f22, Float16 f23,
+    Float16 f24, Float16 f25, Float16 f26, Float16 f27, Float16 f28, Float16 f29, Float16 f30, Float16 f31) :
+        Vec32s (castfp162s(f0), castfp162s(f1), castfp162s(f2), castfp162s(f3), castfp162s(f4), castfp162s(f5), castfp162s(f6), castfp162s(f7), 
+            castfp162s(f8), castfp162s(f9), castfp162s(f10), castfp162s(f11), castfp162s(f12), castfp162s(f13), castfp162s(f14), castfp162s(f15),
+            castfp162s(f16), castfp162s(f17), castfp162s(f18), castfp162s(f19), castfp162s(f20), castfp162s(f21), castfp162s(f22), castfp162s(f23),
+            castfp162s(f24), castfp162s(f25), castfp162s(f26), castfp162s(f27), castfp162s(f28), castfp162s(f29), castfp162s(f30), castfp162s(f31))
+    {}
+    // Constructor to build from two Vec16h:
+    Vec32h(Vec16h const a0, Vec16h const a1) : Vec32s(Vec16h(a0), Vec16h(a1)) {}
+
+    // Constructor to convert from type __m512i used in intrinsics:
+#if INSTRSET >= 10
+    Vec32h(__m512i const x) {
+        zmm = x;
+    }
+    // Assignment operator to convert from type __m256i used in intrinsics:
+    Vec32h & operator = (__m512i const x) {
+        zmm = x;
+        return *this;
+    }
+    // Type cast operator to convert to __m256i used in intrinsics
+    operator __m512i() const {
+        return zmm;
+    }
+#else
+    // Constructor to convert from type Vec32s. This may cause undesired implicit conversions and ambiguities
+    // Vec32h(Vec32s const x) : Vec32s(x) {  }
+#endif
+    // Member function to load from array (unaligned)
+    Vec32h & load(void const * p) {
+        Vec32s::load(p);
+        return *this;
+    }
+    // Member function to load from array, aligned by 64
+    // You may use load_a instead of load if you are certain that p points to an address
+    // divisible by 64. In most cases there is no difference in speed between load and load_a
+    Vec32h & load_a(void const * p) {
+        Vec32s::load_a(p);
+        return *this;
+    }
+    // Member function to store into array (unaligned)
+    // void store(void * p) const // inherited from Vec32s
+
+    // Member function storing into array, aligned by 64
+    // You may use store_a instead of store if you are certain that p points to an address
+    // divisible by 64.
+    //void store_a(void * p) const // inherited from Vec32s
+
+    // Member function storing to aligned uncached memory (non-temporal store).
+    // This may be more efficient than store_a when storing large blocks of memory if it 
+    // is unlikely that the data will stay in the cache until it is read again.
+    // Note: Will generate runtime error if p is not aligned by 64
+    // void store_nt(void * p) const // inherited from Vec32s
+
+    // Partial load. Load n elements and set the rest to 0
+    Vec32h & load_partial(int n, void const * p) {
+        Vec32s::load_partial(n, p);
+        return *this;
+    }
+    // Partial store. Store n elements
+    // void store_partial(int n, void * p) const // inherited from Vec32s
+
+    // cut off vector to n elements. The last 8-n elements are set to zero
+    Vec32h & cutoff(int n) {
+        Vec32s::cutoff(n);
+        return *this;
+    }
+    // Member function to change a single element in vector
+    Vec32h const insert(int index, Float16 a) {
+        Vec32s::insert(index, castfp162s(a));
+        return *this;
+    }
+    // Member function extract a single element from vector
+    Float16 extract(int index) const {
+        return casts2fp16(Vec32s::extract(index));
+    }
+    // Extract a single element. Use store function if extracting more than one element.
+    // Operator [] can only read an element, not write.
+    Float16 operator [] (int index) const {
+        return extract(index);
+    }
+    Vec16h get_low() const {
+#if INSTRSET >= 8
+        return __m256i(Vec32s::get_low());
+#else
+        return reinterpret_h(Vec32s::get_low());
+#endif
+    }
+
+    Vec16h get_high() const {
+#if INSTRSET >= 8
+        return __m256i(Vec32s::get_high());
+#else
+        return reinterpret_h(Vec32s::get_high());
+#endif
+    }
+    static constexpr int size() {
+        return 32;
+    }
+    static constexpr int elementtype() {
+        return 15;
+    }
+};
+
+
+/*****************************************************************************
+*
+*          Operators for Vec32h
+*
+*****************************************************************************/
+
+// vector operator + : add element by element
+static inline Vec32h operator + (Vec32h const a, Vec32h const b) {
+    return Vec32h(a.get_low() + b.get_low(), a.get_high() + b.get_high());
+}
+
+// vector operator + : add vector and scalar
+static inline Vec32h operator + (Vec32h const a, Float16 b) {
+    return a + Vec32h(b);
+}
+static inline Vec32h operator + (Float16 a, Vec32h const b) {
+    return Vec32h(a) + b;
+}
+
+// vector operator += : add
+static inline Vec32h & operator += (Vec32h & a, Vec32h const b) {
+    a = a + b;
+    return a;
+}
+
+// postfix operator ++
+static inline Vec32h operator ++ (Vec32h & a, int) {
+    Vec32h a0 = a;
+    a = a + Float16(1.f);
+    return a0;
+}
+
+// prefix operator ++
+static inline Vec32h & operator ++ (Vec32h & a) {
+    a = a + Float16(1.f);
+    return a;
+}
+
+// vector operator - : subtract element by element
+static inline Vec32h operator - (Vec32h const a, Vec32h const b) {
+    return Vec32h(a.get_low() - b.get_low(), a.get_high() - b.get_high());
+}
+
+// vector operator - : subtract vector and scalar
+static inline Vec32h operator - (Vec32h const a, Float16 b) {
+    return a - Vec32h(b);
+}
+static inline Vec32h operator - (Float16 a, Vec32h const b) {
+    return Vec32h(a) - b;
+}
+
+// vector operator - : unary minus
+// Change sign bit, even for 0, INF and NAN
+static inline Vec32h operator - (Vec32h const a) {
+#if INSTRSET >= 10  // AVX2
+    return _mm512_xor_si512(a, _mm512_set1_epi32(0x80008000));
+#else
+    return Vec32h(-a.get_low(), -a.get_high());
+#endif
+}
+
+// vector operator -= : subtract
+static inline Vec32h & operator -= (Vec32h & a, Vec32h const b) {
+    a = a - b;
+    return a;
+}
+
+// postfix operator --
+static inline Vec32h operator -- (Vec32h & a, int) {
+    Vec32h a0 = a;
+    a = a - Vec32h(Float16(1.f));
+    return a0;
+}
+
+// prefix operator --
+static inline Vec32h & operator -- (Vec32h & a) {
+    a = a - Vec32h(Float16(1.f));
+    return a;
+}
+
+// vector operator * : multiply element by element
+static inline Vec32h operator * (Vec32h const a, Vec32h const b) {
+    return Vec32h(a.get_low() * b.get_low(), a.get_high() * b.get_high());
+}
+
+// vector operator * : multiply vector and scalar
+static inline Vec32h operator * (Vec32h const a, Float16 b) {
+    return a * Vec32h(b);
+}
+static inline Vec32h operator * (Float16 a, Vec32h const b) {
+    return Vec32h(a) * b;
+}
+
+// vector operator *= : multiply
+static inline Vec32h & operator *= (Vec32h & a, Vec32h const b) {
+    a = a * b;
+    return a;
+}
+
+// vector operator / : divide all elements by same integer
+static inline Vec32h operator / (Vec32h const a, Vec32h const b) {
+    return Vec32h(a.get_low() / b.get_low(), a.get_high() / b.get_high());
+}
+
+// vector operator / : divide vector and scalar
+static inline Vec32h operator / (Vec32h const a, Float16 b) {
+    return a / Vec32h(b);
+}
+static inline Vec32h operator / (Float16 a, Vec32h const b) {
+    return Vec32h(a) / b;
+}
+
+// vector operator /= : divide
+static inline Vec32h & operator /= (Vec32h & a, Vec32h const b) {
+    a = a / b;
+    return a;
+}
+
+// vector operator == : returns true for elements for which a == b
+static inline Vec32hb operator == (Vec32h const a, Vec32h const b) {
+    return Vec32hb(a.get_low() == b.get_low(), a.get_high() == b.get_high());
+}
+
+// vector operator != : returns true for elements for which a != b
+static inline Vec32hb operator != (Vec32h const a, Vec32h const b) {
+    return Vec32hb(a.get_low() != b.get_low(), a.get_high() != b.get_high());
+}
+
+// vector operator < : returns true for elements for which a < b
+static inline Vec32hb operator < (Vec32h const a, Vec32h const b) {
+    return Vec32hb(a.get_low() < b.get_low(), a.get_high() < b.get_high());
+}
+
+// vector operator <= : returns true for elements for which a <= b
+static inline Vec32hb operator <= (Vec32h const a, Vec32h const b) {
+    return Vec32hb(a.get_low() <= b.get_low(), a.get_high() <= b.get_high());
+}
+
+// vector operator > : returns true for elements for which a > b
+static inline Vec32hb operator > (Vec32h const a, Vec32h const b) {
+    return Vec32hb(a.get_low() > b.get_low(), a.get_high() > b.get_high());
+}
+
+// vector operator >= : returns true for elements for which a >= b
+static inline Vec32hb operator >= (Vec32h const a, Vec32h const b) {
+    return Vec32hb(a.get_low() >= b.get_low(), a.get_high() >= b.get_high());
+}
+
+
+// Bitwise logical operators
+
+// vector operator & : bitwise and
+static inline Vec32h operator & (Vec32h const a, Vec32h const b) {
+#if INSTRSET >= 10         
+    return _mm512_and_si512(__m512i(a), __m512i(b));
+#else
+    return Vec32h(a.get_low() & b.get_low(), a.get_high() & b.get_high());
+#endif
+}
+
+// vector operator &= : bitwise and
+static inline Vec32h & operator &= (Vec32h & a, Vec32h const b) {
+    a = a & b;
+    return a;
+}
+
+// vector operator & : bitwise and of Vec32h and Vec32hb
+static inline Vec32h operator & (Vec32h const a, Vec32hb const b) {
+#if INSTRSET >= 10         
+    return _mm512_maskz_mov_epi16(b, a);
+#else
+    return Vec32h(a.get_low() & b.get_low(), a.get_high() & b.get_high());
+#endif
+}
+static inline Vec32h operator & (Vec32hb const a, Vec32h const b) {
+    return b & a;
+}
+
+// vector operator | : bitwise or
+static inline Vec32h operator | (Vec32h const a, Vec32h const b) {
+#if INSTRSET >= 10         
+    return _mm512_or_si512(__m512i(a), __m512i(b));
+#else
+    return Vec32h(a.get_low() | b.get_low(), a.get_high() | b.get_high());
+#endif
+}
+
+// vector operator |= : bitwise or
+static inline Vec32h & operator |= (Vec32h & a, Vec32h const b) {
+    a = a | b;
+    return a;
+}
+
+// vector operator ^ : bitwise xor
+static inline Vec32h operator ^ (Vec32h const a, Vec32h const b) {
+#if INSTRSET >= 10         
+    return _mm512_xor_si512(__m512i(a), __m512i(b));
+#else
+    return Vec32h(a.get_low() ^ b.get_low(), a.get_high() ^ b.get_high());
+#endif
+}
+
+// vector operator ^= : bitwise xor
+static inline Vec32h & operator ^= (Vec32h & a, Vec32h const b) {
+    a = a ^ b;
+    return a;
+}
+
+// vector operator ! : logical not. Returns Boolean vector
+static inline Vec32hb operator ! (Vec32h const a) {
+    return a == Vec32h(Float16(0.f));
+}
+
+
+/*****************************************************************************
+*
+*          Functions for reinterpretation between vector types
+*
+*****************************************************************************/
+#if INSTRSET >= 10
+static inline __m512i reinterpret_h(__m512i const x) {
+    return x;
+}
+
+#if defined(__GNUC__) && __GNUC__ <= 9 // GCC v. 9 is missing the _mm512_zextsi256_si512 intrinsic
+static inline Vec32h extend_z(Vec16h a) {
+    return Vec32h(a, Vec16h(0));
+}
+#else
+static inline Vec32h extend_z(Vec16h a) {
+    return _mm512_zextsi256_si512(a);
+}
+#endif
+#else
+
+static inline Vec32h reinterpret_h(Vec32s const x) {
+    return Vec32h(Vec16h(reinterpret_h(x.get_low())), Vec16h(reinterpret_h(x.get_high())));
+}
+
+static inline Vec32s reinterpret_i(Vec32h const x) {
+    return Vec32s(Vec16s(x.get_low()), Vec16s(x.get_high()));
+}
+
+static inline Vec32h extend_z(Vec16h a) {
+    return Vec32h(a, Vec16h(Float16(0.f)));
+}
+
+#endif
+
+
+/*****************************************************************************
+*
+*          Functions for Vec32h
+*
+*****************************************************************************/
+
+// Select between two operands. Corresponds to this pseudocode:
+// for (int i = 0; i < 4; i++) result[i] = s[i] ? a[i] : b[i];
+static inline Vec32h select(Vec32hb const s, Vec32h const a, Vec32h const b) {
+#if INSTRSET >= 10
+    return __m512i(_mm512_mask_mov_epi16(__m512i(b), s, __m512i(a)));
+#else
+    return Vec32h(select(s.get_low(), a.get_low(), b.get_low()), select(s.get_high(), a.get_high(), b.get_high()));
+#endif
+}
+
+// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]
+static inline Vec32h if_add(Vec32hb const f, Vec32h const a, Vec32h const b) {
+    return a + (b & f);
+}
+
+// Conditional subtract: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]
+static inline Vec32h if_sub(Vec32hb const f, Vec32h const a, Vec32h const b) {
+    return a - (b & f);
+}
+
+// Conditional multiply: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]
+static inline Vec32h if_mul(Vec32hb const f, Vec32h const a, Vec32h const b) {
+    return select(f, a*b, a);
+}
+
+// Conditional divide: For all vector elements i: result[i] = f[i] ? (a[i] / b[i]) : a[i]
+static inline Vec32h if_div(Vec32hb const f, Vec32h const a, Vec32h const b) {
+    return select(f, a/b, a);
+}
+
+// Sign functions
+
+// Function sign_bit: gives true for elements that have the sign bit set
+// even for -0.0f, -INF and -NAN
+// Note that sign_bit(Vec32h(-0.0f16)) gives true, while Vec32h(-0.0f16) < Vec32h(0.0f16) gives false
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec32hb sign_bit(Vec32h const a) {
+    Vec32s t1 = reinterpret_i(a);          // reinterpret as 16-bit integer
+    Vec32s t2 = t1 >> 15;                  // extend sign bit
+    return t2 != 0;
+}
+
+// Function sign_combine: changes the sign of a when b has the sign bit set
+// same as select(sign_bit(b), -a, a)
+static inline Vec32h sign_combine(Vec32h const a, Vec32h const b) {
+    return a ^ (b & Vec32h(Float16(-0.0)));
+}
+
+// Categorization functions
+
+// Function is_finite: gives true for elements that are normal, subnormal or zero,
+// false for INF and NAN
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec32hb is_finite(Vec32h const a) {
+    return (Vec32s(reinterpret_i(a)) & 0x7C00) != 0x7C00;
+}
+
+// Function is_inf: gives true for elements that are +INF or -INF
+// false for finite numbers and NAN
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec32hb is_inf(Vec32h const a) {
+    return (Vec32s(reinterpret_i(a)) & 0x7FFF) == 0x7C00;
+}
+
+// Function is_nan: gives true for elements that are +NAN or -NAN
+// false for finite numbers and +/-INF
+// (the underscore in the name avoids a conflict with a macro in Intel's mathimf.h)
+static inline Vec32hb is_nan(Vec32h const a) {
+    return (Vec32s(reinterpret_i(a)) & 0x7FFF) > 0x7C00;
+}
+
+// Function is_subnormal: gives true for elements that are subnormal
+// false for finite numbers, zero, NAN and INF
+static inline Vec32hb is_subnormal(Vec32h const a) {
+    return (Vec32s(reinterpret_i(a)) & 0x7C00) == 0 && (Vec32s(reinterpret_i(a)) & 0x03FF) != 0;
+}
+
+// Function is_zero_or_subnormal: gives true for elements that are zero or subnormal
+// false for finite numbers, NAN and INF
+static inline Vec32hb is_zero_or_subnormal(Vec32h const a) {
+    return (Vec32s(reinterpret_i(a)) & 0x7C00) == 0;
+}
+
+// Function infinite32h: returns a vector where all elements are +INF
+static inline Vec32h infinite32h() {
+    return reinterpret_h(Vec32s(0x7C00));
+}
+
+// template for producing quiet NAN
+template <>
+Vec32h nan_vec<Vec32h>(uint32_t payload) {
+    if constexpr (Vec32h::elementtype() == 15) {  // Float16
+        return reinterpret_h(Vec32s(0x7E00 | (payload & 0x01FF)));
+    }
+} 
+
+// Function nan32h: returns a vector where all elements are NAN (quiet)
+static inline Vec32h nan32h(int n = 0x10) {
+    return nan_vec<Vec32h>(n);
+}
+
+// This function returns the code hidden in a NAN. The sign bit is ignored
+static inline Vec32us nan_code(Vec32h const x) {
+    Vec32us a = Vec32us(reinterpret_i(x));
+    Vec32us const n = 0x3FF;
+    return select(is_nan(x), a & n, Vec32us(0));
+}
+
+
+// General arithmetic functions, etc.
+
+// Horizontal add: Calculates the sum of all vector elements.
+static inline Float16 horizontal_add(Vec32h const a) {
+    return horizontal_add(a.get_low()+a.get_high());
+}
+// same, with high precision
+static inline float horizontal_add_x(Vec32h const a) {
+    return horizontal_add_x(a.get_low()) + horizontal_add_x(a.get_high());
+}
+
+// function max: a > b ? a : b
+static inline Vec32h max(Vec32h const a, Vec32h const b) {
+        return Vec32h(max(a.get_low(), b.get_low()), max(a.get_high(), b.get_high()));
+} 
+// function min: a < b ? a : b
+static inline Vec32h min(Vec32h const a, Vec32h const b) {
+        return Vec32h(min(a.get_low(), b.get_low()), min(a.get_high(), b.get_high()));
+}
+// NAN-safe versions of maximum and minimum are in vector_convert.h
+
+// function abs: absolute value
+static inline Vec32h abs(Vec32h const a) {
+    return reinterpret_h(Vec32s(reinterpret_i(a)) & 0x7FFF);
+}
+
+// function sqrt: square root
+static inline Vec32h sqrt(Vec32h const a) {
+    return Vec32h(sqrt(a.get_low()), sqrt(a.get_high()));
+}
+
+// function square: a * a
+static inline Vec32h square(Vec32h const a) {
+    return a * a;
+}
+
+// The purpose of this template is to prevent implicit conversion of a float
+// exponent to int when calling pow(vector, float) and vectormath_exp.h is not included
+template <typename TT> static Vec32h pow(Vec32h const a, TT const n);  // = delete
+
+// Raise floating point numbers to integer power n
+template <>
+inline Vec32h pow<int>(Vec32h const x0, int const n) {
+    return pow_template_i<Vec32h>(x0, n);
+}
+
+// allow conversion from unsigned int
+template <>
+inline Vec32h pow<uint32_t>(Vec32h const x0, uint32_t const n) {
+    return pow_template_i<Vec32h>(x0, (int)n);
+}
+
+// Raise floating point numbers to integer power n, where n is a compile-time constant:
+// Template in vectorf28.h is used
+//template <typename V, int n>
+//static inline V pow_n(V const a);
+
+// implement as function pow(vector, const_int)
+template <int n>
+static inline Vec32h pow(Vec32h const a, Const_int_t<n>) {
+    return pow_n<Vec32h, n>(a);
+}
+
+static inline Vec32h round(Vec32h const a) {
+    return Vec32h(round(a.get_low()), round(a.get_high()));
+}
+
+// function truncate: round towards zero. (result as float vector)
+static inline Vec32h truncate(Vec32h const a) {
+    return Vec32h(truncate(a.get_low()), truncate(a.get_high()));
+}
+
+// function floor: round towards minus infinity. (result as float vector)
+static inline Vec32h floor(Vec32h const a) {
+    return Vec32h(floor(a.get_low()), floor(a.get_high()));
+}
+
+// function ceil: round towards plus infinity. (result as float vector)
+static inline Vec32h ceil(Vec32h const a) {
+    return Vec32h(ceil(a.get_low()), ceil(a.get_high()));
+}
+
+// function roundi: round to nearest integer (even). (result as integer vector)
+static inline Vec32s roundi(Vec32h const a) {
+    return Vec32s(roundi(a.get_low()), roundi(a.get_high()));
+}
+
+// function truncatei: round towards zero. (result as integer vector)
+static inline Vec32s truncatei(Vec32h const a) {
+    return Vec32s(truncatei(a.get_low()), truncatei(a.get_high()));
+}
+
+// function to_float: convert integer vector to float vector
+static inline Vec32h to_float16(Vec32s const a) {
+    return Vec32h(to_float16(a.get_low()), to_float16(a.get_high()));
+}
+
+// function to_float: convert unsigned integer vector to float vector
+static inline Vec32h to_float16(Vec32us const a) {
+    return Vec32h(to_float16(a.get_low()), to_float16(a.get_high()));
+}
+
+// Approximate math functions
+
+// reciprocal (almost exact)
+static inline Vec32h approx_recipr(Vec32h const a) {
+    return Vec32h(approx_recipr(a.get_low()), approx_recipr(a.get_high()));
+}
+
+// reciprocal squareroot (almost exact)
+static inline Vec32h approx_rsqrt(Vec32h const a) {
+    return Vec32h(approx_rsqrt(a.get_low()), approx_rsqrt(a.get_high()));
+}
+
+// Fused multiply and add functions
+
+// Multiply and add. a*b+c
+static inline Vec32h mul_add(Vec32h const a, Vec32h const b, Vec32h const c) {
+    return Vec32h(mul_add(a.get_low(), b.get_low(), c.get_low()), mul_add(a.get_high(), b.get_high(), c.get_high()));
+}
+
+// Multiply and subtract. a*b-c
+static inline Vec32h mul_sub(Vec32h const a, Vec32h const b, Vec32h const c) {
+    return Vec32h(mul_sub(a.get_low(), b.get_low(), c.get_low()), mul_sub(a.get_high(), b.get_high(), c.get_high()));
+}
+
+// Multiply and inverse subtract
+static inline Vec32h nmul_add(Vec32h const a, Vec32h const b, Vec32h const c) {
+    return Vec32h(nmul_add(a.get_low(), b.get_low(), c.get_low()), nmul_add(a.get_high(), b.get_high(), c.get_high()));
+}
+
+// Math functions using fast bit manipulation
+
+// Extract the exponent as an integer
+// exponent(a) = floor(log2(abs(a)));
+// exponent(1.0f) = 0, exponent(0.0f) = -127, exponent(INF) = +128, exponent(NAN) = +128
+static inline Vec32s exponent(Vec32h const a) {
+    Vec32us t1 = reinterpret_i(a);         // reinterpret as 16-bit integer
+    Vec32us t2 = t1 << 1;                  // shift out sign bit
+    Vec32us t3 = t2 >> 11;                 // shift down logical to position 0
+    Vec32s  t4 = Vec32s(t3) - Vec32s(0x0F);// subtract bias from exponent
+    return t4;
+}
+
+// Extract the fraction part of a floating point number
+// a = 2^exponent(a) * fraction(a), except for a = 0
+// fraction(1.0f) = 1.0f, fraction(5.0f) = 1.25f
+// NOTE: The name fraction clashes with an ENUM in MAC XCode CarbonCore script.h !
+static inline Vec32h fraction(Vec32h const a) {
+    Vec32us t1 = reinterpret_i(a);   // reinterpret as 16-bit integer
+    Vec32us t2 = Vec32us((t1 & 0x3FF) | 0x3C00); // set exponent to 0 + bias
+    return reinterpret_h(t2);
+}
+
+// Fast calculation of pow(2,n) with n integer
+// n  =    0 gives 1.0f
+// n >=  16 gives +INF
+// n <= -15 gives 0.0f
+// This function will never produce subnormals, and never raise exceptions
+static inline Vec32h exp2(Vec32s const n) {
+    Vec32s t1 = max(n, -15);            // limit to allowed range
+    Vec32s t2 = min(t1, 16);
+    Vec32s t3 = t2 + Vec32s(15);        // add bias
+    Vec32s t4 = t3 << 10;               // put exponent into position 10
+    return reinterpret_h(t4);           // reinterpret as float
+}
+
+
+// change signs on vectors Vec32h
+// Each index i0 - i31 is 1 for changing sign on the corresponding element, 0 for no change
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, 
+int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15,
+int i16, int i17, int i18, int i19, int i20, int i21, int i22, int i23,
+int i24, int i25, int i26, int i27, int i28, int i29, int i30, int i31 >
+static inline Vec32h change_sign(Vec32h const a) {
+    
+#if INSTRSET >= 10
+    if constexpr ((i0 | i1 | i2 | i3 | i4 | i5 | i6 | i7 | i8 | i9 | i10 | i11 | i12 | i13 | i14 | i15) == 0) return a;
+    __m512i mask = constant16ui<
+        (i0  ? 0x8000 : 0) | (i1  ? 0x80000000 : 0), 
+        (i2  ? 0x8000 : 0) | (i3  ? 0x80000000 : 0), 
+        (i4  ? 0x8000 : 0) | (i5  ? 0x80000000 : 0), 
+        (i6  ? 0x8000 : 0) | (i7  ? 0x80000000 : 0), 
+        (i8  ? 0x8000 : 0) | (i9  ? 0x80000000 : 0), 
+        (i10 ? 0x8000 : 0) | (i11 ? 0x80000000 : 0), 
+        (i12 ? 0x8000 : 0) | (i13 ? 0x80000000 : 0), 
+        (i14 ? 0x8000 : 0) | (i15 ? 0x80000000 : 0),        
+        (i16 ? 0x8000 : 0) | (i17 ? 0x80000000 : 0), 
+        (i18 ? 0x8000 : 0) | (i19 ? 0x80000000 : 0), 
+        (i20 ? 0x8000 : 0) | (i21 ? 0x80000000 : 0), 
+        (i22 ? 0x8000 : 0) | (i23 ? 0x80000000 : 0), 
+        (i24 ? 0x8000 : 0) | (i25 ? 0x80000000 : 0), 
+        (i26 ? 0x8000 : 0) | (i27 ? 0x80000000 : 0), 
+        (i28 ? 0x8000 : 0) | (i29 ? 0x80000000 : 0), 
+        (i30 ? 0x8000 : 0) | (i31 ? 0x80000000 : 0) >();
+    return  _mm512_xor_si512(a, mask);     // flip sign bits
+#else
+    return Vec32h(change_sign<i0,i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15>(a.get_low()), 
+        change_sign<i16,i17,i18,i19,i20,i21,i22,i23,i24,i25,i26,i27,i28,i29,i30,i31>(a.get_high()));
+#endif
+}
+    
+/*****************************************************************************
+*
+*          Vector permute and blend functions
+*
+******************************************************************************
+*
+* The permute function can reorder the elements of a vector and optionally
+* set some elements to zero.
+*
+* See vectori128.h for details
+*
+*****************************************************************************/
+
+// permute vector Vec32h
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, 
+int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15,
+int i16, int i17, int i18, int i19, int i20, int i21, int i22, int i23,
+int i24, int i25, int i26, int i27, int i28, int i29, int i30, int i31 >
+static inline Vec32h permute32(Vec32h const a) {
+    return reinterpret_h (
+    permute32<i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
+    i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31 > (
+    Vec32s(reinterpret_i(a))));
+}
+
+/*****************************************************************************
+*
+*          Vector blend functions
+*
+*****************************************************************************/
+
+// permute and blend Vec32h
+template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, 
+int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15,
+int i16, int i17, int i18, int i19, int i20, int i21, int i22, int i23,
+int i24, int i25, int i26, int i27, int i28, int i29, int i30, int i31 >
+static inline Vec32h blend32(Vec32h const a, Vec32h const b) {
+    return reinterpret_h (
+    blend32<i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
+    i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31 > (
+    Vec32s(reinterpret_i(a)), Vec32s(reinterpret_i(b))));
+}
+
+
+/*****************************************************************************
+*
+*          Vector lookup functions
+*
+******************************************************************************
+*
+* These functions use vector elements as indexes into a table.
+* The table is given as one or more vectors or as an array.
+*
+*****************************************************************************/
+
+static inline Vec32h lookup32 (Vec32s const index, Vec32h const table) {
+    return reinterpret_h(lookup32(index, Vec32s(reinterpret_i(table))));
+}
+
+template <int n>
+static inline Vec32h lookup(Vec32s const index, void const * table) {
+    return reinterpret_h(lookup<n>(index, (void const *)(table)));
+}
+
+// prevent implicit type conversions
+bool horizontal_and(Vec32h x) = delete;
+bool horizontal_or(Vec32h x) = delete;
+
+
+#endif // MAX_VECTOR_SIZE >= 512
+
+
+/*****************************************************************************
+*
+*          Mathematical functions
+*
+*****************************************************************************/
+
+template <typename V>
+static inline V vf_pow2n (V const n) {
+    typedef decltype(roundi(n)) VI;
+    const float pow2_23 =  8388608.0;            // 2^23
+    const float bias = 127.0;                    // bias in exponent
+    V a = n + (bias + pow2_23);                  // put n + bias in least significant bits
+    VI b = reinterpret_i(a);                     // bit-cast to integer
+    VI c = b << 23;                              // shift left 23 places to get into exponent field
+    V d = reinterpret_f(c);                      // bit-cast back to float
+    return d;
+}
+
+// Template for exp function, half precision
+// The limit of abs(x) is defined by max_x below
+// This function does not produce denormals
+// Template parameters:
+// VTYPE:  float vector type
+// M1: 0 for exp, 1 for expm1
+// BA: 0 for exp, 1 for 0.5*exp, 2 for pow(2,x), 10 for pow(10,x)
+
+template<typename VTYPE, int M1, int BA>
+static inline VTYPE exp_h(VTYPE const initial_x) { 
+    // Taylor coefficients
+    const float P0expf   =  1.f/2.f;
+    const float P1expf   =  1.f/6.f;
+    const float P2expf   =  1.f/24.f;
+    VTYPE  x, r, x2, z, n2;                      // data vectors
+    // maximum abs(x), value depends on BA, defined below
+    // The lower limit of x is slightly more restrictive than the upper limit.
+    // We are specifying the lower limit, except for BA = 1 because it is not used for negative x
+    float max_x;
+    if constexpr (BA <= 1) { // exp(x)
+        //const float ln2f_hi  =  0.693359375f;
+        //const float ln2f_lo  = -2.12194440e-4f;
+        const float ln2f  =  0.69314718f;
+        max_x = (BA == 0) ? 87.3f : 89.0f;
+        x = initial_x;
+        r = round(initial_x*float(1.44269504089f)); //VM_LOG2E
+        x = nmul_add(r, VTYPE(ln2f), x);         //  x -= r * ln2f;
+    }
+    else if constexpr (BA == 2) {                // pow(2,x)
+        max_x = 126.f;
+        r = round(initial_x);
+        x = initial_x - r;
+        x = x * 0.69314718056f; // (float)VM_LN2;
+    }
+    else if constexpr (BA == 10) {               // pow(10,x)
+        max_x = 37.9f;
+        const float log10_2 = 0.30102999566f;   // log10(2)
+        x = initial_x;
+        r = round(initial_x*float(3.32192809489f)); // VM_LOG2E*VM_LN10
+        x = nmul_add(r, VTYPE(log10_2), x);      //  x -= r * log10_2
+        x = x * 2.30258509299f;  // (float)VM_LN10;
+    }
+    else  {  // undefined value of BA
+        return 0.;
+    }
+    x2 = x * x;
+    //z = polynomial_2(x,P0expf,P1expf,P2expf);
+    z = mul_add(x2, P2expf, mul_add(x, P1expf, P0expf));
+    z = mul_add(z, x2, x);                       // z *= x2;  z += x;
+    if constexpr (BA == 1) r--;                  // 0.5 * exp(x)
+    n2 = vf_pow2n(r);                            // multiply by power of 2
+    if constexpr (M1 == 0) {                     // exp        
+        z = (z + 1.0f) * n2;
+    }
+    else {                                       // expm1
+        z = mul_add(z, n2, n2 - 1.0f);           //  z = z * n2 + (n2 - 1.0f);
+#ifdef SIGNED_ZERO                               // pedantic preservation of signed zero
+        z = select(initial_x == 0.f, initial_x, z);
+#endif
+    }
+    // check for overflow
+    auto inrange  = abs(initial_x) < max_x;      // boolean vector
+    // check for INF and NAN
+    inrange &= is_finite(initial_x);
+    if (horizontal_and(inrange)) {               // fast normal path
+        return z;
+    }
+    else {
+        // overflow, underflow and NAN
+        VTYPE inf = 1.e20f;                                // will overflow to INF
+        r = select(sign_bit(initial_x), 0.f-(M1&1), inf);  // value in case of +/- overflow or INF
+        z = select(inrange, z, r);                         // +/- underflow
+        z = select(is_nan(initial_x), initial_x, z);       // NAN goes through
+        return z;
+    }
+}
+
+
+// Template for trigonometric functions
+// Template parameters:
+// VTYPE:  vector type
+// SC:     1 = sin, 2 = cos, 3 = sincos, 4 = tan, 8 = multiply by pi
+// Parameters:
+// xx = input x (radians)
+// cosret = return pointer (only if SC = 3)
+template<typename VTYPE, int SC>
+static inline VTYPE sincos_h(VTYPE * cosret, VTYPE const xx) {
+
+    // define constants
+    const float DP1F = 0.78515625f * 2.f;
+    const float DP2F = 2.4187564849853515625E-4f * 2.f;
+    const float DP3F = 3.77489497744594108E-8f * 2.f;
+
+    const float P0sinf = -1.6666654611E-1f;
+    const float P1sinf = 8.3321608736E-3f;
+
+    const float P0cosf = 4.166664568298827E-2f;
+    const float P1cosf = -1.388731625493765E-3f;
+
+    const float pi     = 3.14159265358979323846f;// pi
+    const float c2_pi  = float(2./3.14159265358979323846); // 2/pi
+
+    typedef decltype(roundi(xx)) ITYPE;          // integer vector type
+    typedef decltype(xx < xx) BVTYPE;            // boolean vector type
+
+    VTYPE  xa, x, y, x2, s, c, sin1, cos1;       // data vectors
+    ITYPE  q;                                    // integer vector
+    BVTYPE swap;                                 // boolean vector
+
+    xa = abs(xx);
+
+    // Find quadrant
+    if constexpr ((SC & 8) != 0) {
+        y = round(xa * VTYPE(2.0f));
+    }
+    else {
+        xa = select(xa > VTYPE(314.25f), VTYPE(0.f), xa); // avoid meaningless results for high x
+        y = round(xa * c2_pi);                   // quadrant, as float
+    }
+    q = roundi(y);                               // quadrant, as integer
+    //      0 -   pi/4 => 0
+    //   pi/4 - 3*pi/4 => 1
+    // 3*pi/4 - 5*pi/4 => 2
+    // 5*pi/4 - 7*pi/4 => 3
+    // 7*pi/4 - 8*pi/4 => 4
+
+    if constexpr ((SC & 8) != 0) {               // sinpi
+        // modulo 2: subtract 0.5*y
+        x = nmul_add(y, VTYPE(0.5f), xa) * VTYPE(pi);
+    }
+    else {                                       // sin
+        // Reduce by extended precision modular arithmetic
+#if INSTRSET < 8
+        x = ((xa - y * DP1F) - y * DP2F) - y * DP3F; // accuracy 2 ULP without FMA
+#else
+        x = nmul_add(y, DP2F + DP3F, nmul_add(y, DP1F, xa)); // accuracy 1 ULP with FMA
+#endif
+    }
+
+    // Taylor expansion of sin and cos, valid for -pi/4 <= x <= pi/4
+    x2 = x * x;
+    s = mul_add(x2, P1sinf, P0sinf) * (x*x2) + x;
+    c = mul_add(x2, P1cosf, P0cosf) * (x2*x2) + nmul_add(0.5f, x2, 1.0f); 
+    // s = P0sinf * (x*x2) + x;  // 2 ULP error
+    // c = P0cosf * (x2*x2) + nmul_add(0.5f, x2, 1.0f);  // 2 ULP error
+
+    // swap sin and cos if odd quadrant
+    swap = BVTYPE((q & 1) != 0);
+
+    if constexpr ((SC & 5) != 0) {               // get sin
+        sin1 = select(swap, c, s);
+        ITYPE signsin = ((q << 30) ^ ITYPE(reinterpret_i(xx))); // sign
+        sin1 = sign_combine(sin1, reinterpret_f(signsin));
+    }
+    if constexpr ((SC & 6) != 0) {               // get cos
+        cos1 = select(swap, s, c);               // sign
+        ITYPE signcos = ((q + 1) & 2) << 30;
+        cos1 ^= reinterpret_f(signcos);
+    }
+    // select return
+    if      constexpr ((SC & 7) == 1) return sin1;
+    else if constexpr ((SC & 7) == 2) return cos1;
+    else if constexpr ((SC & 7) == 3) {          // both sin and cos. cos returned through pointer
+        *cosret = cos1;
+        return sin1;
+    }
+    else {                                       // (SC & 7) == 4. tan
+        if constexpr (SC == 12) {
+            // tanpi can give INF result, tan cannot. Get the right sign of INF result according to IEEE 754-2019
+            cos1 = select(cos1 == VTYPE(0.f), VTYPE(0.f), cos1); // remove sign of 0
+            // the sign of zero output is arbitrary. fixing it would be a waste of code
+        }
+        return sin1 / cos1;
+    }
+}
+
+// Instantiations of templates
+
+static inline Vec8h exp(Vec8h const x) {
+    Vec8f xf = to_float(x);
+    Vec8f yf = exp_h<Vec8f, 0, 0>(xf);
+    return to_float16(yf);
+}
+
+static inline Vec8h exp2(Vec8h const x) {
+    Vec8f xf = to_float(x);
+    Vec8f yf = exp_h<Vec8f, 0, 2>(xf);
+    return to_float16(yf);
+}
+
+static inline Vec8h exp10(Vec8h const x) {
+    Vec8f xf = to_float(x);
+    Vec8f yf = exp_h<Vec8f, 0, 10>(xf);
+    return to_float16(yf);
+}
+
+static inline Vec8h expm1(Vec8h const x) {
+    Vec8f xf = to_float(x);
+    Vec8f yf = exp_h<Vec8f, 1, 0>(xf);
+    return to_float16(yf);
+}
+
+static inline Vec8h sin(Vec8h const x) {
+    Vec8f xf = to_float(x);
+    Vec8f yf = sincos_h<Vec8f, 1>(0, xf);
+    return to_float16(yf);
+}
+static inline Vec8h cos(Vec8h const x) {
+    Vec8f xf = to_float(x);
+    Vec8f yf = sincos_h<Vec8f, 2>(0, xf);
+    return to_float16(yf);
+}
+static inline Vec8h sincos(Vec8h * cosret, Vec8h const x) {
+    Vec8f xf = to_float(x);
+    Vec8f cf;  // cos return
+    Vec8f yf = sincos_h<Vec8f, 3>(&cf, xf);
+    if (cosret) *cosret = to_float16(cf);
+    return to_float16(yf);
+}
+static inline Vec8h tan(Vec8h const x) {
+    Vec8f xf = to_float(x);
+    Vec8f yf = sincos_h<Vec8f, 4>(0, xf);
+    return to_float16(yf);
+}
+
+static inline Vec8h sinpi(Vec8h const x) {
+    Vec8f xf = to_float(x);
+    Vec8f yf = sincos_h<Vec8f, 9>(0, xf);
+    return to_float16(yf);
+}
+static inline Vec8h cospi(Vec8h const x) {
+    Vec8f xf = to_float(x);
+    Vec8f yf = sincos_h<Vec8f, 10>(0, xf);
+    return to_float16(yf);
+}
+static inline Vec8h sincospi(Vec8h * cosret, Vec8h const x) {
+    Vec8f xf = to_float(x);
+    Vec8f cf;  // cos return
+    Vec8f yf = sincos_h<Vec8f, 11>(&cf, xf);
+    if (cosret) *cosret = to_float16(cf);
+    return to_float16(yf);
+}
+static inline Vec8h tanpi(Vec8h const x) {
+    Vec8f xf = to_float(x);
+    Vec8f yf = sincos_h<Vec8f, 12>(0, xf);
+    return to_float16(yf);
+} 
+
+#if MAX_VECTOR_SIZE >= 512
+
+static inline Vec16h exp(Vec16h const x) {
+    Vec16f xf = to_float(x);
+    Vec16f yf = exp_h<Vec16f, 0, 0>(xf);
+    return to_float16(yf);
+}
+
+static inline Vec16h exp2(Vec16h const x) {
+    Vec16f xf = to_float(x);
+    Vec16f yf = exp_h<Vec16f, 0, 2>(xf);
+    return to_float16(yf);
+}
+
+static inline Vec16h exp10(Vec16h const x) {
+    Vec16f xf = to_float(x);
+    Vec16f yf = exp_h<Vec16f, 0, 10>(xf);
+    return to_float16(yf);
+}
+
+static inline Vec16h expm1(Vec16h const x) {
+    Vec16f xf = to_float(x);
+    Vec16f yf = exp_h<Vec16f, 1, 0>(xf);
+    return to_float16(yf);
+}
+
+static inline Vec16h sin(Vec16h const x) {
+    Vec16f xf = to_float(x);
+    Vec16f yf = sincos_h<Vec16f, 1>(0, xf);
+    return to_float16(yf);
+}
+static inline Vec16h cos(Vec16h const x) {
+    Vec16f xf = to_float(x);
+    Vec16f yf = sincos_h<Vec16f, 2>(0, xf);
+    return to_float16(yf);
+}
+static inline Vec16h sincos(Vec16h * cosret, Vec16h const x) {
+    Vec16f xf = to_float(x);
+    Vec16f cf;  // cos return
+    Vec16f yf = sincos_h<Vec16f, 3>(&cf, xf);
+    if (cosret) *cosret = to_float16(cf);
+    return to_float16(yf);
+}
+static inline Vec16h tan(Vec16h const x) {
+    Vec16f xf = to_float(x);
+    Vec16f yf = sincos_h<Vec16f, 4>(0, xf);
+    return to_float16(yf);
+} 
+
+static inline Vec16h sinpi(Vec16h const x) {
+    Vec16f xf = to_float(x);
+    Vec16f yf = sincos_h<Vec16f, 9>(0, xf);
+    return to_float16(yf);
+}
+static inline Vec16h cospi(Vec16h const x) {
+    Vec16f xf = to_float(x);
+    Vec16f yf = sincos_h<Vec16f, 10>(0, xf);
+    return to_float16(yf);
+}
+static inline Vec16h sincospi(Vec16h * cosret, Vec16h const x) {
+    Vec16f xf = to_float(x);
+    Vec16f cf;  // cos return
+    Vec16f yf = sincos_h<Vec16f, 11>(&cf, xf);
+    if (cosret) *cosret = to_float16(cf);
+    return to_float16(yf);
+}
+static inline Vec16h tanpi(Vec16h const x) {
+    Vec16f xf = to_float(x);
+    Vec16f yf = sincos_h<Vec16f, 12>(0, xf);
+    return to_float16(yf);
+} 
+
+#endif  // MAX_VECTOR_SIZE >= 256 
+
+#if MAX_VECTOR_SIZE >= 512
+
+static inline Vec32h exp(Vec32h const x) {
+    Vec16f xf_lo = to_float(x.get_low());
+    Vec16f xf_hi = to_float(x.get_high());
+    Vec16f yf_lo = exp_h<Vec16f, 0, 0>(xf_lo);
+    Vec16f yf_hi = exp_h<Vec16f, 0, 0>(xf_hi);
+    return Vec32h(to_float16(yf_lo), to_float16(yf_hi));
+}
+
+static inline Vec32h exp2(Vec32h const x) {
+    Vec16f xf_lo = to_float(x.get_low());
+    Vec16f xf_hi = to_float(x.get_high());
+    Vec16f yf_lo = exp_h<Vec16f, 0, 2>(xf_lo);
+    Vec16f yf_hi = exp_h<Vec16f, 0, 2>(xf_hi);
+    return Vec32h(to_float16(yf_lo), to_float16(yf_hi));
+}
+
+static inline Vec32h exp10(Vec32h const x) {
+    Vec16f xf_lo = to_float(x.get_low());
+    Vec16f xf_hi = to_float(x.get_high());
+    Vec16f yf_lo = exp_h<Vec16f, 0, 10>(xf_lo);
+    Vec16f yf_hi = exp_h<Vec16f, 0, 10>(xf_hi);
+    return Vec32h(to_float16(yf_lo), to_float16(yf_hi));
+}
+
+static inline Vec32h expm1(Vec32h const x) {
+    Vec16f xf_lo = to_float(x.get_low());
+    Vec16f xf_hi = to_float(x.get_high());
+    Vec16f yf_lo = exp_h<Vec16f, 1, 0>(xf_lo);
+    Vec16f yf_hi = exp_h<Vec16f, 1, 0>(xf_hi);
+    return Vec32h(to_float16(yf_lo), to_float16(yf_hi));
+}
+
+static inline Vec32h sin(Vec32h const x) {
+    Vec16f xf_lo = to_float(x.get_low());
+    Vec16f xf_hi = to_float(x.get_high());
+    Vec16f yf_lo = sincos_h<Vec16f, 1>(0, xf_lo);
+    Vec16f yf_hi = sincos_h<Vec16f, 1>(0, xf_hi);
+    return Vec32h(to_float16(yf_lo), to_float16(yf_hi));
+}
+static inline Vec32h cos(Vec32h const x) {
+    Vec16f xf_lo = to_float(x.get_low());
+    Vec16f xf_hi = to_float(x.get_high());
+    Vec16f yf_lo = sincos_h<Vec16f, 2>(0, xf_lo);
+    Vec16f yf_hi = sincos_h<Vec16f, 2>(0, xf_hi);
+    return Vec32h(to_float16(yf_lo), to_float16(yf_hi));
+}
+static inline Vec32h sincos(Vec32h * cosret, Vec32h const x) {
+    Vec16f xf_lo = to_float(x.get_low());
+    Vec16f xf_hi = to_float(x.get_high());
+    Vec16f cf_lo, cf_hi;
+    Vec16f yf_lo = sincos_h<Vec16f, 3>(&cf_lo, xf_lo);
+    Vec16f yf_hi = sincos_h<Vec16f, 3>(&cf_hi, xf_hi);
+    if (cosret) * cosret = Vec32h(to_float16(cf_lo), to_float16(cf_hi));
+    return Vec32h(to_float16(yf_lo), to_float16(yf_hi));
+}
+static inline Vec32h tan(Vec32h const x) {
+    Vec16f xf_lo = to_float(x.get_low());
+    Vec16f xf_hi = to_float(x.get_high());
+    Vec16f yf_lo = sincos_h<Vec16f, 4>(0, xf_lo);
+    Vec16f yf_hi = sincos_h<Vec16f, 4>(0, xf_hi);
+    return Vec32h(to_float16(yf_lo), to_float16(yf_hi));
+}
+
+static inline Vec32h sinpi(Vec32h const x) {
+    Vec16f xf_lo = to_float(x.get_low());
+    Vec16f xf_hi = to_float(x.get_high());
+    Vec16f yf_lo = sincos_h<Vec16f, 9>(0, xf_lo);
+    Vec16f yf_hi = sincos_h<Vec16f, 9>(0, xf_hi);
+    return Vec32h(to_float16(yf_lo), to_float16(yf_hi));
+}
+static inline Vec32h cospi(Vec32h const x) {
+    Vec16f xf_lo = to_float(x.get_low());
+    Vec16f xf_hi = to_float(x.get_high());
+    Vec16f yf_lo = sincos_h<Vec16f, 10>(0, xf_lo);
+    Vec16f yf_hi = sincos_h<Vec16f, 10>(0, xf_hi);
+    return Vec32h(to_float16(yf_lo), to_float16(yf_hi));
+}
+static inline Vec32h sincospi(Vec32h * cosret, Vec32h const x) {
+    Vec16f xf_lo = to_float(x.get_low());
+    Vec16f xf_hi = to_float(x.get_high());
+    Vec16f cf_lo, cf_hi;
+    Vec16f yf_lo = sincos_h<Vec16f, 11>(&cf_lo, xf_lo);
+    Vec16f yf_hi = sincos_h<Vec16f, 11>(&cf_hi, xf_hi);
+    if (cosret) * cosret = Vec32h(to_float16(cf_lo), to_float16(cf_hi));
+    return Vec32h(to_float16(yf_lo), to_float16(yf_hi));
+}
+static inline Vec32h tanpi(Vec32h const x) {
+    Vec16f xf_lo = to_float(x.get_low());
+    Vec16f xf_hi = to_float(x.get_high());
+    Vec16f yf_lo = sincos_h<Vec16f, 12>(0, xf_lo);
+    Vec16f yf_hi = sincos_h<Vec16f, 12>(0, xf_hi);
+    return Vec32h(to_float16(yf_lo), to_float16(yf_hi));
+} 
+
+#endif  // MAX_VECTOR_SIZE >= 512
+
+#ifdef VCL_NAMESPACE
+}
+#endif
+
+#endif // VECTORFP16_H
diff --git a/LGhost/VCL2/vectori256.h b/LGhost/VCL2/vectori256.h
index 035693f..3242778 100644
--- a/LGhost/VCL2/vectori256.h
+++ b/LGhost/VCL2/vectori256.h
@@ -1,8 +1,8 @@
 /****************************  vectori256.h   *******************************
 * Author:        Agner Fog
 * Date created:  2012-05-30
-* Last modified: 2020-03-26
-* Version:       2.01.02
+* Last modified: 2023-07-04
+* Version:       2.02.02
 * Project:       vector class library
 * Description:
 * Header file defining integer vector classes as interface to intrinsic
@@ -28,7 +28,7 @@
 * Each vector object is represented internally in the CPU as a 256-bit register.
 * This header file defines operators and functions for these vectors.
 *
-* (c) Copyright 2012-2020 Agner Fog.
+* (c) Copyright 2012-2023 Agner Fog.
 * Apache License version 2.0 or later.
 *****************************************************************************/
 
@@ -39,7 +39,7 @@
 #include "vectorclass.h"
 #endif
 
-#if VECTORCLASS_H < 20100
+#if VECTORCLASS_H < 20200
 #error Incompatible versions of vector class library mixed
 #endif
 
@@ -84,8 +84,7 @@ protected:
     __mmask32  mm; // Boolean mask register
 public:
     // Default constructor:
-    Vec32b() {
-    }
+    Vec32b() = default;
     // Constructor to convert from type __mmask32 used in intrinsics
     // Made explicit to prevent implicit conversion from int
     Vec32b(__mmask32 x) {
@@ -178,7 +177,7 @@ protected:
     __m256i ymm; // Integer vector
 public:
     // Default constructor:
-    Vec256b() {}
+    Vec256b() = default;
 
     // Constructor to broadcast the same value into all elements
     // Removed because of undesired implicit conversions:
@@ -298,10 +297,6 @@ static inline Vec256b andnot (Vec256b const a, Vec256b const b) {
     return _mm256_andnot_si256(b, a);
 }
 
-static inline __m256i zero_si256() {
-    return _mm256_setzero_si256();
-}
-
 
 /*****************************************************************************
 *
@@ -337,8 +332,7 @@ static inline bool horizontal_or (Vec256b const a) {
 class Vec32c : public Vec256b {
 public:
     // Default constructor:
-    Vec32c(){
-    }
+    Vec32c() = default;
     // Constructor to broadcast the same value into all elements:
     Vec32c(int i) {
         ymm = _mm256_set1_epi8((char)i);
@@ -491,8 +485,7 @@ public:
 class Vec32cb : public Vec32c {
 public:
     // Default constructor:
-    Vec32cb(){
-    }
+    Vec32cb() = default;
     // Constructor to build from all elements:
     /*
     Vec32cb(bool x0, bool x1, bool x2, bool x3, bool x4, bool x5, bool x6, bool x7,
@@ -1020,7 +1013,7 @@ static inline Vec32c abs_saturated(Vec32c const a) {
 // function rotate_left all elements
 // Use negative count to rotate right
 static inline Vec32c rotate_left(Vec32c const a, int b) {
-    uint8_t mask = 0xFFu << b;                             // mask off overflow bits
+    int8_t  mask  = int8_t(0xFFu << b);                    // mask off overflow bits
     __m256i m     = _mm256_set1_epi8(mask);
     __m128i bb    = _mm_cvtsi32_si128(b & 7);              // b modulo 8
     __m128i mbb   = _mm_cvtsi32_si128((- b) & 7);          // 8-b modulo 8
@@ -1041,8 +1034,7 @@ static inline Vec32c rotate_left(Vec32c const a, int b) {
 class Vec32uc : public Vec32c {
 public:
     // Default constructor:
-    Vec32uc(){
-    }
+    Vec32uc() = default;
     // Constructor to broadcast the same value into all elements:
     Vec32uc(uint32_t i) {
         ymm = _mm256_set1_epi8((char)i);
@@ -1304,8 +1296,7 @@ static inline Vec32uc min(Vec32uc const a, Vec32uc const b) {
 class Vec16s : public Vec256b {
 public:
     // Default constructor:
-    Vec16s() {
-    }
+    Vec16s() = default;
     // Constructor to broadcast the same value into all elements:
     Vec16s(int i) {
         ymm = _mm256_set1_epi16((int16_t)i);
@@ -1346,11 +1337,6 @@ public:
         ymm = _mm256_load_si256((__m256i const*)p);
         return *this;
     }
-    // Member function to load 16 unsigned 8-bit integers from array
-    Vec16s & load_16uc(void const * p) {
-        ymm = _mm256_cvtepu8_epi16(Vec16uc().load(p));
-        return *this;
-    }
     // Partial load. Load n elements and set the rest to 0
     Vec16s & load_partial(int n, void const * p) {
 #if INSTRSET >= 10  // AVX512VL
@@ -1455,8 +1441,7 @@ public:
 class Vec16sb : public Vec16s {
 public:
     // Default constructor:
-    Vec16sb() {
-    }
+    Vec16sb() = default;
     // Constructor to build from all elements:
     /*
     Vec16sb(bool x0, bool x1, bool x2, bool x3, bool x4, bool x5, bool x6, bool x7,
@@ -1909,8 +1894,7 @@ static inline Vec16s rotate_left(Vec16s const a, int b) {
 class Vec16us : public Vec16s {
 public:
     // Default constructor:
-    Vec16us(){
-    }
+    Vec16us() = default;
     // Constructor to broadcast the same value into all elements:
     Vec16us(uint32_t i) {
         ymm = _mm256_set1_epi16((int16_t)i);
@@ -2137,7 +2121,7 @@ static inline uint32_t horizontal_add_x (Vec16us const a) {
     __m128i sum2  = _mm_add_epi32(_mm256_extracti128_si256(sum1,1),_mm256_castsi256_si128(sum1));
     __m128i sum3  = _mm_add_epi32(sum2,_mm_unpackhi_epi64(sum2,sum2));
     __m128i sum4  = _mm_add_epi32(sum3,_mm_shuffle_epi32(sum3,1));
-    return (int16_t)_mm_cvtsi128_si32(sum4);               // truncate to 16 bits
+    return (uint32_t)(uint16_t)_mm_cvtsi128_si32(sum4);    // truncate to 16 bits
 }
 
 // function add_saturated: add element by element, unsigned with saturation
@@ -2170,8 +2154,7 @@ static inline Vec16us min(Vec16us const a, Vec16us const b) {
 class Vec8i : public Vec256b {
 public:
     // Default constructor:
-    Vec8i() {
-    }
+    Vec8i() = default;
     // Constructor to broadcast the same value into all elements:
     Vec8i(int i) {
         ymm = _mm256_set1_epi32(i);
@@ -2207,16 +2190,6 @@ public:
         ymm = _mm256_load_si256((__m256i const*)p);
         return *this;
     }
-    // Member function to load 8 unsigned 8-bit integers from array
-    Vec8i & load_8uc(void const * p) {
-        ymm = _mm256_cvtepu8_epi32(Vec16uc().loadl(p));
-        return *this;
-    }
-    // Member function to load 8 unsigned 16-bit integers from array
-    Vec8i & load_8us(void const * p) {
-        ymm = _mm256_cvtepu16_epi32(Vec8us().load(p));
-        return *this;
-    }
     // Partial load. Load n elements and set the rest to 0
     Vec8i & load_partial(int n, void const * p) {
 #if INSTRSET >= 10  // AVX512VL
@@ -2321,8 +2294,7 @@ public:
 class Vec8ib : public Vec8i {
 public:
     // Default constructor:
-    Vec8ib() {
-    }
+    Vec8ib() = default;
     // Constructor to build from all elements:
     Vec8ib(bool x0, bool x1, bool x2, bool x3, bool x4, bool x5, bool x6, bool x7) :
         Vec8i(-int32_t(x0), -int32_t(x1), -int32_t(x2), -int32_t(x3), -int32_t(x4), -int32_t(x5), -int32_t(x6), -int32_t(x7))
@@ -2777,8 +2749,7 @@ static inline Vec8i rotate_left(Vec8i const a, int b) {
 class Vec8ui : public Vec8i {
 public:
     // Default constructor:
-    Vec8ui() {
-    }
+    Vec8ui() = default;
     // Constructor to broadcast the same value into all elements:
     Vec8ui(uint32_t i) {
         ymm = _mm256_set1_epi32((int32_t)i);
@@ -3039,8 +3010,7 @@ static inline Vec8ui min(Vec8ui const a, Vec8ui const b) {
 class Vec4q : public Vec256b {
 public:
     // Default constructor:
-    Vec4q() {
-    }
+    Vec4q() = default;
     // Constructor to broadcast the same value into all elements:
     Vec4q(int64_t i) {
         ymm = _mm256_set1_epi64x(i);
@@ -3186,8 +3156,7 @@ public:
 class Vec4qb : public Vec4q {
 public:
     // Default constructor:
-    Vec4qb() {
-    }
+    Vec4qb() = default;
     // Constructor to build from all elements:
     Vec4qb(bool x0, bool x1, bool x2, bool x3) :
         Vec4q(-int64_t(x0), -int64_t(x1), -int64_t(x2), -int64_t(x3)) {
@@ -3647,8 +3616,7 @@ static inline Vec4q rotate_left(Vec4q const a, int b) {
 class Vec4uq : public Vec4q {
 public:
     // Default constructor:
-    Vec4uq() {
-    }
+    Vec4uq() = default;
     // Constructor to broadcast the same value into all elements:
     Vec4uq(uint64_t i) {
         ymm = Vec4q((int64_t)i);
@@ -3965,7 +3933,7 @@ static inline Vec4q permute4(Vec4q const a) {
 #if INSTRSET >= 10  // use compact mask
         y = _mm256_maskz_mov_epi64(zero_mask<4>(indexs), y);
 #else  // use broad mask
-        const EList <int64_t, 4> bm = zero_mask_broad<Vec4q>(indexs);
+        constexpr EList <int64_t, 4> bm = zero_mask_broad<Vec4q>(indexs);
         y = _mm256_and_si256(Vec4q().load(bm.a), y);
 #endif
     }
@@ -4044,7 +4012,7 @@ static inline Vec8i permute8(Vec8i const a) {
             else
 #endif
             if constexpr ((flags & perm_cross_lane) == 0) {  // no lane crossing. Use pshufb
-                const EList <int8_t, 32> bm = pshufb_mask<Vec8i>(indexs);
+                constexpr EList <int8_t, 32> bm = pshufb_mask<Vec8i>(indexs);
                 return _mm256_shuffle_epi8(a, Vec8i().load(bm.a));
             }
             // full permute needed
@@ -4062,7 +4030,7 @@ static inline Vec8i permute8(Vec8i const a) {
 #if INSTRSET >= 10  // use compact mask
         y = _mm256_maskz_mov_epi32(zero_mask<8>(indexs), y);
 #else  // use broad mask
-        const EList <int32_t, 8> bm = zero_mask_broad<Vec8i>(indexs);
+        constexpr EList <int32_t, 8> bm = zero_mask_broad<Vec8i>(indexs);
         y = _mm256_and_si256(Vec8i().load(bm.a), y);
 #endif
     }
@@ -4108,6 +4076,11 @@ static inline Vec16s permute16(Vec16s const a) {
             else if constexpr ((flags & perm_rotate) != 0) {    // fits palignr. rotate within lanes
                 y = _mm256_alignr_epi8(a, a, (flags >> perm_rot_count) & 0xF);
             }
+#if INSTRSET >= 10  // use rotate
+            else if constexpr ((flags & perm_swap) != 0) {      // swap adjacent elements. rotate 32 bits
+                y = _mm256_rol_epi32(a, 16);
+            }
+#endif
             else {
                 // flags for 16 bit permute instructions
                 constexpr uint64_t flags16 = perm16_flags<Vec16s>(indexs);
@@ -4127,7 +4100,7 @@ static inline Vec16s permute16(Vec16s const a) {
                     }
                 }
                 else {  // use pshufb
-                    const EList <int8_t, 32> bm = pshufb_mask<Vec16s>(indexs);
+                    constexpr EList <int8_t, 32> bm = pshufb_mask<Vec16s>(indexs);
                     return _mm256_shuffle_epi8(a, Vec16s().load(bm.a));
                 }
             }
@@ -4148,7 +4121,7 @@ static inline Vec16s permute16(Vec16s const a) {
             }
 #endif  // AVX512VBMI2
             else if constexpr ((flags & perm_cross_lane) == 0) {     // no lane crossing. Use pshufb
-                const EList <int8_t, 32> bm = pshufb_mask<Vec16s>(indexs);
+                constexpr EList <int8_t, 32> bm = pshufb_mask<Vec16s>(indexs);
                 return _mm256_shuffle_epi8(a, Vec16s().load(bm.a));
             }
             else if constexpr ((flags & perm_rotate_big) != 0) {// fits full rotate
@@ -4166,12 +4139,12 @@ static inline Vec16s permute16(Vec16s const a) {
             }
             else {  // full permute needed
 #if INSTRSET >= 10  // AVX512VL
-                const EList <int16_t, 16> bm = perm_mask_broad<Vec16s>(indexs);
+                constexpr EList <int16_t, 16> bm = perm_mask_broad<Vec16s>(indexs);
                 y = _mm256_permutexvar_epi16(Vec16s().load(bm.a), y);
 #else           // no full permute instruction available
                 __m256i swap = _mm256_permute4x64_epi64(y,0x4E);// swap high and low 128-bit lane
-                const EList <int8_t, 32> bm1 = pshufb_mask<Vec16s, 1>(indexs);
-                const EList <int8_t, 32> bm2 = pshufb_mask<Vec16s, 0>(indexs);
+                constexpr EList <int8_t, 32> bm1 = pshufb_mask<Vec16s, 1>(indexs);
+                constexpr EList <int8_t, 32> bm2 = pshufb_mask<Vec16s, 0>(indexs);
                 __m256i r1 = _mm256_shuffle_epi8(swap, Vec16s().load(bm1.a));
                 __m256i r2 = _mm256_shuffle_epi8(y,    Vec16s().load(bm2.a));
                 return       _mm256_or_si256(r1, r2);
@@ -4183,7 +4156,7 @@ static inline Vec16s permute16(Vec16s const a) {
 #if INSTRSET >= 10  // use compact mask
         y = _mm256_maskz_mov_epi16(zero_mask<16>(indexs), y);
 #else               // use broad mask
-        const EList <int16_t, 16> bm = zero_mask_broad<Vec16s>(indexs);
+        constexpr EList <int16_t, 16> bm = zero_mask_broad<Vec16s>(indexs);
         y = _mm256_and_si256(Vec16s().load(bm.a), y);
 #endif
     }
@@ -4233,7 +4206,7 @@ static inline Vec32c permute32(Vec32c const a) {
                 y = _mm256_alignr_epi8(a, a, (flags >> perm_rot_count) & 0xF);
             }
             else { // use pshufb
-                const EList <int8_t, 32> bm = pshufb_mask<Vec32c>(indexs);
+                constexpr EList <int8_t, 32> bm = pshufb_mask<Vec32c>(indexs);
                 return _mm256_shuffle_epi8(a, Vec32c().load(bm.a));
             }
         }
@@ -4253,7 +4226,7 @@ static inline Vec32c permute32(Vec32c const a) {
             }
 #endif  // AVX512VBMI2
             else if constexpr ((flags & perm_cross_lane) == 0) {     // no lane crossing. Use pshufb
-                const EList <int8_t, 32> bm = pshufb_mask<Vec32c>(indexs);
+                constexpr EList <int8_t, 32> bm = pshufb_mask<Vec32c>(indexs);
                 return _mm256_shuffle_epi8(a, Vec32c().load(bm.a));
             }
             else if constexpr ((flags & perm_rotate_big) != 0) {// fits full rotate
@@ -4271,13 +4244,13 @@ static inline Vec32c permute32(Vec32c const a) {
             }
             else {  // full permute needed
 #if INSTRSET >= 10 && defined ( __AVX512VBMI__ ) // AVX512VBMI
-                const EList <int8_t, 32> bm = perm_mask_broad<Vec32c>(indexs);
+                constexpr EList <int8_t, 32> bm = perm_mask_broad<Vec32c>(indexs);
                 y = _mm256_permutexvar_epi8(Vec32c().load(bm.a), y);
 #else
                 // no full permute instruction available
                 __m256i swap = _mm256_permute4x64_epi64(y, 0x4E);  // swap high and low 128-bit lane
-                const EList <int8_t, 32> bm1 = pshufb_mask<Vec32c, 1>(indexs);
-                const EList <int8_t, 32> bm2 = pshufb_mask<Vec32c, 0>(indexs);
+                constexpr EList <int8_t, 32> bm1 = pshufb_mask<Vec32c, 1>(indexs);
+                constexpr EList <int8_t, 32> bm2 = pshufb_mask<Vec32c, 0>(indexs);
                 __m256i r1 = _mm256_shuffle_epi8(swap, Vec32c().load(bm1.a));
                 __m256i r2 = _mm256_shuffle_epi8(y,    Vec32c().load(bm2.a));
                 return       _mm256_or_si256(r1, r2);
@@ -4289,7 +4262,7 @@ static inline Vec32c permute32(Vec32c const a) {
 #if INSTRSET >= 10  // use compact mask
         y = _mm256_maskz_mov_epi8(zero_mask<32>(indexs), y);
 #else  // use broad mask
-        const EList <int8_t, 32> bm = zero_mask_broad<Vec32c>(indexs);
+        constexpr EList <int8_t, 32> bm = zero_mask_broad<Vec32c>(indexs);
         y = _mm256_and_si256(Vec32c().load(bm.a), y);
 #endif
     }
@@ -4386,7 +4359,7 @@ static inline Vec4q blend4(Vec4q const a, Vec4q const b) {
 #if INSTRSET >= 10  // use compact mask
         y = _mm256_maskz_mov_epi64(zero_mask<4>(indexs), y);
 #else  // use broad mask
-        const EList <int64_t, 4> bm = zero_mask_broad<Vec4q>(indexs);
+        constexpr EList <int64_t, 4> bm = zero_mask_broad<Vec4q>(indexs);
         y = _mm256_and_si256(Vec4q().load(bm.a), y);
 #endif
     }
@@ -4473,7 +4446,7 @@ static inline Vec8i blend8(Vec8i const a, Vec8i const b) {
 #if INSTRSET >= 10  // use compact mask
         y = _mm256_maskz_mov_epi32(zero_mask<8>(indexs), y);
 #else  // use broad mask
-        const EList <int32_t, 8> bm = zero_mask_broad<Vec8i>(indexs);
+        constexpr EList <int32_t, 8> bm = zero_mask_broad<Vec8i>(indexs);
         y = _mm256_and_si256(Vec8i().load(bm.a), y);
 #endif
     }
@@ -4535,7 +4508,7 @@ template <int i0,  int i1,  int i2,  int i3,  int i4,  int i5,  int i6,  int i7,
     else { // No special cases
 #if INSTRSET >= 10  // AVX512VL. use vpermi2w
         if constexpr ((flags & (blend_perma | blend_permb)) != 0) {
-            const EList <int16_t, 16> bm = perm_mask_broad<Vec16s>(indexs);
+            constexpr EList <int16_t, 16> bm = perm_mask_broad<Vec16s>(indexs);
             return _mm256_maskz_permutex2var_epi16(zero_mask<16>(indexs), a, Vec16s().load(bm.a), b);
         }
 #endif
@@ -4560,7 +4533,7 @@ template <int i0,  int i1,  int i2,  int i3,  int i4,  int i5,  int i6,  int i7,
             y = _mm256_blend_epi16(ya, yb, (uint8_t)mb);
         }
         else {
-            const EList <int16_t, 16> bm = make_broad_mask<Vec16s>(mb);
+            constexpr EList <int16_t, 16> bm = make_broad_mask<Vec16s>(mb);
             y = _mm256_blendv_epi8 (ya, yb, Vec16s().load(bm.a));
         }
 #endif
@@ -4569,7 +4542,7 @@ template <int i0,  int i1,  int i2,  int i3,  int i4,  int i5,  int i6,  int i7,
 #if INSTRSET >= 10  // use compact mask
         y = _mm256_maskz_mov_epi16(zero_mask<16>(indexs), y);
 #else  // use broad mask
-        const EList <int16_t, 16> bm = zero_mask_broad<Vec16s>(indexs);
+        constexpr EList <int16_t, 16> bm = zero_mask_broad<Vec16s>(indexs);
         y = _mm256_and_si256(Vec16s().load(bm.a), y);
 #endif
     }
@@ -4621,7 +4594,7 @@ static inline Vec32c blend32(Vec32c const a, Vec32c const b) {
     else { // No special cases
 #if INSTRSET >= 10 && defined (__AVX512VBMI__) // AVX512VL + AVX512VBMI. use vpermi2b
         if constexpr ((flags & (blend_perma | blend_permb)) != 0) {
-            const EList <int8_t, 32> bm = perm_mask_broad<Vec32c>(indexs);
+            constexpr EList <int8_t, 32> bm = perm_mask_broad<Vec32c>(indexs);
             return _mm256_maskz_permutex2var_epi8(zero_mask<32>(indexs), a, Vec32c().load(bm.a), b);
         }
 #endif
@@ -4646,7 +4619,7 @@ static inline Vec32c blend32(Vec32c const a, Vec32c const b) {
 #if INSTRSET >= 10 // AVX512VL
         y = _mm256_mask_mov_epi8 (ya, mb, yb);
 #else  // AVX2
-        const EList <int8_t, 32> bm = make_broad_mask<Vec32c>(mb);
+        constexpr EList <int8_t, 32> bm = make_broad_mask<Vec32c>(mb);
         y = _mm256_blendv_epi8 (ya, yb, Vec32c().load(bm.a));
 #endif
     }
@@ -4654,7 +4627,7 @@ static inline Vec32c blend32(Vec32c const a, Vec32c const b) {
 #if INSTRSET >= 10  // use compact mask
         y = _mm256_maskz_mov_epi8(zero_mask<32>(indexs), y);
 #else  // use broad mask
-        const EList <int8_t, 32> bm = zero_mask_broad<Vec32c>(indexs);
+        constexpr EList <int8_t, 32> bm = zero_mask_broad<Vec32c>(indexs);
         y = _mm256_and_si256(Vec32c().load(bm.a), y);
 #endif
     }
@@ -4705,7 +4678,10 @@ static inline Vec32c lookup(Vec32uc const index, void const * table) {
     if constexpr (n <= 32) return lookup32(index, Vec32c().load(table));
     // n > 32. Limit index
     Vec32uc index1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        index1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         index1 = Vec32uc(index) & uint8_t(n-1);
     }
@@ -4747,7 +4723,10 @@ static inline Vec16s lookup(Vec16s const index, void const * table) {
     if constexpr (n <= 16) return lookup16(index, Vec16s().load(table));
     // n > 16. Limit index
     Vec16us index1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        index1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         index1 = Vec16us(index) & (n-1);
     }
@@ -4781,7 +4760,10 @@ static inline Vec8i lookup(Vec8i const index, void const * table) {
     }
     // n > 16. Limit index
     Vec8ui index1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        index1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         index1 = Vec8ui(index) & (n-1);
     }
@@ -4801,7 +4783,10 @@ static inline Vec4q lookup(Vec4q const index, int64_t const * table) {
     if constexpr (n <= 0) return 0;
     // n > 0. Limit index
     Vec4uq index1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        index1 = Vec4uq(index);
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         index1 = Vec4uq(index) & (n-1);
     }
@@ -5074,7 +5059,7 @@ static inline void scatter(Vec4i const index, uint32_t limit, Vec4q const data,
 
 /*****************************************************************************
 *
-*          Functions for conversion between integer sizes
+*          Functions for conversion between integer sizes and vector types
 *
 *****************************************************************************/
 
@@ -5197,13 +5182,6 @@ static inline Vec32uc compress_saturated (Vec16us const low, Vec16us const high)
     return            _mm256_permute4x64_epi64(pk, 0xD8);  // put in right place
 }
 
-// Function compress : packs two vectors of 16-bit integers into one vector of 8-bit integers
-// Signed to unsigned, with saturation
-static inline Vec32uc compress_saturated_s2u (Vec16s const low, Vec16s const high) {
-    __m256i pk    = _mm256_packus_epi16(low,high);         // this instruction saturates from signed 16 bit to unsigned 8 bit
-    return          _mm256_permute4x64_epi64(pk, 0xD8);    // put in right place
-}
-
 // Compress 32-bit integers to 16-bit integers, signed and unsigned, with and without saturation
 
 // Function compress : packs two vectors of 32-bit integers into one vector of 16-bit integers
@@ -5239,13 +5217,6 @@ static inline Vec16us compress_saturated (Vec8ui const low, Vec8ui const high) {
     return            _mm256_permute4x64_epi64(pk, 0xD8);  // put in right place
 }
 
-// Function compress : packs two vectors of 32-bit integers into one vector of 16-bit integers
-// Signed to unsigned, with saturation
-static inline Vec16us compress_saturated_s2u (Vec8i const low, Vec8i const high) {
-    __m256i pk    =  _mm256_packus_epi32(low,high);        // this instruction saturates from signed 32 bit to unsigned 16 bit
-    return           _mm256_permute4x64_epi64(pk, 0xD8);   // put in right place
-}
-
 // Compress 64-bit integers to 32-bit integers, signed and unsigned, with and without saturation
 
 // Function compress : packs two vectors of 64-bit integers into one vector of 32-bit integers
@@ -5291,6 +5262,112 @@ static inline Vec8ui compress_saturated (Vec4uq const low, Vec4uq const high) {
     return  Vec8ui (compress(Vec4q(lowsatur), Vec4q(hisatur)));
 }
 
+// extend vectors to double size by adding zeroes
+
+#ifdef ZEXT_MISSING
+// GCC v. 9 is missing the _mm256_zextsi128_si256 intrinsic
+
+static inline Vec32c extend_z(Vec16c a) {
+    return Vec32c(a, Vec16c(0));
+}
+static inline Vec32uc extend_z(Vec16uc a) {
+    return Vec32uc(a, Vec16uc(0));
+}
+static inline Vec16s extend_z(Vec8s a) {
+    return Vec16s(a, Vec8s(0));
+}
+static inline Vec16us extend_z(Vec8us a) {
+    return Vec16us(a, Vec8us(0));
+}
+static inline Vec8i extend_z(Vec4i a) {
+    return Vec8i(a, Vec4i(0));
+}
+static inline Vec8ui extend_z(Vec4ui a) {
+    return Vec8ui(a, Vec4ui(0));
+}
+static inline Vec4q extend_z(Vec2q a) {
+    return Vec4q(a, Vec2q(0));
+}
+static inline Vec4uq extend_z(Vec2uq a) {
+    return Vec4uq(a, Vec2uq(0));
+}
+
+#else
+
+static inline Vec32c extend_z(Vec16c a) {
+    return _mm256_zextsi128_si256(a);
+}
+static inline Vec32uc extend_z(Vec16uc a) {
+    return _mm256_zextsi128_si256(a);
+}
+static inline Vec16s extend_z(Vec8s a) {
+    return _mm256_zextsi128_si256(a);
+}
+static inline Vec16us extend_z(Vec8us a) {
+    return _mm256_zextsi128_si256(a);
+}
+static inline Vec8i extend_z(Vec4i a) {
+    return _mm256_zextsi128_si256(a);
+}
+static inline Vec8ui extend_z(Vec4ui a) {
+    return _mm256_zextsi128_si256(a);
+}
+static inline Vec4q extend_z(Vec2q a) {
+    return _mm256_zextsi128_si256(a);
+}
+static inline Vec4uq extend_z(Vec2uq a) {
+    return _mm256_zextsi128_si256(a);
+}
+#endif // ZEXT_MISSING
+
+#if INSTRSET < 10  // broad boolean vectors
+#ifdef ZEXT_MISSING
+// GCC v. 9 is missing the _mm256_zextsi128_si256 intrinsic
+static inline Vec32cb extend_z(Vec16cb a) {
+    return Vec32cb(a, Vec16cb(false));
+}
+static inline Vec16sb extend_z(Vec8sb a) {
+    return Vec16sb(a, Vec8sb(false));
+}
+static inline Vec8ib extend_z(Vec4ib a) {
+    return Vec8ib(a, Vec4ib(false));
+}
+static inline Vec4qb extend_z(Vec2qb a) {
+    return Vec4qb(a, Vec2qb(false));
+}
+
+#else
+static inline Vec32cb extend_z(Vec16cb a) {
+    return _mm256_zextsi128_si256(a);
+}
+static inline Vec16sb extend_z(Vec8sb a) {
+    return _mm256_zextsi128_si256(a);
+}
+static inline Vec8ib extend_z(Vec4ib a) {
+    return _mm256_zextsi128_si256(a);
+}
+static inline Vec4qb extend_z(Vec2qb a) {
+    return _mm256_zextsi128_si256(a);
+}
+#endif  // ZEXT_MISSING
+
+#else    // compact boolean vectors
+
+static inline Vec32b extend_z(Vec16b a) {
+    return __mmask32(a);
+}
+static inline Vec16b extend_z(Vec8b a) {
+    return __mmask16(a);
+}
+static inline Vec8b extend_z(Vec4b a) {
+    return __mmask8(uint8_t(a) & 0x0F);
+}
+static inline Vec4b extend_z(Vec2b a) {
+    return __mmask8(uint8_t(a) & 0x03);
+} 
+
+#endif
+
 
 /*****************************************************************************
 *
diff --git a/LGhost/VCL2/vectori256e.h b/LGhost/VCL2/vectori256e.h
index df47594..b3cdd8d 100644
--- a/LGhost/VCL2/vectori256e.h
+++ b/LGhost/VCL2/vectori256e.h
@@ -1,8 +1,8 @@
 /****************************  vectori256e.h   *******************************
 * Author:        Agner Fog
 * Date created:  2012-05-30
-* Last modified: 2020-03-26
-* Version:       2.01.02
+* Last modified: 2023-06-03
+* Version:       2.02.01
 * Project:       vector class library
 * Description:
 * Header file defining 256-bit integer point vector classes as interface
@@ -28,7 +28,7 @@
 * Each vector object is represented internally in the CPU as two 128-bit registers.
 * This header file defines operators and functions for these vectors.
 *
-* (c) Copyright 2012-2020 Agner Fog.
+* (c) Copyright 2012-2023 Agner Fog.
 * Apache License version 2.0 or later.
 *****************************************************************************/
 
@@ -39,7 +39,7 @@
 #include "vectorclass.h"
 #endif
 
-#if VECTORCLASS_H < 20100
+#if VECTORCLASS_H < 20200
 #error Incompatible versions of vector class library mixed
 #endif
 
@@ -66,8 +66,7 @@ protected:
     __m128i y1;                        // high half
 public:
     // Default constructor:
-    Vec256b() {
-    }
+    Vec256b() = default;
     Vec256b(__m128i x0, __m128i x1) {  // constructor to build from two __m128i
         y0 = x0;  y1 = x1;
     }
@@ -211,8 +210,7 @@ static inline bool horizontal_or (Vec256b const a) {
 class Vec32c : public Vec256b {
 public:
     // Default constructor:
-    Vec32c(){
-    }
+    Vec32c() = default;
     // Constructor to broadcast the same value into all elements:
     Vec32c(int i) {
         y1 = y0 = _mm_set1_epi8((char)i);
@@ -343,8 +341,7 @@ public:
 class Vec32cb : public Vec32c {
 public:
     // Default constructor:
-    Vec32cb() {}
-
+    Vec32cb() = default;
     // Constructor to convert from type Vec256b
     Vec32cb(Vec256b const x) {
         y0 = x.get_low();
@@ -730,8 +727,7 @@ static inline Vec32c rotate_left(Vec32c const a, int b) {
 class Vec32uc : public Vec32c {
 public:
     // Default constructor:
-    Vec32uc(){
-    }
+    Vec32uc() = default;
     // Constructor to broadcast the same value into all elements:
     Vec32uc(uint32_t i) {
         y1 = y0 = _mm_set1_epi8((char)i);
@@ -962,8 +958,7 @@ static inline Vec32uc min(Vec32uc const a, Vec32uc const b) {
 class Vec16s : public Vec256b {
 public:
     // Default constructor:
-    Vec16s() {
-    }
+    Vec16s() = default;
     // Constructor to broadcast the same value into all elements:
     Vec16s(int i) {
         y1 = y0 = _mm_set1_epi16((int16_t)i);
@@ -1085,8 +1080,7 @@ public:
 class Vec16sb : public Vec16s {
 public:
     // Default constructor:
-    Vec16sb() {
-    }
+    Vec16sb() = default;
     // Constructor to build from all elements:
     Vec16sb(bool x0, bool x1, bool x2, bool x3, bool x4, bool x5, bool x6, bool x7,
         bool x8, bool x9, bool x10, bool x11, bool x12, bool x13, bool x14, bool x15) :
@@ -1472,8 +1466,7 @@ static inline Vec16s rotate_left(Vec16s const a, int b) {
 class Vec16us : public Vec16s {
 public:
     // Default constructor:
-    Vec16us(){
-    }
+    Vec16us() = default;
     // Constructor to broadcast the same value into all elements:
     Vec16us(uint32_t i) {
         y1 = y0 = _mm_set1_epi16((int16_t)i);
@@ -1702,8 +1695,7 @@ static inline Vec16us min(Vec16us const a, Vec16us const b) {
 class Vec8i : public Vec256b {
 public:
     // Default constructor:
-    Vec8i() {
-    }
+    Vec8i() = default;
     // Constructor to broadcast the same value into all elements:
     Vec8i(int i) {
         y1 = y0 = _mm_set1_epi32(i);
@@ -1824,8 +1816,7 @@ public:
 class Vec8ib : public Vec8i {
 public:
     // Default constructor:
-    Vec8ib() {
-    }
+    Vec8ib() = default;
     // Constructor to build from all elements:
     Vec8ib(bool x0, bool x1, bool x2, bool x3, bool x4, bool x5, bool x6, bool x7) :
         Vec8i(-int32_t(x0), -int32_t(x1), -int32_t(x2), -int32_t(x3), -int32_t(x4), -int32_t(x5), -int32_t(x6), -int32_t(x7))
@@ -2212,8 +2203,7 @@ static inline Vec8i rotate_left(Vec8i const a, int b) {
 class Vec8ui : public Vec8i {
 public:
     // Default constructor:
-    Vec8ui() {
-    }
+    Vec8ui() = default;
     // Constructor to broadcast the same value into all elements:
     Vec8ui(uint32_t i) {
         y1 = y0 = _mm_set1_epi32(int32_t(i));
@@ -2446,8 +2436,7 @@ static inline Vec8ui min(Vec8ui const a, Vec8ui const b) {
 class Vec4q : public Vec256b {
 public:
     // Default constructor:
-    Vec4q() {
-    }
+    Vec4q() = default;
     // Constructor to broadcast the same value into all elements:
     Vec4q(int64_t i) {
         y0 = y1 = Vec2q(i);
@@ -2568,8 +2557,7 @@ public:
 class Vec4qb : public Vec4q {
 public:
     // Default constructor:
-    Vec4qb() {
-    }
+    Vec4qb() = default;
     // Constructor to build from all elements:
     Vec4qb(bool x0, bool x1, bool x2, bool x3) :
         Vec4q(-int64_t(x0), -int64_t(x1), -int64_t(x2), -int64_t(x3)) {
@@ -2931,8 +2919,7 @@ static inline Vec4q rotate_left(Vec4q const a, int b) {
 class Vec4uq : public Vec4q {
 public:
     // Default constructor:
-    Vec4uq() {
-    }
+    Vec4uq() = default;
     // Constructor to broadcast the same value into all elements:
     Vec4uq(uint64_t i) {
         y1 = y0 = Vec2q((int64_t)i);
@@ -3156,7 +3143,7 @@ static inline Vec8i permute8(Vec8i const a) {
 }
 
 template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7 >
-static inline Vec8ui permute4(Vec8ui const a) {
+static inline Vec8ui permute8(Vec8ui const a) {
     return Vec8ui (permute8<i0,i1,i2,i3,i4,i5,i6,i7> (Vec8i(a)));
 }
 
@@ -3299,7 +3286,10 @@ static inline Vec32c lookup(Vec32uc const index, void const * table) {
     if constexpr (n <= 32) return lookup32(index, Vec32c().load(table));
     // n > 32. Limit index
     Vec32uc index1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        index1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         index1 = Vec32uc(index) & uint8_t(n-1);
     }
@@ -3338,7 +3328,10 @@ static inline Vec16s lookup(Vec16s const index, void const * table) {
     if constexpr (n <= 16) return lookup16(index, Vec16s().load(table));
     // n > 16. Limit index
     Vec16us i1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        i1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         i1 = Vec16us(index) & (n-1);
     }
@@ -3371,7 +3364,10 @@ static inline Vec8i lookup(Vec8i const index, void const * table) {
     }
     // n > 8. Limit index
     Vec8ui i1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        i1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         i1 = Vec8ui(index) & (n-1);
     }
@@ -3392,7 +3388,10 @@ static inline Vec4q lookup(Vec4q const index, void const * table) {
     if constexpr (n <= 0) return 0;
     // n > 0. Limit index
     Vec4uq index1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        index1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         index1 = Vec4uq(index) & (n-1);
     }
@@ -3574,7 +3573,7 @@ static inline void scatter(Vec4i const index, uint32_t limit, Vec4q const data,
 
 /*****************************************************************************
 *
-*          Functions for conversion between integer sizes
+*          Functions for conversion between integer sizes and vector types
 *
 *****************************************************************************/
 
@@ -3722,6 +3721,46 @@ static inline Vec8ui compress_saturated (Vec4uq const low, Vec4uq const high) {
     return Vec8ui(compress_saturated(low.get_low(),low.get_high()), compress_saturated(high.get_low(),high.get_high()));
 }
 
+// extend vectors to double size by adding zeroes
+static inline Vec32c extend_z(Vec16c a) {
+    return Vec32c(a, _mm_setzero_si128());
+}
+static inline Vec32uc extend_z(Vec16uc a) {
+    return Vec32uc(a, _mm_setzero_si128());
+}
+static inline Vec16s extend_z(Vec8s a) {
+    return Vec16s(a, _mm_setzero_si128());
+}
+static inline Vec16us extend_z(Vec8us a) {
+    return Vec16us(a, _mm_setzero_si128());
+}
+static inline Vec8i extend_z(Vec4i a) {
+    return Vec8i(a, _mm_setzero_si128());
+}
+static inline Vec8ui extend_z(Vec4ui a) {
+    return Vec8ui(a, _mm_setzero_si128());
+}
+static inline Vec4q extend_z(Vec2q a) {
+    return Vec4q(a, _mm_setzero_si128());
+}
+static inline Vec4uq extend_z(Vec2uq a) {
+    return Vec4uq(a, _mm_setzero_si128());
+} 
+
+static inline Vec32cb extend_z(Vec16cb a) {
+    return Vec32cb(a, _mm_setzero_si128());
+}
+static inline Vec16sb extend_z(Vec8sb a) {
+    return Vec16sb(a, _mm_setzero_si128());
+}
+static inline Vec8ib extend_z(Vec4ib a) {
+    return Vec8ib(a, _mm_setzero_si128());
+}
+static inline Vec4qb extend_z(Vec2qb a) {
+    return Vec4qb(a, _mm_setzero_si128());
+}
+
+
 
 /*****************************************************************************
 *
diff --git a/LGhost/VCL2/vectori512.h b/LGhost/VCL2/vectori512.h
index eca5d0b..c02431c 100644
--- a/LGhost/VCL2/vectori512.h
+++ b/LGhost/VCL2/vectori512.h
@@ -1,8 +1,8 @@
 /****************************  vectori512.h   *******************************
 * Author:        Agner Fog
 * Date created:  2014-07-23
-* Last modified: 2020-03-26
-* Version:       2.01.02
+* Last modified: 2023-06-03
+* Version:       2.02.01
 * Project:       vector class library
 * Description:
 * Header file defining 512-bit integer vector classes for 32 and 64 bit integers.
@@ -22,7 +22,7 @@
 * Each vector object is represented internally in the CPU as a 512-bit register.
 * This header file defines operators and functions for these vectors.
 *
-* (c) Copyright 2012-2020 Agner Fog.
+* (c) Copyright 2012-2023 Agner Fog.
 * Apache License version 2.0 or later.
 *****************************************************************************/
 
@@ -33,7 +33,7 @@
 #include "vectorclass.h"
 #endif
 
-#if VECTORCLASS_H < 20100
+#if VECTORCLASS_H < 20200
 #error Incompatible versions of vector class library mixed
 #endif
 
@@ -85,8 +85,7 @@ protected:
     __m512i zmm; // Integer vector
 public:
     // Default constructor:
-    Vec512b() {
-    }
+    Vec512b() = default;
     // Constructor to build from two Vec256b:
     Vec512b(Vec256b const a0, Vec256b const a1) {
         zmm = _mm512_inserti64x4(_mm512_castsi256_si512(a0), a1, 1);
@@ -200,10 +199,6 @@ static inline Vec512b andnot (Vec512b const a, Vec512b const b) {
     return _mm512_andnot_epi32(b, a);
 }
 
-static inline __m512i zero_si512() {
-    return _mm512_setzero_si512();
-}
-
 
 /*****************************************************************************
 *
@@ -214,8 +209,7 @@ static inline __m512i zero_si512() {
 class Vec16i: public Vec512b {
 public:
     // Default constructor:
-    Vec16i() {
-    }
+    Vec16i() = default;
     // Constructor to broadcast the same value into all elements:
     Vec16i(int i) {
         zmm = _mm512_set1_epi32(i);
@@ -252,16 +246,6 @@ public:
         zmm = _mm512_load_si512(p);
         return *this;
     }
-    // Member function to load 16 unsigned 8-bit integers from array
-    Vec16i & load_16uc(void const * p) {
-        zmm = _mm512_cvtepu8_epi32(Vec16uc().load(p));
-        return *this;
-    }
-    // Member function to load 16 unsigned 16-bit integers from array
-    Vec16i & load_16us(void const * p) {
-        zmm = _mm512_cvtepu16_epi32(Vec16us().load(p));
-        return *this;
-    }
     // Partial load. Load n elements and set the rest to 0
     Vec16i & load_partial(int n, void const * p) {
         zmm = _mm512_maskz_loadu_epi32(__mmask16((1u << n) - 1), p);
@@ -554,8 +538,7 @@ static inline Vec16i rotate_left(Vec16i const a, int b) {
 class Vec16ui : public Vec16i {
 public:
     // Default constructor:
-    Vec16ui() {
-    }
+    Vec16ui() = default;
     // Constructor to broadcast the same value into all elements:
     Vec16ui(uint32_t i) {
         zmm = _mm512_set1_epi32((int32_t)i);
@@ -768,8 +751,7 @@ static inline Vec16ui min(Vec16ui const a, Vec16ui const b) {
 class Vec8q : public Vec512b {
 public:
     // Default constructor:
-    Vec8q() {
-    }
+    Vec8q() = default;
     // Constructor to broadcast the same value into all elements:
     Vec8q(int64_t i) {
         zmm = _mm512_set1_epi64(i);
@@ -1107,8 +1089,7 @@ static inline Vec8q rotate_left(Vec8q const a, int b) {
 class Vec8uq : public Vec8q {
 public:
     // Default constructor:
-    Vec8uq() {
-    }
+    Vec8uq() = default;
     // Constructor to broadcast the same value into all elements:
     Vec8uq(uint64_t i) {
         zmm = Vec8q((int64_t)i);
@@ -1171,7 +1152,7 @@ public:
         return Vec4uq(Vec8q::get_high());
     }
     static constexpr int elementtype() {
-        return 10;
+        return 11;
     }
 };
 
@@ -1360,7 +1341,7 @@ static inline Vec8q permute8(Vec8q const a) {
                 if constexpr ((flags & perm_addz2) == 0) return y;
             }
             else if constexpr ((flags & perm_cross_lane) == 0) {  // no lane crossing. Use pshufb
-                const EList <int8_t, 64> bm = pshufb_mask<Vec8q>(indexs);
+                constexpr EList <int8_t, 64> bm = pshufb_mask<Vec8q>(indexs);
                 return _mm512_shuffle_epi8(y, Vec8q().load(bm.a));
             }
             else {
@@ -1440,7 +1421,7 @@ static inline Vec16i permute16(Vec16i const a) {
                 if constexpr ((flags & perm_addz2) == 0) return y;
             }
             else if constexpr ((flags & perm_cross_lane) == 0) { // no lane crossing. Use pshufb
-                const EList <int8_t, 64> bm = pshufb_mask<Vec16i>(indexs);
+                constexpr EList <int8_t, 64> bm = pshufb_mask<Vec16i>(indexs);
                 return _mm512_shuffle_epi8(a, Vec16i().load(bm.a));
             }
             else {
@@ -1511,7 +1492,7 @@ static inline Vec8q blend8(Vec8q const a, Vec8q const b) {
             y = _mm512_shuffle_i64x2(b, a, shuf);
         }
         else {
-            const EList <int64_t, 8> bm = perm_mask_broad<Vec8q>(indexs);   // full permute
+            constexpr EList <int64_t, 8> bm = perm_mask_broad<Vec8q>(indexs);   // full permute
             y = _mm512_permutex2var_epi64(a, Vec8q().load(bm.a), b);
         }
     }
@@ -1539,7 +1520,7 @@ static inline Vec8q blend8(Vec8q const a, Vec8q const b) {
     // we might use 2 x _mm512_mask(z)_shuffle_epi32 like in blend16 below
 #endif
     else { // No special cases
-        const EList <int64_t, 8> bm = perm_mask_broad<Vec8q>(indexs);   // full permute
+        constexpr EList <int64_t, 8> bm = perm_mask_broad<Vec8q>(indexs);   // full permute
         y = _mm512_permutex2var_epi64(a, Vec8q().load(bm.a), b);
     }
     if constexpr ((flags & blend_zeroing) != 0) {          // additional zeroing needed
@@ -1640,7 +1621,7 @@ static inline Vec16i blend16(Vec16i const a, Vec16i const b) {
     }
 
     else { // No special cases
-        const EList <int32_t, 16> bm = perm_mask_broad<Vec16i>(indexs);   // full permute
+        constexpr EList <int32_t, 16> bm = perm_mask_broad<Vec16i>(indexs);   // full permute
         y = _mm512_permutex2var_epi32(a, Vec16i().load(bm.a), b);
     }
     if constexpr ((flags & blend_zeroing) != 0) {          // additional zeroing needed
@@ -1695,7 +1676,10 @@ static inline Vec16i lookup(Vec16i const index, void const * table) {
     }
     // n > 32. Limit index
     Vec16ui index1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        index1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         index1 = Vec16ui(index) & (n-1);
     }
@@ -1726,7 +1710,10 @@ static inline Vec8q lookup(Vec8q const index, void const * table) {
     }
     // n > 16. Limit index
     Vec8uq index1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        index1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         index1 = Vec8uq(index) & (n-1);
     }
@@ -1894,7 +1881,7 @@ static inline void scatter(Vec8i const index, uint32_t limit, Vec8q const data,
 
 /*****************************************************************************
 *
-*          Functions for conversion between integer sizes
+*          Functions for conversion between integer sizes and vector types
 *
 *****************************************************************************/
 
@@ -1949,6 +1936,42 @@ static inline Vec16ui compress_saturated (Vec8uq const low, Vec8uq const high) {
     return Vec16ui(low2, high2);
 }
 
+#ifdef ZEXT_MISSING
+// GCC v. 9 and earlier are missing the _mm512_zextsi256_si512 intrinsic
+// extend vectors to double size by adding zeroes
+static inline Vec16i extend_z(Vec8i a) {
+    return Vec16i(a, Vec8i(0));
+}
+static inline Vec16ui extend_z(Vec8ui a) {
+    return Vec16ui(a, Vec8ui(0));
+}
+static inline Vec8q extend_z(Vec4q a) {
+    return Vec8q(a, Vec4q(0));
+}
+static inline Vec8uq extend_z(Vec4uq a) {
+    return Vec8uq(a, Vec4uq(0));
+}
+#else
+// extend vectors to double size by adding zeroes
+static inline Vec16i extend_z(Vec8i a) {
+    return _mm512_zextsi256_si512(a);
+}
+static inline Vec16ui extend_z(Vec8ui a) {
+    return _mm512_zextsi256_si512(a);
+}
+static inline Vec8q extend_z(Vec4q a) {
+    return _mm512_zextsi256_si512(a);
+}
+static inline Vec8uq extend_z(Vec4uq a) {
+    return _mm512_zextsi256_si512(a);
+}
+#endif
+
+// compact boolean vectors
+
+//static inline Vec16ib extend_z(Vec8ib a); // same as Vec16is extend_z(Vec8is)
+//static inline Vec8qb extend_z(Vec4qb a);  // same as Vec8ib extend_z(Vec4ib)
+
 
 /*****************************************************************************
 *
diff --git a/LGhost/VCL2/vectori512e.h b/LGhost/VCL2/vectori512e.h
index e1dc4d9..5991d23 100644
--- a/LGhost/VCL2/vectori512e.h
+++ b/LGhost/VCL2/vectori512e.h
@@ -1,8 +1,8 @@
 /****************************  vectori512e.h   *******************************
 * Author:        Agner Fog
 * Date created:  2014-07-23
-* Last modified: 2020-03-26
-* Version:       2.01.02
+* Last modified: 2023-06-03
+* Version:       2.02.01
 * Project:       vector classes
 * Description:
 * Header file defining 512-bit integer vector classes for 32 and 64 bit integers.
@@ -21,7 +21,7 @@
 * Each vector object is represented internally in the CPU as two 256-bit registers.
 * This header file defines operators and functions for these vectors.
 *
-* (c) Copyright 2012-2020 Agner Fog.
+* (c) Copyright 2012-2023 Agner Fog.
 * Apache License version 2.0 or later.
 *****************************************************************************/
 
@@ -32,7 +32,7 @@
 #include "vectorclass.h"
 #endif
 
-#if VECTORCLASS_H < 20100
+#if VECTORCLASS_H < 20200
 #error Incompatible versions of vector class library mixed
 #endif
 
@@ -59,8 +59,7 @@ protected:
     Vec256b z1;                         // high half
 public:
     // Default constructor:
-    Vec512b() {
-    }
+    Vec512b() = default;
     // Constructor to build from two Vec256b:
     Vec512b(Vec256b const a0, Vec256b const a1) {
         z0 = a0;  z1 = a1;
@@ -169,8 +168,7 @@ static inline Vec512b andnot (Vec512b const a, Vec512b const b) {
 class Vec16b : public Vec512b {
 public:
     // Default constructor:
-    Vec16b () {
-    }
+    Vec16b() = default;
     // Constructor to build from all elements:
     Vec16b(bool b0, bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7,
     bool b8, bool b9, bool b10, bool b11, bool b12, bool b13, bool b14, bool b15) {
@@ -332,8 +330,7 @@ static inline bool horizontal_or (Vec16b const a) {
 class Vec16ib : public Vec16b {
 public:
     // Default constructor:
-    Vec16ib () {
-    }
+    Vec16ib () = default;
     /*
     Vec16ib (Vec16b const & x) {
         z0 = x.get_low();
@@ -456,8 +453,7 @@ static inline Vec16ib andnot (Vec16ib const a, Vec16ib const b) {
 class Vec8b : public Vec16b {
 public:
     // Default constructor:
-    Vec8b () {
-    }
+    Vec8b () = default;
     /*
     Vec8b (Vec16b const & x) {
         z0 = x.get_low();
@@ -536,8 +532,7 @@ public:
 class Vec8qb : public Vec8b {
 public:
     // Default constructor:
-    Vec8qb () {
-    }
+    Vec8qb() = default;
     Vec8qb (Vec16b const x) {
         z0 = x.get_low();
         z1 = x.get_high();
@@ -659,8 +654,7 @@ static inline Vec8qb andnot (Vec8qb const a, Vec8qb const b) {
 class Vec16i: public Vec512b {
 public:
     // Default constructor:
-    Vec16i() {
-    }
+    Vec16i() = default;
     // Constructor to broadcast the same value into all elements:
     Vec16i(int i) {
         z0 = z1 = Vec8i(i);
@@ -1001,18 +995,17 @@ static inline Vec16i rotate_left(Vec16i const a, int b) {
 class Vec16ui : public Vec16i {
 public:
     // Default constructor:
-    Vec16ui() {
-    };
+    Vec16ui() = default;
     // Constructor to broadcast the same value into all elements:
     Vec16ui(uint32_t i) {
         z0 = z1 = Vec8ui(i);
-    };
+    }
     // Constructor to build from all elements:
     Vec16ui(uint32_t i0, uint32_t i1, uint32_t i2, uint32_t i3, uint32_t i4, uint32_t i5, uint32_t i6, uint32_t i7,
     uint32_t i8, uint32_t i9, uint32_t i10, uint32_t i11, uint32_t i12, uint32_t i13, uint32_t i14, uint32_t i15) {
         z0 = Vec8ui(i0, i1, i2, i3, i4, i5, i6, i7);
         z1 = Vec8ui(i8, i9, i10, i11, i12, i13, i14, i15);
-    };
+    }
     // Constructor to build from two Vec8ui:
     Vec16ui(Vec8ui const a0, Vec8ui const a1) {
         z0 = a0;
@@ -1215,8 +1208,7 @@ static inline Vec16ui min(Vec16ui const a, Vec16ui const b) {
 class Vec8q : public Vec512b {
 public:
     // Default constructor:
-    Vec8q() {
-    }
+    Vec8q() = default;
     // Constructor to broadcast the same value into all elements:
     Vec8q(int64_t i) {
         z0 = z1 = Vec4q(i);
@@ -1557,8 +1549,7 @@ static inline Vec8q rotate_left(Vec8q const a, int b) {
 class Vec8uq : public Vec8q {
 public:
     // Default constructor:
-    Vec8uq() {
-    }
+    Vec8uq() = default;
     // Constructor to broadcast the same value into all elements:
     Vec8uq(uint64_t i) {
         z0 = z1 = Vec4uq(i);
@@ -1856,7 +1847,10 @@ static inline Vec16i lookup(Vec16i const index, void const * table) {
     if constexpr (n <= 16) return lookup16(index, Vec16i().load(table));
     // n > 16. Limit index
     Vec16ui i1;
-    if constexpr ((n & (n - 1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        i1 = index;
+    }
+    else if constexpr ((n & (n - 1)) == 0) {
         // n is a power of 2, make index modulo n
         i1 = Vec16ui(index) & (n - 1);
     }
@@ -1908,7 +1902,10 @@ static inline Vec8q lookup(Vec8q const index, void const * table) {
     }
     // n > 8. Limit index
     Vec8uq i1;
-    if constexpr ((n & (n-1)) == 0) {
+    if constexpr (n == INT_MAX) {
+        i1 = index;
+    }
+    else if constexpr ((n & (n-1)) == 0) {
         // n is a power of 2, make index modulo n
         i1 = Vec8uq(index) & (n-1);
     }
@@ -2102,7 +2099,7 @@ static inline Vec8q gather8q(void const * a) {
 
 /*****************************************************************************
 *
-*          Functions for conversion between integer sizes
+*          Functions for conversion between integer sizes and vector types
 *
 *****************************************************************************/
 
@@ -2207,6 +2204,29 @@ static inline Vec16ui compress_saturated (Vec8uq const low, Vec8uq const high) {
     return Vec16ui(compress_saturated(low.get_low(),low.get_high()), compress_saturated(high.get_low(),high.get_high()));
 }
 
+// extend vectors to double size by adding zeroes
+static inline Vec16i extend_z(Vec8i a) {
+    return Vec16i(a, Vec8i(0));
+}
+static inline Vec16ui extend_z(Vec8ui a) {
+    return Vec16ui(a, Vec8ui(0));
+}
+static inline Vec8q extend_z(Vec4q a) {
+    return Vec8q(a, Vec4q(0));
+}
+static inline Vec8uq extend_z(Vec4uq a) {
+    return Vec8uq(a, Vec4uq(0));
+}
+
+// broad boolean vectors
+
+static inline Vec16ib extend_z(Vec8ib a) {
+    return Vec16ib(a, Vec8ib(false));
+}
+static inline Vec8qb extend_z(Vec4qb a) {
+    return Vec8qb(a, Vec4qb(false));
+} 
+
 
 /*****************************************************************************
 *
diff --git a/LGhost/VCL2/vectori512s.h b/LGhost/VCL2/vectori512s.h
index 38000a6..6d19ef4 100644
--- a/LGhost/VCL2/vectori512s.h
+++ b/LGhost/VCL2/vectori512s.h
@@ -1,8 +1,8 @@
 /****************************  vectori512s.h   ********************************
 * Author:        Agner Fog
 * Date created:  2019-04-20
-* Last modified: 2020-02-23
-* Version:       2.01.01
+* Last modified: 2023-07-04
+* Version:       2.02.02
 * Project:       vector classes
 * Description:
 * Header file defining 512-bit integer vector classes for 8 and 16 bit integers.
@@ -22,7 +22,7 @@
 * Each vector object is represented internally in the CPU as a 512-bit register.
 * This header file defines operators and functions for these vectors.
 *
-* (c) Copyright 2012-2020 Agner Fog.
+* (c) Copyright 2012-2023 Agner Fog.
 * Apache License version 2.0 or later.
 ******************************************************************************/
 
@@ -33,7 +33,7 @@
 #include "vectorclass.h"
 #endif
 
-#if VECTORCLASS_H < 20100
+#if VECTORCLASS_H < 20200
 #error Incompatible versions of vector class library mixed
 #endif
 
@@ -57,8 +57,7 @@ namespace VCL_NAMESPACE {
 class Vec64c: public Vec512b {
 public:
     // Default constructor:
-    Vec64c() {
-    }
+    Vec64c() = default;
     // Constructor to broadcast the same value into all elements:
     Vec64c(int8_t i) {
         zmm = _mm512_set1_epi8(i);
@@ -182,8 +181,7 @@ protected:
     __mmask64  mm; // Boolean vector
 public:
     // Default constructor:
-    Vec64b () {
-    }
+    Vec64b () = default;
     // Constructor to build from all elements:
     /*
     Vec64b(bool b0, bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7,
@@ -607,7 +605,7 @@ static inline Vec64c abs_saturated(Vec64c const a) {
 // function rotate_left all elements
 // Use negative count to rotate right
 static inline Vec64c rotate_left(Vec64c const a, int b) {
-    uint8_t mask  = 0xFFu << b;                    // mask off overflow bits
+    int8_t  mask  = int8_t(0xFFu << b);            // mask off overflow bits
     __m512i m     = _mm512_set1_epi8(mask);
     __m128i bb    = _mm_cvtsi32_si128(b & 7);      // b modulo 8
     __m128i mbb   = _mm_cvtsi32_si128((- b) & 7);  // 8-b modulo 8
@@ -628,8 +626,7 @@ static inline Vec64c rotate_left(Vec64c const a, int b) {
 class Vec64uc : public Vec64c {
 public:
     // Default constructor:
-    Vec64uc() {
-    }
+    Vec64uc() = default;
     // Constructor to broadcast the same value into all elements:
     Vec64uc(uint8_t i) {
         zmm = _mm512_set1_epi8((int8_t)i);
@@ -643,10 +640,10 @@ public:
         uint8_t i40, uint8_t i41, uint8_t i42, uint8_t i43, uint8_t i44, uint8_t i45, uint8_t i46, uint8_t i47,
         uint8_t i48, uint8_t i49, uint8_t i50, uint8_t i51, uint8_t i52, uint8_t i53, uint8_t i54, uint8_t i55,
         uint8_t i56, uint8_t i57, uint8_t i58, uint8_t i59, uint8_t i60, uint8_t i61, uint8_t i62, uint8_t i63)
-        : Vec64c(i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
-            i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31,
-            i32, i33, i34, i35, i36, i37, i38, i39, i40, i41, i42, i43, i44, i45, i46, i47,
-            i48, i49, i50, i51, i52, i53, i54, i55, i56, i57, i58, i59, i60, i61, i62, i63) {}
+        : Vec64c(int8_t(i0), int8_t(i1), int8_t(i2), int8_t(i3), int8_t(i4), int8_t(i5), int8_t(i6), int8_t(i7), int8_t(i8), int8_t(i9), int8_t(i10), int8_t(i11), int8_t(i12), int8_t(i13), int8_t(i14), int8_t(i15),
+            int8_t(i16), int8_t(i17), int8_t(i18), int8_t(i19), int8_t(i20), int8_t(i21), int8_t(i22), int8_t(i23), int8_t(i24), int8_t(i25), int8_t(i26), int8_t(i27), int8_t(i28), int8_t(i29), int8_t(i30), int8_t(i31),
+            int8_t(i32), int8_t(i33), int8_t(i34), int8_t(i35), int8_t(i36), int8_t(i37), int8_t(i38), int8_t(i39), int8_t(i40), int8_t(i41), int8_t(i42), int8_t(i43), int8_t(i44), int8_t(i45), int8_t(i46), int8_t(i47),
+            int8_t(i48), int8_t(i49), int8_t(i50), int8_t(i51), int8_t(i52), int8_t(i53), int8_t(i54), int8_t(i55), int8_t(i56), int8_t(i57), int8_t(i58), int8_t(i59), int8_t(i60), int8_t(i61), int8_t(i62), int8_t(i63)) {}
 
     // Constructor to build from two Vec32uc:
     Vec64uc(Vec32uc const a0, Vec32uc const a1) {
@@ -842,8 +839,7 @@ static inline Vec64uc min(Vec64uc const a, Vec64uc const b) {
 class Vec32s: public Vec512b {
 public:
     // Default constructor:
-    Vec32s() {
-    }
+    Vec32s() = default;
     // Constructor to broadcast the same value into all elements:
     Vec32s(int16_t i) {
         zmm = _mm512_set1_epi16(i);
@@ -892,11 +888,6 @@ public:
         zmm = _mm512_load_si512(p);
         return *this;
     }
-    // Member function to load 32 unsigned 8-bit integers from array
-    Vec32s & load_32uc(void const * p) {
-        zmm = _mm512_cvtepu8_epi16(Vec32uc().load(p));
-        return *this;
-    }
     // Partial load. Load n elements and set the rest to 0
     Vec32s & load_partial(int n, void const * p) {
         zmm = _mm512_maskz_loadu_epi16(__mmask32(((uint64_t)1 << n) - 1), p);
@@ -1197,8 +1188,7 @@ static inline Vec32s rotate_left(Vec32s const a, int b) {
 class Vec32us : public Vec32s {
 public:
     // Default constructor:
-    Vec32us() {
-    }
+    Vec32us() = default;
     // Constructor to broadcast the same value into all elements:
     Vec32us(uint16_t i) {
         zmm = _mm512_set1_epi16((int16_t)i);
@@ -1208,8 +1198,8 @@ public:
         uint16_t i8,  uint16_t i9,  uint16_t i10, uint16_t i11, uint16_t i12, uint16_t i13, uint16_t i14, uint16_t i15,
         uint16_t i16, uint16_t i17, uint16_t i18, uint16_t i19, uint16_t i20, uint16_t i21, uint16_t i22, uint16_t i23,
         uint16_t i24, uint16_t i25, uint16_t i26, uint16_t i27, uint16_t i28, uint16_t i29, uint16_t i30, uint16_t i31)
-    : Vec32s(i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,
-         i16, i17, i18, i19, i20, i21, i22, i23, i24, i25, i26, i27, i28, i29, i30, i31) {}
+    : Vec32s(int16_t(i0), int16_t(i1), int16_t(i2), int16_t(i3), int16_t(i4), int16_t(i5), int16_t(i6), int16_t(i7), int16_t(i8), int16_t(i9), int16_t(i10), int16_t(i11), int16_t(i12), int16_t(i13), int16_t(i14), int16_t(i15),
+         int16_t(i16), int16_t(i17), int16_t(i18), int16_t(i19), int16_t(i20), int16_t(i21), int16_t(i22), int16_t(i23), int16_t(i24), int16_t(i25), int16_t(i26), int16_t(i27), int16_t(i28), int16_t(i29), int16_t(i30), int16_t(i31)) {}
 
     // Constructor to build from two Vec16us:
     Vec32us(Vec16us const a0, Vec16us const a1) {
@@ -1429,14 +1419,18 @@ template <int... i0 >
             if constexpr ((flags & perm_rotate) != 0) {         // fits palignr. rotate within lanes
                 y = _mm512_alignr_epi8(a, a, (flags >> perm_rot_count) & 0xF);
             }
+            else if constexpr ((flags & perm_swap) != 0) {      // swap adjacent elements. rotate 32 bits
+                y = _mm512_rol_epi32(a, 16);
+
+            }
             else { // use pshufb
-                const EList <int8_t, 64> bm = pshufb_mask<Vec32s>(indexs);
+                constexpr EList <int8_t, 64> bm = pshufb_mask<Vec32s>(indexs);
                 return _mm512_shuffle_epi8(a, Vec32s().load(bm.a));
             }
         }
         else {  // different patterns in all lanes
             if constexpr ((flags & perm_cross_lane) == 0) {     // no lane crossing. Use pshufb
-                const EList <int8_t, 64> bm = pshufb_mask<Vec32s>(indexs);
+                constexpr EList <int8_t, 64> bm = pshufb_mask<Vec32s>(indexs);
                 return _mm512_shuffle_epi8(a, Vec32s().load(bm.a));
             }
             else if constexpr ((flags & perm_rotate_big) != 0) {// fits full rotate
@@ -1466,7 +1460,7 @@ template <int... i0 >
             }
 #endif  // AVX512VBMI2
             else {  // full permute needed
-                const EList <int16_t, 32> bm = perm_mask_broad<Vec32s>(indexs);
+                constexpr EList <int16_t, 32> bm = perm_mask_broad<Vec32s>(indexs);
                 y = _mm512_permutexvar_epi16 (Vec32s().load(bm.a), y);
             }
         }
@@ -1512,7 +1506,7 @@ static inline Vec64c permute64(Vec64c const a) {
         }
         else {
             if constexpr ((flags & perm_cross_lane) == 0) {               // no lane crossing. Use pshufb
-                const EList <int8_t, 64> bm = pshufb_mask<Vec64c>(indexs);
+                constexpr EList <int8_t, 64> bm = pshufb_mask<Vec64c>(indexs);
                 return _mm512_shuffle_epi8(a, Vec64c().load(bm.a));
             }
             else if constexpr ((flags & perm_rotate_big) != 0) {          // fits full rotate
@@ -1543,7 +1537,7 @@ static inline Vec64c permute64(Vec64c const a) {
 #endif  // AVX512VBMI2
             else {      // full permute needed
 #ifdef __AVX512VBMI__   // full permute instruction available
-                const EList <int8_t, 64> bm = perm_mask_broad<Vec64c>(indexs);
+                constexpr EList <int8_t, 64> bm = perm_mask_broad<Vec64c>(indexs);
                 y = _mm512_permutexvar_epi8(Vec64c().load(bm.a), y);
 #else
                 // There is no 8-bit full permute. Use 16-bit permute
@@ -1633,7 +1627,7 @@ static inline Vec32s blend32(Vec32s const a, Vec32s const b) {
         if (!(flags & blend_addz)) return y;               // no remaining zeroing
     }
     else { // No special cases
-        const EList <int16_t, 32> bm = perm_mask_broad<Vec32s>(indexs);      // full permute
+        constexpr EList <int16_t, 32> bm = perm_mask_broad<Vec32s>(indexs);      // full permute
         y = _mm512_permutex2var_epi16(a, Vec32s().load(bm.a), b);
     }
     if constexpr ((flags & blend_zeroing) != 0) {          // additional zeroing needed
@@ -1691,7 +1685,7 @@ static inline Vec64c blend64(Vec64c const a, Vec64c const b) {
     }
     else { // No special cases
 #ifdef  __AVX512VBMI__   // AVX512VBMI
-        const EList <int8_t, 64> bm = perm_mask_broad<Vec64c>(indexs);      // full permute
+        constexpr EList <int8_t, 64> bm = perm_mask_broad<Vec64c>(indexs);      // full permute
         y = _mm512_permutex2var_epi8(a, Vec64c().load(bm.a), b);
 #else   // split into two permutes
         constexpr EList<int, 128> L = blend_perm_indexes<64, 0> (indexs);
@@ -1886,7 +1880,7 @@ static inline Vec64c shift_bytes_down(Vec64c const a) {
 
 /*****************************************************************************
 *
-*          Functions for conversion between integer sizes
+*          Functions for conversion between integer sizes and vector types
 *
 *****************************************************************************/
 
@@ -1989,14 +1983,6 @@ static inline Vec64uc compress_saturated (Vec32us const low, Vec32us const high)
     return  _mm512_permutexvar_epi64(in, pk);              // put in right place
 }
 
-// Function compress : packs two vectors of 16-bit integers into one vector of 8-bit integers
-// Signed to unsigned, with saturation
-static inline Vec64uc compress_saturated_s2u (Vec32s const low, Vec32s const high) {
-    __m512i pk    = _mm512_packus_epi16(low,high);         // this instruction saturates from signed 16 bit to unsigned 8 bit
-    __m512i in    = constant16ui<0,0,2,0,4,0,6,0,1,0,3,0,5,0,7,0>();
-    return  _mm512_permutexvar_epi64(in, pk);              // put in right place
-}
-
 // Compress 32-bit integers to 16-bit integers, signed and unsigned, with and without saturation
 
 // Function compress : packs two vectors of 32-bit integers into one vector of 16-bit integers
@@ -2035,13 +2021,44 @@ static inline Vec32us compress_saturated (Vec16ui const low, Vec16ui const high)
     return  _mm512_permutexvar_epi64(in, pk);              // put in right place
 }
 
-// Function compress : packs two vectors of 32-bit integers into one vector of 16-bit integers
-// Signed to unsigned, with saturation
-static inline Vec32us compress_saturated_s2u (Vec16i const low, Vec16i const high) {
-    __m512i pk    =  _mm512_packus_epi32(low,high);        // this instruction saturates from signed 32 bit to unsigned 16 bit
-    __m512i in    = constant16ui<0,0,2,0,4,0,6,0,1,0,3,0,5,0,7,0>();
-    return  _mm512_permutexvar_epi64(in, pk);              // put in right place
+#ifdef ZEXT_MISSING
+// GCC v. 9 and earlier are missing the _mm512_zextsi256_si512 intrinsic
+
+// extend vectors to double size by adding zeroes
+static inline Vec64c extend_z(Vec32c a) {
+    return Vec64c(a, Vec32c(0));
+}
+static inline Vec64uc extend_z(Vec32uc a) {
+    return Vec64uc(a, Vec32uc(0));
+}
+static inline Vec32s extend_z(Vec16s a) {
+    return Vec32s(a, Vec16s(0));
+}
+static inline Vec32us extend_z(Vec16us a) {
+    return Vec32us(a, Vec16us(0));
+}
+#else
+// extend vectors to double size by adding zeroes
+static inline Vec64c extend_z(Vec32c a) {
+    return _mm512_zextsi256_si512(a);
+}
+static inline Vec64uc extend_z(Vec32uc a) {
+    return _mm512_zextsi256_si512(a);
+}
+static inline Vec32s extend_z(Vec16s a) {
+    return _mm512_zextsi256_si512(a);
+}
+static inline Vec32us extend_z(Vec16us a) {
+    return _mm512_zextsi256_si512(a);
+}
+#endif
+
+// compact boolean vectors
+
+static inline Vec64b extend_z(Vec32b a) {
+    return __mmask64(__mmask32(a));
 }
+//static inline Vec32sb extend_z(Vec16sb a); same as Vec32cb extend_z(Vec16cb a) {
 
 
 /*****************************************************************************
diff --git a/LGhost/VCL2/vectori512se.h b/LGhost/VCL2/vectori512se.h
index 83a38a5..178662f 100644
--- a/LGhost/VCL2/vectori512se.h
+++ b/LGhost/VCL2/vectori512se.h
@@ -1,8 +1,8 @@
 /****************************  vectori512se.h   *******************************
 * Author:        Agner Fog
 * Date created:  2019-04-20
-* Last modified: 2020-02-23
-* Version:       2.01.01
+* Last modified: 2022-07-20
+* Version:       2.02.00
 * Project:       vector class library
 * Description:
 * Header file defining 512-bit integer vector classes for 8 and 16 bit integers.
@@ -22,7 +22,7 @@
 * Each vector object is represented internally in the CPU as two 256-bit registers.
 * This header file defines operators and functions for these vectors.
 *
-* (c) Copyright 2012-2020 Agner Fog.
+* (c) Copyright 2012-2022 Agner Fog.
 * Apache License version 2.0 or later.
 ******************************************************************************/
 
@@ -33,7 +33,7 @@
 #include "vectorclass.h"
 #endif
 
-#if VECTORCLASS_H < 20100
+#if VECTORCLASS_H < 20200
 #error Incompatible versions of vector class library mixed
 #endif
 
@@ -60,8 +60,7 @@ protected:
     Vec256b z1;          // higher 256 bits
 public:
     // Default constructor:
-    Vec64c() {
-    }
+    Vec64c() = default;
     // Constructor to build from two Vec32c:
     Vec64c(Vec32c const a0, Vec32c const a1) {
         z0 = a0;
@@ -240,8 +239,8 @@ public:
 class Vec64cb : public Vec64c {
 public:
     // Default constructor:
-    Vec64cb () {
-    }
+    Vec64cb() = default;
+
     Vec64cb (Vec64c const a) : Vec64c(a) {}
 
     // Constructor to build from all elements: Not implemented
@@ -640,8 +639,7 @@ static inline Vec64c rotate_left(Vec64c const a, int b) {
 class Vec64uc : public Vec64c {
 public:
     // Default constructor:
-    Vec64uc() {
-    }
+    Vec64uc() = default;
     // Construct from Vec64c
     Vec64uc(Vec64c const a) : Vec64c(a) {
     }
@@ -864,8 +862,7 @@ static inline Vec64uc min(Vec64uc const a, Vec64uc const b) {
 class Vec32s : public Vec64c {
 public:
     // Default constructor:
-    Vec32s() {
-    }
+    Vec32s() = default;
     // Constructor to broadcast the same value into all elements:
     Vec32s(int16_t i) {
         z0 = z1 = Vec16s(i);
@@ -1014,8 +1011,7 @@ public:
 class Vec32sb : public Vec32s {
 public:
     // Default constructor:
-    Vec32sb () {
-    }
+    Vec32sb() = default;
     // Constructor to build from all elements: Not implemented
 
     // Constructor to convert from type __mmask32 used in intrinsics: not possible
@@ -1395,8 +1391,7 @@ static inline Vec32s rotate_left(Vec32s const a, int b) {
 class Vec32us : public Vec32s {
 public:
     // Default constructor:
-    Vec32us() {
-    }
+    Vec32us() = default;
     // Construct from Vec32s
     Vec32us(Vec32s const a) {
         z0 = a.get_low();  z1 = a.get_high();
@@ -1789,7 +1784,7 @@ static inline Vec64c shift_bytes_down(Vec64c const a) {
 
 /*****************************************************************************
 *
-*          Functions for conversion between integer sizes
+*          Functions for conversion between integer sizes and vector types
 *
 *****************************************************************************/
 
@@ -1890,6 +1885,30 @@ static inline Vec32us compress_saturated (Vec16ui const low, Vec16ui const high)
     return Vec32us(compress_saturated(low.get_low(),low.get_high()), compress_saturated(high.get_low(),high.get_high()));
 }
 
+// extend vectors to double size by adding zeroes
+static inline Vec64c extend_z(Vec32c a) {
+    return Vec64c(a, Vec32c(0));
+}
+static inline Vec64uc extend_z(Vec32uc a) {
+    return Vec64uc(a, Vec32uc(0));
+}
+static inline Vec32s extend_z(Vec16s a) {
+    return Vec32s(a, Vec16s(0));
+}
+static inline Vec32us extend_z(Vec16us a) {
+    return Vec32us(a, Vec16us(0));
+}
+
+// broad boolean vectors
+
+static inline Vec64cb extend_z(Vec32cb a) {
+    return Vec64cb(a, Vec32cb(false));
+}
+static inline Vec32sb extend_z(Vec16sb a) {
+    return Vec32sb(a, Vec16sb(false));
+}
+
+
 
 /*****************************************************************************
 *
diff --git a/LGhost/VCL2/vectormath_common.h b/LGhost/VCL2/vectormath_common.h
index 8e082b6..b006f03 100644
--- a/LGhost/VCL2/vectormath_common.h
+++ b/LGhost/VCL2/vectormath_common.h
@@ -1,15 +1,15 @@
 /***************************  vectormath_common.h   ****************************
 * Author:        Agner Fog
 * Date created:  2014-04-18
-* Last modified: 2020-06-08
-* Version:       2.01.03
+* Last modified: 2022-07-20
+* Version:       2.02.00
 * Project:       vector classes
 * Description:
 * Header file containing common code for inline version of mathematical functions.
 *
 * For detailed instructions, see VectorClass.pdf
 *
-* (c) Copyright 2014-2020 Agner Fog.
+* (c) Copyright 2014-2022 Agner Fog.
 * Apache License version 2.0 or later.
 ******************************************************************************/
 
@@ -26,7 +26,7 @@
 #include "vectorclass.h"
 #endif
 
-#if VECTORCLASS_H < 20000
+#if VECTORCLASS_H < 20200
 #error Incompatible versions of vector class library mixed
 #endif
 
@@ -62,7 +62,7 @@ namespace VCL_NAMESPACE {
 /******************************************************************************
       templates for producing infinite and nan in desired vector type
 ******************************************************************************/
-template <class VTYPE>
+template <typename VTYPE>
 static inline VTYPE infinite_vec();
 
 template <>
diff --git a/LGhost/VCL2/vectormath_exp.h b/LGhost/VCL2/vectormath_exp.h
index 124b1a1..6713d8b 100644
--- a/LGhost/VCL2/vectormath_exp.h
+++ b/LGhost/VCL2/vectormath_exp.h
@@ -1,8 +1,8 @@
 /****************************  vectormath_exp.h   ******************************
 * Author:        Agner Fog
 * Date created:  2014-04-18
-* Last modified: 2020-06-08
-* Version:       2.00.03
+* Last modified: 2022-07-20
+* Version:       2.02.00
 * Project:       vector class library
 * Description:
 * Header file containing inline vector functions of logarithms, exponential
@@ -29,12 +29,12 @@
 *
 * For detailed instructions see vcl_manual.pdf
 *
-* (c) Copyright 2014-2020 Agner Fog.
+* (c) Copyright 2014-2022 Agner Fog.
 * Apache License version 2.0 or later.
 ******************************************************************************/
 
 #ifndef VECTORMATH_EXP_H
-#define VECTORMATH_EXP_H  1
+#define VECTORMATH_EXP_H  202
 
 #include "vectormath_common.h"
 
@@ -675,7 +675,7 @@ union vm_udi {
 
 // extract exponent of a positive number x as a floating point number
 static inline Vec4f exponent_f(Vec4f const x) {
-#ifdef __AVX512VL__                              // AVX512VL
+#if INSTRSET >= 10                               // AVX512VL
     // prevent returning -inf for x=0
     return _mm_maskz_getexp_ps(_mm_cmp_ps_mask(x,Vec4f(0.f),4), x);
 #else
@@ -692,7 +692,7 @@ static inline Vec4f exponent_f(Vec4f const x) {
 }
 
 static inline Vec2d exponent_f(Vec2d const x) {
-#ifdef __AVX512VL__                              // AVX512VL
+#if INSTRSET >= 10                               // AVX512VL
     // prevent returning -inf for x=0
     //return _mm_maskz_getexp_pd(x != 0., x);
     return _mm_maskz_getexp_pd(_mm_cmp_pd_mask(x,Vec2d(0.),4), x);
@@ -714,7 +714,7 @@ static inline Vec2d exponent_f(Vec2d const x) {
 #if MAX_VECTOR_SIZE >= 256
 
 static inline Vec8f exponent_f(Vec8f const x) {
-#ifdef __AVX512VL__                              // AVX512VL
+#if INSTRSET >= 10
     // prevent returning -inf for x=0
     //return _mm256_maskz_getexp_ps(x != 0.f, x);
     return _mm256_maskz_getexp_ps(_mm256_cmp_ps_mask(x,Vec8f(0.f),4), x);
@@ -733,7 +733,7 @@ static inline Vec8f exponent_f(Vec8f const x) {
 
 // extract exponent of a positive number x as a floating point number
 static inline Vec4d exponent_f(Vec4d const x) {
-#ifdef __AVX512VL__                              // AVX512VL
+#if INSTRSET >= 10
     // prevent returning -inf for x=0
     //return _mm256_maskz_getexp_pd(x != 0., x);
     return _mm256_maskz_getexp_pd(_mm256_cmp_pd_mask(x,Vec4d(0.),4), x);
@@ -1547,7 +1547,7 @@ static inline VTYPE pow_template_d(VTYPE const x0, VTYPE const y) {
     // data vectors
     VTYPE x, x1, x2;                             // x variable
     VTYPE px, qx, ef, yr, v;                     // calculation of logarithm
-    VTYPE lg, lg1, lg2;
+    VTYPE lg, lg1;
     VTYPE lgerr, x2err;
     VTYPE e1, e2, ee;
     VTYPE e3, z, z1;                             // calculation of exp and pow
@@ -1852,7 +1852,7 @@ static inline VTYPE pow_template_f(VTYPE const x0, VTYPE const y) {
     ee = e1 + e2 + e3;
     ei = roundi(ee);
     // biased exponent of result:
-    ej = ei + (ITYPE(reinterpret_i(z)) >> 23);
+    ej = ei + (ITYPE(reinterpret_i(abs(z))) >> 23);
     // check exponent for overflow and underflow
     overflow  = BVTYPE(ej >= 0x0FF) | (ee >  300.f);
     underflow = BVTYPE(ej <= 0x000) | (ee < -300.f);
@@ -1872,7 +1872,7 @@ static inline VTYPE pow_template_f(VTYPE const x0, VTYPE const y) {
     if (horizontal_or(overflow | underflow)) {
         // handle errors
         z = select(underflow, VTYPE(0.f), z);
-        z = select(overflow, infinite_vec<VTYPE>(), z);
+        z = select(overflow, infinite_vec<VTYPE>(), z);                
     }
 
     // check for x == 0
diff --git a/LGhost/VCL2/vectormath_hyp.h b/LGhost/VCL2/vectormath_hyp.h
index 6c0efa8..bebac00 100644
--- a/LGhost/VCL2/vectormath_hyp.h
+++ b/LGhost/VCL2/vectormath_hyp.h
@@ -1,8 +1,8 @@
 /****************************  vectormath_hyp.h   ******************************
 * Author:        Agner Fog
 * Date created:  2014-07-09
-* Last modified: 2019-08-01
-* Version:       2.00.00
+* Last modified: 2022-07-20
+* Version:       2.02.00
 * Project:       vector class library
 * Description:
 * Header file containing inline vector functions of hyperbolic and inverse
@@ -24,12 +24,12 @@
 *
 * For detailed instructions, see vectormath_common.h and vcl_manual.pdf
 *
-* (c) Copyright 2014-2019 Agner Fog.
+* (c) Copyright 2014-2022 Agner Fog.
 * Apache License version 2.0 or later.
 ******************************************************************************/
 
 #ifndef VECTORMATH_HYP_H
-#define VECTORMATH_HYP_H  1
+#define VECTORMATH_HYP_H  202
 
 #include "vectormath_exp.h"
 
diff --git a/LGhost/VCL2/vectormath_lib.h b/LGhost/VCL2/vectormath_lib.h
index 172fbbb..04be83c 100644
--- a/LGhost/VCL2/vectormath_lib.h
+++ b/LGhost/VCL2/vectormath_lib.h
@@ -1,30 +1,29 @@
 /****************************  vectormath_lib.h   *****************************
 * Author:        Agner Fog
 * Date created:  2012-05-30
-* Last modified: 2019-08-01
-* Version:       2.00.00
+* Last modified: 2022-08-02
+* Version:       2.02.00
 * Project:       vector class library
 * Description:
 * Header file defining mathematical functions on floating point vectors
-* using Intel SVML library
-*
-* Instructions to use SVML library:
-* Include this file and link with svml
+* using Intel SVML (Short Vector Math Library)
 *
+* Include this file if you want to use SVML for math functions on vectors
+* See vcl_manual.pdf for details on how to obtain the SVML library and link to it.
 * Alternatively, use the inline math functions by including
-* vectormath_exp.h for power and exponential functions
-* vectormath_trig.h for trigonometric functions
+* vectormath_exp.h for power and exponential functions,
+* vectormath_trig.h for trigonometric functions,
 * vectormath_hyp.h for hyperbolic functions
 *
 * For detailed instructions, see vcl_manual.pdf
 *
-* (c) Copyright 2012-2019 Agner Fog.
+* (c) Copyright 2012-2022 Agner Fog.
 * Apache License version 2.0 or later.
 \*****************************************************************************/
 
 // check combination of header files
 #ifndef VECTORMATH_LIB_H
-#define VECTORMATH_LIB_H  1
+#define VECTORMATH_LIB_H  202
 
 #ifdef VECTORMATH_COMMON_H
 #error conflicting header files. More than one implementation of mathematical functions included
@@ -36,11 +35,29 @@
 namespace VCL_NAMESPACE {    // optional name space
 #endif
 
+#if defined(__INTEL_COMPILER) || defined(__INTEL_LLVM_COMPILER)
+#define USE_SVML_INTRINSICS  // Intel compilers have intrinsic functions of access to SVML library
+#endif
+
+#if !(defined(USE_SVML_INTRINSICS))
+// sinpi, cospi, and tanpi functions are included in SVML, but undocumented
+// (The "Classic" version of Intel compiler accepts the intrinsics of these functions even though they are not in the header files)
+#define TRIGPI_FUNCTIONS
+#endif
+
+#if defined(__clang__) || defined (__GNUC__)
+#define SINCOS_ASM  // sincos can be fixed with inline assembly
+#else
+    // MS compiler does not support inline assembly. sincos not available
+#endif
+
+
+
+#ifdef USE_SVML_INTRINSICS
 
-#ifdef __INTEL_COMPILER
 /*****************************************************************************
 *
-*      128-bit vector functions using Intel compiler
+*      128-bit vector functions using Intel compiler intrinsic functions
 *
 *****************************************************************************/
 
@@ -145,6 +162,27 @@ static inline Vec2d tan(Vec2d const x) {    // tangent
     return _mm_tan_pd(x);
 }
 
+#ifdef TRIGPI_FUNCTIONS
+static inline Vec4f sinpi(Vec4f const x) {    // sine
+    return _mm_sinpi_ps(x);
+}
+static inline Vec2d sinpi(Vec2d const x) {    // sine
+    return _mm_sinpi_pd(x);
+}
+static inline Vec4f cospi(Vec4f const x) {    // cosine
+    return _mm_cospi_ps(x);
+}
+static inline Vec2d cospi(Vec2d const x) {    // cosine
+    return _mm_cospi_pd(x);
+}
+static inline Vec4f tanpi(Vec4f const x) {    // tangent
+    return _mm_tanpi_ps(x);
+}
+static inline Vec2d tanpi(Vec2d const x) {    // tangent
+    return _mm_tanpi_pd(x);
+}
+#endif // TRIGPI_FUNCTIONS
+
 // inverse trigonometric functions
 static inline Vec4f asin(Vec4f const x) {   // inverse sine
     return _mm_asin_ps(x);
@@ -245,25 +283,23 @@ static inline Vec2d cdfnorminv(Vec2d const x) {  // inverse cumulative normal di
 }
 
 #else
-/*****************************************************************************
+/*************************************************************************************
 *
-*      128-bit vector functions using other compiler than Intel
+*      128-bit vector functions using other compiler than Intel C++ compiler "Classic"
 *
-*****************************************************************************/
+*************************************************************************************/
 
-#if (defined(_WIN64) || defined(__CYGWIN__)) && defined(__x86_64__)
-// fix incompatible calling convention in Win64
-#if defined(_MSC_VER) || defined(__clang__)
-#define V_VECTORCALL __vectorcall
+#if (defined(_WIN64) && !defined(USE_SVML_INTRINSICS) )
+// (call with one parameter may work without __vectorcall because the parameter happens to be in zmm0, but that would be unsafe)
+#define V_VECTORCALL  __vectorcall  // fix calling convention, one parameter.
+#define V_VECTORCALL2 __vectorcall  // fix calling convention, two parameters or two returns
 #else
-// gcc. Change this if future gcc version supports __vectorcall
-#define V_VECTORCALL __attribute__((sysv_abi))  // this is inefficient but it works
-#endif
-#else  // not Win64. Vectors are transferred in registers by default
 #define V_VECTORCALL
+#define V_VECTORCALL2
 #endif
 
-// External function prototypes, 128-bit vectors
+
+// External function prototypes for SVML library, 128-bit vectors
 extern "C" {
     extern __m128  V_VECTORCALL __svml_expf4       (__m128);
     extern __m128d V_VECTORCALL __svml_exp2        (__m128d);
@@ -273,8 +309,8 @@ extern "C" {
     extern __m128d V_VECTORCALL __svml_exp22       (__m128d);
     extern __m128  V_VECTORCALL __svml_exp10f4     (__m128);
     extern __m128d V_VECTORCALL __svml_exp102      (__m128d);
-    extern __m128  V_VECTORCALL __svml_powf4       (__m128,  __m128);
-    extern __m128d V_VECTORCALL __svml_pow2        (__m128d, __m128d);
+    extern __m128  V_VECTORCALL2 __svml_powf4      (__m128,  __m128);
+    extern __m128d V_VECTORCALL2 __svml_pow2       (__m128d, __m128d);
     extern __m128  V_VECTORCALL __svml_cbrtf4      (__m128);
     extern __m128d V_VECTORCALL __svml_cbrt2       (__m128d);
     extern __m128  V_VECTORCALL __svml_invsqrtf4   (__m128);
@@ -291,18 +327,26 @@ extern "C" {
     extern __m128d V_VECTORCALL __svml_sin2        (__m128d);
     extern __m128  V_VECTORCALL __svml_cosf4       (__m128);
     extern __m128d V_VECTORCALL __svml_cos2        (__m128d);
-    extern __m128  V_VECTORCALL __svml_sincosf4    (__m128);  // cos returned in xmm1
-    extern __m128d V_VECTORCALL __svml_sincos2     (__m128d); // cos returned in xmm1
+    extern __m128  V_VECTORCALL2 __svml_sincosf4   (__m128);  // cos returned in xmm1
+    extern __m128d V_VECTORCALL2 __svml_sincos2    (__m128d); // cos returned in xmm1
     extern __m128  V_VECTORCALL __svml_tanf4       (__m128);
-    extern __m128d V_VECTORCALL __svml_tan2        (__m128d);
+    extern __m128d V_VECTORCALL __svml_tan2        (__m128d);    
+    extern __m128  V_VECTORCALL __svml_sinpif4     (__m128);
+    extern __m128d V_VECTORCALL __svml_sinpi2      (__m128d);
+    extern __m128  V_VECTORCALL __svml_cospif4     (__m128);
+    extern __m128d V_VECTORCALL __svml_cospi2      (__m128d);
+    //extern __m128  V_VECTORCALL2 __svml_sincospif4 (__m128); // not in library
+    //extern __m128d V_VECTORCALL2 __svml_sincospi2  (__m128d);// not in library
+    extern __m128  V_VECTORCALL __svml_tanpif4     (__m128);
+    extern __m128d V_VECTORCALL __svml_tanpi2      (__m128d);
     extern __m128  V_VECTORCALL __svml_asinf4      (__m128);
     extern __m128d V_VECTORCALL __svml_asin2       (__m128d);
     extern __m128  V_VECTORCALL __svml_acosf4      (__m128);
     extern __m128d V_VECTORCALL __svml_acos2       (__m128d);
     extern __m128  V_VECTORCALL __svml_atanf4      (__m128);
     extern __m128d V_VECTORCALL __svml_atan2       (__m128d);
-    extern __m128  V_VECTORCALL __svml_atan2f4     (__m128,  __m128);
-    extern __m128d V_VECTORCALL __svml_atan22      (__m128d, __m128d);
+    extern __m128  V_VECTORCALL2 __svml_atan2f4    (__m128,  __m128);
+    extern __m128d V_VECTORCALL2 __svml_atan22     (__m128d, __m128d);
     extern __m128  V_VECTORCALL __svml_sinhf4      (__m128);
     extern __m128d V_VECTORCALL __svml_sinh2       (__m128d);
     extern __m128  V_VECTORCALL __svml_coshf4      (__m128);
@@ -344,10 +388,10 @@ static inline Vec2d exp (Vec2d const x) {   // exponential function
     return  __svml_exp2(x);
 }
 
-static inline Vec4f expm1 (Vec4f const x) { // exp(x)-1. Avoids loss of precision if x is close to 1
+static inline Vec4f expm1 (Vec4f const x) { // exp(x)-1
     return  __svml_expm1f4(x);
 }
-static inline Vec2d expm1 (Vec2d const x) { // exp(x)-1. Avoids loss of precision if x is close to 1
+static inline Vec2d expm1 (Vec2d const x) { // exp(x)-1
     return  __svml_expm12(x);
 }
 
@@ -369,13 +413,13 @@ static inline Vec4f pow (Vec4f const a, Vec4f const b) {   // pow(a,b) = a to th
     return  __svml_powf4(a,b);
 }
 
-static inline Vec4f pow (Vec4f const a, float const b) {   // pow(a,b) = a to the power of b
+static inline Vec4f pow (Vec4f const a, float const b) {   // pow(a,b)
     return  __svml_powf4(a,Vec4f(b));
 }
-static inline Vec2d pow (Vec2d const a, Vec2d const b) {   // pow(a,b) = a to the power of b
+static inline Vec2d pow (Vec2d const a, Vec2d const b) {   // pow(a,b)
     return  __svml_pow2(a,b);
 }
-static inline Vec2d pow (Vec2d const a, double const b) {  // pow(a,b) = a to the power of b
+static inline Vec2d pow (Vec2d const a, double const b) {  // pow(a,b)
     return  __svml_pow2(a,Vec2d(b));
 }
 
@@ -430,28 +474,23 @@ static inline Vec2d cos (Vec2d const x) {   // cosine
     return  __svml_cos2(x);
 }
 
-#if defined(__unix__) || defined(__INTEL_COMPILER) || !defined(__x86_64__) || !defined(_MSC_VER)
-// no inline assembly in 64 bit MS compiler
-static inline Vec4f sincos (Vec4f * pcos, Vec4f const x) {   // sine and cosine. sin(x) returned, cos(x) in pcos
+// sincos function. sin(x) returned, cos(x) in pcos
+
+#ifdef SINCOS_ASM  // sincos can be fixed with inline assembly
+
+static inline Vec4f sincos (Vec4f * pcos, Vec4f const x) {
     __m128 r_sin, r_cos;
-    r_sin = __svml_sincosf4(x);
-#if defined(__unix__) || defined(__GNUC__)
-    //   __asm__ ( "call V_VECTORCALL __svml_sincosf4 \n movaps %%xmm0, %0 \n movaps %%xmm1, %1" : "=m"(r_sin), "=m"(r_cos) : "xmm0"(x) );
+    //   __asm__ ( "call __svml_sincosf4 \n movaps %%xmm0, %0 \n movaps %%xmm1, %1" : "=m"(r_sin), "=m"(r_cos) : "xmm0"(x) );
+    r_sin = __svml_sincosf4(x); // fix calling convention in windows and linux using assembly
     __asm__ __volatile__ ( "movaps %%xmm1, %0":"=m"(r_cos));
-#else // Windows
-    _asm movaps r_cos, xmm1;
-#endif
     *pcos = r_cos;
     return r_sin;
 }
+
 static inline Vec2d sincos (Vec2d * pcos, Vec2d const x) {   // sine and cosine. sin(x) returned, cos(x) in pcos
     __m128d r_sin, r_cos;
     r_sin = __svml_sincos2(x);
-#if defined(__unix__) || defined(__GNUC__)
     __asm__ __volatile__ ( "movaps %%xmm1, %0":"=m"(r_cos));
-#else // Windows
-    _asm movapd r_cos, xmm1;
-#endif
     *pcos = r_cos;
     return r_sin;
 }
@@ -464,6 +503,27 @@ static inline Vec2d tan (Vec2d const x) {   // tangent
     return  __svml_tan2(x);
 }
 
+static inline Vec4f sinpi (Vec4f const x) {   // sine
+    return  __svml_sinpif4(x);
+}
+static inline Vec2d sinpi (Vec2d const x) {   // sine
+    return  __svml_sinpi2(x);
+}
+
+static inline Vec4f cospi (Vec4f const x) {   // cosine
+    return  __svml_cospif4(x);
+}
+static inline Vec2d cospi (Vec2d const x) {   // cosine
+    return  __svml_cospi2(x);
+}
+
+static inline Vec4f tanpi (Vec4f const x) {   // tangent
+    return  __svml_tanpif4(x);
+}
+static inline Vec2d tanpi (Vec2d const x) {   // tangent
+    return  __svml_tanpi2(x);
+}
+
 // inverse trigonometric functions
 static inline Vec4f asin (Vec4f const x) {  // inverse sine
     return  __svml_asinf4(x);
@@ -572,101 +632,104 @@ static inline Vec2d cdfnorminv (Vec2d const x) { // inverse cumulative normal di
     return  __svml_cdfnorminv2(x);
 }
 
-#endif   // __INTEL_COMPILER
+#endif   // USE_SVML_INTRINSICS
+
+
 
 #if defined (MAX_VECTOR_SIZE) && MAX_VECTOR_SIZE >= 256  // 256 bit vectors
 
-#if defined (VECTORF256_H)   // 256-bit vector registers supported
+#if defined (VECTORF256_H)  // 256-bit vector registers supported
 
-#ifdef __INTEL_COMPILER
+#ifdef USE_SVML_INTRINSICS
 /*****************************************************************************
 *
-*      256-bit vector functions using Intel compiler
+*      256-bit vector functions using Intel compiler intrinsic functions
 *
 *****************************************************************************/
+
 // exponential and power functions
-static inline Vec8f exp(Vec8f const x) {    // exponential function
+static inline Vec8f exp(Vec8f const x) {       // exponential function
     return _mm256_exp_ps(x);
 }
-static inline Vec4d exp(Vec4d const x) {    // exponential function
+static inline Vec4d exp(Vec4d const x) {       // exponential function
     return _mm256_exp_pd(x);
 }
-static inline Vec8f expm1(Vec8f const x) {  // exp(x)-1. Avoids loss of precision if x is close to 1
+static inline Vec8f expm1(Vec8f const x) {     // exp(x)-1. Avoids loss of precision if x is close to 1
     return _mm256_expm1_ps(x);
 }
-static inline Vec4d expm1(Vec4d const x) {  // exp(x)-1. Avoids loss of precision if x is close to 1
+static inline Vec4d expm1(Vec4d const x) {     // exp(x)-1. Avoids loss of precision if x is close to 1
     return _mm256_expm1_pd(x);
 }
-static inline Vec8f exp2(Vec8f const x) {   // pow(2,x)
+static inline Vec8f exp2(Vec8f const x) {      // pow(2,x)
     return _mm256_exp2_ps(x);
 }
-static inline Vec4d exp2(Vec4d const x) {   // pow(2,x)
+static inline Vec4d exp2(Vec4d const x) {      // pow(2,x)
     return _mm256_exp2_pd(x);
 }
-static inline Vec8f exp10(Vec8f const x) {  // pow(10,x)
+static inline Vec8f exp10(Vec8f const x) {     // pow(10,x)
     return _mm256_exp10_ps(x);
 }
-static inline Vec4d exp10(Vec4d const x) {  // pow(10,x)
+static inline Vec4d exp10(Vec4d const x) {     // pow(10,x)
     return _mm256_exp10_pd(x);
 }
-static inline Vec8f pow(Vec8f const a, Vec8f const b) {    // pow(a,b) = a to the power of b
+static inline Vec8f pow(Vec8f const a, Vec8f const b) { // pow(a,b) = a to the power of b
     return _mm256_pow_ps(a, b);
 }
-static inline Vec8f pow(Vec8f const a, float const b) {    // pow(a,b) = a to the power of b
+static inline Vec8f pow(Vec8f const a, float const b) {  // pow(a,b) = a to the power of b
     return _mm256_pow_ps(a, Vec8f(b));
 }
-static inline Vec4d pow(Vec4d const a, Vec4d const b) {    // pow(a,b) = a to the power of b
+static inline Vec4d pow(Vec4d const a, Vec4d const b) {  // pow(a,b) = a to the power of b
     return _mm256_pow_pd(a, b);
 }
-static inline Vec4d pow(Vec4d const a, double const b) {   // pow(a,b) = a to the power of b
+static inline Vec4d pow(Vec4d const a, double const b) { // pow(a,b) = a to the power of b
     return _mm256_pow_pd(a, Vec4d(b));
 }
-static inline Vec8f cbrt(Vec8f const x) {   // pow(x,1/3)
+static inline Vec8f cbrt(Vec8f const x) {      // pow(x,1/3)
     return _mm256_cbrt_ps(x);
 }
-static inline Vec4d cbrt(Vec4d const x) {   // pow(x,1/3)
+static inline Vec4d cbrt(Vec4d const x) {      // pow(x,1/3)
     return _mm256_cbrt_pd(x);
 }
 // logarithms
-static inline Vec8f log(Vec8f const x) {    // natural logarithm
+static inline Vec8f log(Vec8f const x) {       // natural logarithm
     return _mm256_log_ps(x);
 }
-static inline Vec4d log(Vec4d const x) {    // natural logarithm
+static inline Vec4d log(Vec4d const x) {       // natural logarithm
     return _mm256_log_pd(x);
 }
-static inline Vec8f log1p(Vec8f const x) {  // log(1+x). Avoids loss of precision if 1+x is close to 1
+static inline Vec8f log1p(Vec8f const x) {     // log(1+x). Avoids loss of precision if 1+x is close to 1
     return _mm256_log1p_ps(x);
 }
-static inline Vec4d log1p(Vec4d const x) {  // log(1+x). Avoids loss of precision if 1+x is close to 1
+static inline Vec4d log1p(Vec4d const x) {     // log(1+x). Avoids loss of precision if 1+x is close to 1
     return _mm256_log1p_pd(x);
 }
-static inline Vec8f log2(Vec8f const x) {   // logarithm base 2
+static inline Vec8f log2(Vec8f const x) {      // logarithm base 2
     return _mm256_log2_ps(x);
 }
-static inline Vec4d log2(Vec4d const x) {   // logarithm base 2
+static inline Vec4d log2(Vec4d const x) {      // logarithm base 2
     return _mm256_log2_pd(x);
 }
-static inline Vec8f log10(Vec8f const x) {  // logarithm base 10
+static inline Vec8f log10(Vec8f const x) {     // logarithm base 10
     return _mm256_log10_ps(x);
 }
-static inline Vec4d log10(Vec4d const x) {  // logarithm base 10
+static inline Vec4d log10(Vec4d const x) {     // logarithm base 10
     return _mm256_log10_pd(x);
 }
 
 // trigonometric functions
-static inline Vec8f sin(Vec8f const x) {    // sine
+static inline Vec8f sin(Vec8f const x) {       // sine
     return _mm256_sin_ps(x);
 }
-static inline Vec4d sin(Vec4d const x) {    // sine
+static inline Vec4d sin(Vec4d const x) {       // sine
     return _mm256_sin_pd(x);
 }
-static inline Vec8f cos(Vec8f const x) {    // cosine
+static inline Vec8f cos(Vec8f const x) {       // cosine
     return _mm256_cos_ps(x);
 }
-static inline Vec4d cos(Vec4d const x) {    // cosine
+static inline Vec4d cos(Vec4d const x) {       // cosine
     return _mm256_cos_pd(x);
 }
-static inline Vec8f sincos(Vec8f * pcos, Vec8f const x) {   // sine and cosine. sin(x) returned, cos(x) in pcos
+static inline Vec8f sincos(Vec8f * pcos, Vec8f const x) { // sine and cosine. sin(x) returned, cos(x) in pcos
     __m256 r_sin, r_cos;
     r_sin = _mm256_sincos_ps(&r_cos, x);
     *pcos = r_cos;
@@ -678,320 +741,360 @@ static inline Vec4d sincos(Vec4d * pcos, Vec4d const x) {  // sine and cosine. s
     *pcos = r_cos;
     return r_sin;
 }
-static inline Vec8f tan(Vec8f const x) {    // tangent
+static inline Vec8f tan(Vec8f const x) {       // tangent
     return _mm256_tan_ps(x);
 }
-static inline Vec4d tan(Vec4d const x) {    // tangent
+static inline Vec4d tan(Vec4d const x) {       // tangent
     return _mm256_tan_pd(x);
 }
 
+#ifdef TRIGPI_FUNCTIONS
+static inline Vec8f sinpi(Vec8f const x) {     // sine
+    return _mm256_sinpi_ps(x);
+}
+static inline Vec4d sinpi(Vec4d const x) {     // sine
+    return _mm256_sinpi_pd(x);
+}
+static inline Vec8f cospi(Vec8f const x) {     // cosine
+    return _mm256_cospi_ps(x);
+}
+static inline Vec4d cospi(Vec4d const x) {     // cosine
+    return _mm256_cospi_pd(x);
+}
+static inline Vec8f tanpi(Vec8f const x) {     // tangent
+    return _mm256_tanpi_ps(x);
+}
+static inline Vec4d tanpi(Vec4d const x) {     // tangent
+    return _mm256_tanpi_pd(x);
+}
+#endif // TRIGPI_FUNCTIONS
+
 // inverse trigonometric functions
-static inline Vec8f asin(Vec8f const x) {   // inverse sine
+static inline Vec8f asin(Vec8f const x) {      // inverse sine
     return _mm256_asin_ps(x);
 }
-static inline Vec4d asin(Vec4d const x) {   // inverse sine
+static inline Vec4d asin(Vec4d const x) {      // inverse sine
     return _mm256_asin_pd(x);
 }
 
-static inline Vec8f acos(Vec8f const x) {   // inverse cosine
+static inline Vec8f acos(Vec8f const x) {      // inverse cosine
     return _mm256_acos_ps(x);
 }
-static inline Vec4d acos(Vec4d const x) {   // inverse cosine
+static inline Vec4d acos(Vec4d const x) {      // inverse cosine
     return _mm256_acos_pd(x);
 }
 
-static inline Vec8f atan(Vec8f const x) {   // inverse tangent
+static inline Vec8f atan(Vec8f const x) {      // inverse tangent
     return _mm256_atan_ps(x);
 }
-static inline Vec4d atan(Vec4d const x) {   // inverse tangent
+static inline Vec4d atan(Vec4d const x) {      // inverse tangent
     return _mm256_atan_pd(x);
 }
-static inline Vec8f atan2(Vec8f const a, Vec8f const b) {  // inverse tangent of a/b
+static inline Vec8f atan2(Vec8f const a, Vec8f const b) { // inverse tangent of a/b
     return _mm256_atan2_ps(a, b);
 }
-static inline Vec4d atan2(Vec4d const a, Vec4d const b) {  // inverse tangent of a/b
+static inline Vec4d atan2(Vec4d const a, Vec4d const b) { // inverse tangent of a/b
     return _mm256_atan2_pd(a, b);
 }
 
 // hyperbolic functions and inverse hyperbolic functions
-static inline Vec8f sinh(Vec8f const x) {   // hyperbolic sine
+static inline Vec8f sinh(Vec8f const x) {      // hyperbolic sine
     return _mm256_sinh_ps(x);
 }
-static inline Vec4d sinh(Vec4d const x) {   // hyperbolic sine
+static inline Vec4d sinh(Vec4d const x) {      // hyperbolic sine
     return _mm256_sinh_pd(x);
 }
-static inline Vec8f cosh(Vec8f const x) {   // hyperbolic cosine
+static inline Vec8f cosh(Vec8f const x) {      // hyperbolic cosine
     return _mm256_cosh_ps(x);
 }
-static inline Vec4d cosh(Vec4d const x) {   // hyperbolic cosine
+static inline Vec4d cosh(Vec4d const x) {      // hyperbolic cosine
     return _mm256_cosh_pd(x);
 }
-static inline Vec8f tanh(Vec8f const x) {   // hyperbolic tangent
+static inline Vec8f tanh(Vec8f const x) {      // hyperbolic tangent
     return _mm256_tanh_ps(x);
 }
-static inline Vec4d tanh(Vec4d const x) {   // hyperbolic tangent
+static inline Vec4d tanh(Vec4d const x) {      // hyperbolic tangent
     return _mm256_tanh_pd(x);
 }
-static inline Vec8f asinh(Vec8f const x) {  // inverse hyperbolic sine
+static inline Vec8f asinh(Vec8f const x) {     // inverse hyperbolic sine
     return _mm256_asinh_ps(x);
 }
-static inline Vec4d asinh(Vec4d const x) {  // inverse hyperbolic sine
+static inline Vec4d asinh(Vec4d const x) {     // inverse hyperbolic sine
     return _mm256_asinh_pd(x);
 }
-static inline Vec8f acosh(Vec8f const x) {  // inverse hyperbolic cosine
+static inline Vec8f acosh(Vec8f const x) {     // inverse hyperbolic cosine
     return _mm256_acosh_ps(x);
 }
-static inline Vec4d acosh(Vec4d const x) {  // inverse hyperbolic cosine
+static inline Vec4d acosh(Vec4d const x) {     // inverse hyperbolic cosine
     return _mm256_acosh_pd(x);
 }
-static inline Vec8f atanh(Vec8f const x) {  // inverse hyperbolic tangent
+static inline Vec8f atanh(Vec8f const x) {     // inverse hyperbolic tangent
     return _mm256_atanh_ps(x);
 }
-static inline Vec4d atanh(Vec4d const x) {  // inverse hyperbolic tangent
+static inline Vec4d atanh(Vec4d const x) {     // inverse hyperbolic tangent
     return _mm256_atanh_pd(x);
 }
 
 // error function
-static inline Vec8f erf(Vec8f const x) {    // error function
+static inline Vec8f erf(Vec8f const x) {       // error function
     return _mm256_erf_ps(x);
 }
-static inline Vec4d erf(Vec4d const x) {    // error function
+static inline Vec4d erf(Vec4d const x) {       // error function
     return _mm256_erf_pd(x);
 }
-static inline Vec8f erfc(Vec8f const x) {   // error function complement
+static inline Vec8f erfc(Vec8f const x) {      // error function complement
     return _mm256_erfc_ps(x);
 }
-static inline Vec4d erfc(Vec4d const x) {   // error function complement
+static inline Vec4d erfc(Vec4d const x) {      // error function complement
     return _mm256_erfc_pd(x);
 }
-static inline Vec8f erfinv(Vec8f const x) { // inverse error function
+static inline Vec8f erfinv(Vec8f const x) {    // inverse error function
     return _mm256_erfinv_ps(x);
 }
-static inline Vec4d erfinv(Vec4d const x) { // inverse error function
+static inline Vec4d erfinv(Vec4d const x) {    // inverse error function
     return _mm256_erfinv_pd(x);
 }
 
-static inline Vec8f cdfnorm(Vec8f const x) {     // cumulative normal distribution function
+static inline Vec8f cdfnorm(Vec8f const x) {   // cumulative normal distribution function
     return _mm256_cdfnorm_ps(x);
 }
-static inline Vec4d cdfnorm(Vec4d const x) {     // cumulative normal distribution function
+static inline Vec4d cdfnorm(Vec4d const x) {   // cumulative normal distribution function
     return _mm256_cdfnorm_pd(x);
 }
-static inline Vec8f cdfnorminv(Vec8f const x) {  // inverse cumulative normal distribution function
+static inline Vec8f cdfnorminv(Vec8f const x) {// inverse cumulative normal distribution function
     return _mm256_cdfnorminv_ps(x);
 }
-static inline Vec4d cdfnorminv(Vec4d const x) {  // inverse cumulative normal distribution function
+static inline Vec4d cdfnorminv(Vec4d const x) {// inverse cumulative normal distribution function
     return _mm256_cdfnorminv_pd(x);
 }
 
-
-#else    // __INTEL_COMPILER
+#else    // not USE_SVML_INTRINSICS
 /*****************************************************************************
 *
 *      256-bit vector functions using other compiler than Intel
 *
 *****************************************************************************/
-// External function prototypes, 256-bit vectors
+
+// External function prototypes for SVML library, 256-bit vectors
 extern "C" {
-    extern __m256  V_VECTORCALL __svml_expf8       (__m256);
-    extern __m256d V_VECTORCALL __svml_exp4        (__m256d);
-    extern __m256  V_VECTORCALL __svml_expm1f8     (__m256);
-    extern __m256d V_VECTORCALL __svml_expm14      (__m256d);
-    extern __m256  V_VECTORCALL __svml_exp2f8      (__m256);
-    extern __m256d V_VECTORCALL __svml_exp24       (__m256d);
-    extern __m256  V_VECTORCALL __svml_exp10f8     (__m256);
-    extern __m256d V_VECTORCALL __svml_exp104      (__m256d);
-    extern __m256  V_VECTORCALL __svml_powf8       (__m256,  __m256);
-    extern __m256d V_VECTORCALL __svml_pow4        (__m256d, __m256d);
-    extern __m256  V_VECTORCALL __svml_cbrtf8      (__m256);
-    extern __m256d V_VECTORCALL __svml_cbrt4       (__m256d);
-    extern __m256  V_VECTORCALL __svml_invsqrtf8   (__m256);
-    extern __m256d V_VECTORCALL __svml_invsqrt4    (__m256d);
-    extern __m256  V_VECTORCALL __svml_logf8       (__m256);
-    extern __m256d V_VECTORCALL __svml_log4        (__m256d);
-    extern __m256  V_VECTORCALL __svml_log1pf8     (__m256);
-    extern __m256d V_VECTORCALL __svml_log1p4      (__m256d);
-    extern __m256  V_VECTORCALL __svml_log2f8      (__m256);
-    extern __m256d V_VECTORCALL __svml_log24       (__m256d);
-    extern __m256  V_VECTORCALL __svml_log10f8     (__m256);
-    extern __m256d V_VECTORCALL __svml_log104      (__m256d);
-    extern __m256  V_VECTORCALL __svml_sinf8       (__m256);
-    extern __m256d V_VECTORCALL __svml_sin4        (__m256d);
-    extern __m256  V_VECTORCALL __svml_cosf8       (__m256);
-    extern __m256d V_VECTORCALL __svml_cos4        (__m256d);
-    extern __m256  V_VECTORCALL __svml_sincosf8    (__m256);  // cos returned in ymm1
-    extern __m256d V_VECTORCALL __svml_sincos4     (__m256d); // cos returned in ymm1
-    extern __m256  V_VECTORCALL __svml_tanf8       (__m256);
-    extern __m256d V_VECTORCALL __svml_tan4        (__m256d);
-    extern __m256  V_VECTORCALL __svml_asinf8      (__m256);
-    extern __m256d V_VECTORCALL __svml_asin4       (__m256d);
-    extern __m256  V_VECTORCALL __svml_acosf8      (__m256);
-    extern __m256d V_VECTORCALL __svml_acos4       (__m256d);
-    extern __m256  V_VECTORCALL __svml_atanf8      (__m256);
-    extern __m256d V_VECTORCALL __svml_atan4       (__m256d);
-    extern __m256  V_VECTORCALL __svml_atan2f8     (__m256, __m256);
-    extern __m256d V_VECTORCALL __svml_atan24      (__m256d, __m256d);
-    extern __m256  V_VECTORCALL __svml_sinhf8      (__m256);
-    extern __m256d V_VECTORCALL __svml_sinh4       (__m256d);
-    extern __m256  V_VECTORCALL __svml_coshf8      (__m256);
-    extern __m256d V_VECTORCALL __svml_cosh4       (__m256d);
-    extern __m256  V_VECTORCALL __svml_tanhf8      (__m256);
-    extern __m256d V_VECTORCALL __svml_tanh4       (__m256d);
-    extern __m256  V_VECTORCALL __svml_asinhf8     (__m256);
-    extern __m256d V_VECTORCALL __svml_asinh4      (__m256d);
-    extern __m256  V_VECTORCALL __svml_acoshf8     (__m256);
-    extern __m256d V_VECTORCALL __svml_acosh4      (__m256d);
-    extern __m256  V_VECTORCALL __svml_atanhf8     (__m256);
-    extern __m256d V_VECTORCALL __svml_atanh4      (__m256d);
-    extern __m256  V_VECTORCALL __svml_erff8       (__m256);
-    extern __m256d V_VECTORCALL __svml_erf4        (__m256d);
-    extern __m256  V_VECTORCALL __svml_erfcf8      (__m256);
-    extern __m256d V_VECTORCALL __svml_erfc4       (__m256d);
-    extern __m256  V_VECTORCALL __svml_erfinvf8    (__m256);
-    extern __m256d V_VECTORCALL __svml_erfinv4     (__m256d);
+    extern __m256  V_VECTORCALL __svml_expf8        (__m256);
+    extern __m256d V_VECTORCALL __svml_exp4         (__m256d);
+    extern __m256  V_VECTORCALL __svml_expm1f8      (__m256);
+    extern __m256d V_VECTORCALL __svml_expm14       (__m256d);
+    extern __m256  V_VECTORCALL __svml_exp2f8       (__m256);
+    extern __m256d V_VECTORCALL __svml_exp24        (__m256d);
+    extern __m256  V_VECTORCALL __svml_exp10f8      (__m256);
+    extern __m256d V_VECTORCALL __svml_exp104       (__m256d);
+    extern __m256  V_VECTORCALL2 __svml_powf8       (__m256,  __m256);
+    extern __m256d V_VECTORCALL2 __svml_pow4        (__m256d, __m256d);
+    extern __m256  V_VECTORCALL __svml_cbrtf8       (__m256);
+    extern __m256d V_VECTORCALL __svml_cbrt4        (__m256d);
+    extern __m256  V_VECTORCALL __svml_invsqrtf8    (__m256);
+    extern __m256d V_VECTORCALL __svml_invsqrt4     (__m256d);
+    extern __m256  V_VECTORCALL __svml_logf8        (__m256);
+    extern __m256d V_VECTORCALL __svml_log4         (__m256d);
+    extern __m256  V_VECTORCALL __svml_log1pf8      (__m256);
+    extern __m256d V_VECTORCALL __svml_log1p4       (__m256d);
+    extern __m256  V_VECTORCALL __svml_log2f8       (__m256);
+    extern __m256d V_VECTORCALL __svml_log24        (__m256d);
+    extern __m256  V_VECTORCALL __svml_log10f8      (__m256);
+    extern __m256d V_VECTORCALL __svml_log104       (__m256d);
+    extern __m256  V_VECTORCALL __svml_sinf8        (__m256);
+    extern __m256d V_VECTORCALL __svml_sin4         (__m256d);
+    extern __m256  V_VECTORCALL __svml_cosf8        (__m256);
+    extern __m256d V_VECTORCALL __svml_cos4         (__m256d);
+    extern __m256  V_VECTORCALL2 __svml_sincosf8    (__m256);  // cos returned in ymm1
+    extern __m256d V_VECTORCALL2 __svml_sincos4     (__m256d); // cos returned in ymm1
+    extern __m256  V_VECTORCALL __svml_tanf8        (__m256);
+    extern __m256d V_VECTORCALL __svml_tan4         (__m256d);
+    extern __m256  V_VECTORCALL __svml_sinpif8      (__m256);
+    extern __m256d V_VECTORCALL __svml_sinpi4       (__m256d);
+    extern __m256  V_VECTORCALL __svml_cospif8      (__m256);
+    extern __m256d V_VECTORCALL __svml_cospi4       (__m256d);
+    extern __m256  V_VECTORCALL __svml_tanpif8      (__m256);
+    extern __m256d V_VECTORCALL __svml_tanpi4       (__m256d);
+    extern __m256  V_VECTORCALL __svml_asinf8       (__m256);
+    extern __m256d V_VECTORCALL __svml_asin4        (__m256d);
+    extern __m256  V_VECTORCALL __svml_acosf8       (__m256);
+    extern __m256d V_VECTORCALL __svml_acos4        (__m256d);
+    extern __m256  V_VECTORCALL __svml_atanf8       (__m256);
+    extern __m256d V_VECTORCALL __svml_atan4        (__m256d);
+    extern __m256  V_VECTORCALL2 __svml_atan2f8     (__m256, __m256);
+    extern __m256d V_VECTORCALL2 __svml_atan24      (__m256d, __m256d);
+    extern __m256  V_VECTORCALL __svml_sinhf8       (__m256);
+    extern __m256d V_VECTORCALL __svml_sinh4        (__m256d);
+    extern __m256  V_VECTORCALL __svml_coshf8       (__m256);
+    extern __m256d V_VECTORCALL __svml_cosh4        (__m256d);
+    extern __m256  V_VECTORCALL __svml_tanhf8       (__m256);
+    extern __m256d V_VECTORCALL __svml_tanh4        (__m256d);
+    extern __m256  V_VECTORCALL __svml_asinhf8      (__m256);
+    extern __m256d V_VECTORCALL __svml_asinh4       (__m256d);
+    extern __m256  V_VECTORCALL __svml_acoshf8      (__m256);
+    extern __m256d V_VECTORCALL __svml_acosh4       (__m256d);
+    extern __m256  V_VECTORCALL __svml_atanhf8      (__m256);
+    extern __m256d V_VECTORCALL __svml_atanh4       (__m256d);
+    extern __m256  V_VECTORCALL __svml_erff8        (__m256);
+    extern __m256d V_VECTORCALL __svml_erf4         (__m256d);
+    extern __m256  V_VECTORCALL __svml_erfcf8       (__m256);
+    extern __m256d V_VECTORCALL __svml_erfc4        (__m256d);
+    extern __m256  V_VECTORCALL __svml_erfinvf8     (__m256);
+    extern __m256d V_VECTORCALL __svml_erfinv4      (__m256d);
     extern __m256  V_VECTORCALL __svml_cdfnorminvf8(__m256);
-    extern __m256d V_VECTORCALL __svml_cdfnorminv4 (__m256d);
-    extern __m256  V_VECTORCALL __svml_cdfnormf8   (__m256);
-    extern __m256d V_VECTORCALL __svml_cdfnorm4    (__m256d);
-    //extern __m256  V_VECTORCALL __svml_cexpf8      (__m256);
-    //extern __m256d V_VECTORCALL __svml_cexp4       (__m256d);
+    extern __m256d V_VECTORCALL __svml_cdfnorminv4  (__m256d);
+    extern __m256  V_VECTORCALL __svml_cdfnormf8    (__m256);
+    extern __m256d V_VECTORCALL __svml_cdfnorm4     (__m256d);
+    //extern __m256  V_VECTORCALL __svml_cexpf8     (__m256);
+    //extern __m256d V_VECTORCALL __svml_cexp4      (__m256d);
 }
 
 
 // exponential and power functions
-static inline Vec8f exp (Vec8f const x) {   // exponential function
+static inline Vec8f exp (Vec8f const x) {      // exponential function
     return  __svml_expf8(x);
 }
-static inline Vec4d exp (Vec4d const x) {   // exponential function
+static inline Vec4d exp (Vec4d const x) {      // exponential function
     return  __svml_exp4(x);
 }
-static inline Vec8f expm1 (Vec8f const x) { // exp(x)-1
+static inline Vec8f expm1 (Vec8f const x) {    // exp(x)-1
     return  __svml_expm1f8(x);
 }
-static inline Vec4d expm1 (Vec4d const x) { // exp(x)-1
+static inline Vec4d expm1 (Vec4d const x) {    // exp(x)-1
     return  __svml_expm14(x);
 }
-static inline Vec8f exp2 (Vec8f const x) {  // pow(2,x)
+static inline Vec8f exp2 (Vec8f const x) {     // pow(2,x)
     return  __svml_exp2f8(x);
 }
-static inline Vec4d exp2 (Vec4d const x) {  // pow(2,x)
+static inline Vec4d exp2 (Vec4d const x) {     // pow(2,x)
     return  __svml_exp24(x);
 }
-static inline Vec8f exp10 (Vec8f const x) { // pow(10,x)
+static inline Vec8f exp10 (Vec8f const x) {    // pow(10,x)
     return  __svml_exp10f8(x);
 }
-static inline Vec4d exp10 (Vec4d const x) { // pow(10,x)
+static inline Vec4d exp10 (Vec4d const x) {    // pow(10,x)
     return  __svml_exp104(x);
 }
-static inline Vec8f pow (Vec8f const a, Vec8f const b) {   // pow(a,b) = a to the power of b
+static inline Vec8f pow (Vec8f const a, Vec8f const b) {  // pow(a,b) = a to the power of b
     return  __svml_powf8(a,b);
 }
-static inline Vec8f pow (Vec8f const a, float const b) {   // pow(a,b) = a to the power of b
+static inline Vec8f pow (Vec8f const a, float const b) {  // pow(a,b)
     return  __svml_powf8(a,Vec8f(b));
 }
-static inline Vec4d pow (Vec4d const a, Vec4d const b) {   // pow(a,b) = a to the power of b
+static inline Vec4d pow (Vec4d const a, Vec4d const b) {  // pow(a,b)
     return  __svml_pow4(a,b);
 }
-static inline Vec4d pow (Vec4d const a, double const b) {  // pow(a,b) = a to the power of b
+static inline Vec4d pow (Vec4d const a, double const b) { // pow(a,b)
     return  __svml_pow4(a,Vec4d(b));
 }
-static inline Vec8f cbrt (Vec8f const x) {  // pow(x,1/3)
+static inline Vec8f cbrt (Vec8f const x) {     // pow(x,1/3)
     return  __svml_cbrtf8(x);
 }
-static inline Vec4d cbrt (Vec4d const x) {  // pow(x,1/3)
+static inline Vec4d cbrt (Vec4d const x) {     // pow(x,1/3)
     return  __svml_cbrt4(x);
 }
 
 // logarithms
-static inline Vec8f log (Vec8f const x) {   // natural logarithm
+static inline Vec8f log (Vec8f const x) {      // natural logarithm
     return  __svml_logf8(x);
 }
-static inline Vec4d log (Vec4d const x) {   // natural logarithm
+static inline Vec4d log (Vec4d const x) {      // natural logarithm
     return  __svml_log4(x);
 }
-static inline Vec8f log1p (Vec8f const x) { // log(1+x). Avoids loss of precision if 1+x is close to 1
+static inline Vec8f log1p (Vec8f const x) {    // log(1+x)
     return  __svml_log1pf8(x);
 }
-static inline Vec4d log1p (Vec4d const x) { // log(1+x). Avoids loss of precision if 1+x is close to 1
+static inline Vec4d log1p (Vec4d const x) {    // log(1+x)
     return  __svml_log1p4(x);
 }
-static inline Vec8f log2 (Vec8f const x) {  // logarithm base 2
+static inline Vec8f log2 (Vec8f const x) {     // logarithm base 2
     return  __svml_log2f8(x);
 }
-static inline Vec4d log2 (Vec4d const x) {  // logarithm base 2
+static inline Vec4d log2 (Vec4d const x) {     // logarithm base 2
     return  __svml_log24(x);
 }
-static inline Vec8f log10 (Vec8f const x) { // logarithm base 10
+static inline Vec8f log10 (Vec8f const x) {    // logarithm base 10
     return  __svml_log10f8(x);
 }
-static inline Vec4d log10 (Vec4d const x) { // logarithm base 10
+static inline Vec4d log10 (Vec4d const x) {    // logarithm base 10
     return  __svml_log104(x);
 }
 
 // trigonometric functions (angles in radians)
-static inline Vec8f sin (Vec8f const x) {   // sine
+static inline Vec8f sin (Vec8f const x) {      // sine
     return  __svml_sinf8(x);
 }
-static inline Vec4d sin (Vec4d const x) {   // sine
+static inline Vec4d sin (Vec4d const x) {      // sine
     return  __svml_sin4(x);
 }
-static inline Vec8f cos (Vec8f const x) {   // cosine
+static inline Vec8f cos (Vec8f const x) {      // cosine
     return  __svml_cosf8(x);
 }
-static inline Vec4d cos (Vec4d const x) {   // cosine
+static inline Vec4d cos (Vec4d const x) {      // cosine
     return  __svml_cos4(x);
 }
 
-#if defined(__unix__) || defined(__INTEL_COMPILER) || !defined(__x86_64__) || !defined(_MSC_VER)
+#ifdef SINCOS_ASM  // sincos can be fixed with inline assembly
 // no inline assembly in 64 bit MS compiler
-static inline Vec8f sincos (Vec8f * pcos, Vec8f const x) {   // sine and cosine. sin(x) returned, cos(x) in pcos
+// sine and cosine. sin(x) returned, cos(x) in pcos
+static inline Vec8f sincos (Vec8f * pcos, Vec8f const x) {
     __m256 r_sin, r_cos;
     r_sin = __svml_sincosf8(x);
-#if defined(__unix__) || defined(__GNUC__)
     __asm__ __volatile__ ( "vmovaps %%ymm1, %0":"=m"(r_cos));
-#else // Windows
-    _asm vmovaps r_cos, ymm1;
-#endif
     *pcos = r_cos;
     return r_sin;
 }
-static inline Vec4d sincos (Vec4d * pcos, Vec4d const x) {   // sine and cosine. sin(x) returned, cos(x) in pcos
+// sine and cosine. sin(x) returned, cos(x) in pcos
+static inline Vec4d sincos (Vec4d * pcos, Vec4d const x) {
     __m256d r_sin, r_cos;
     r_sin = __svml_sincos4(x);
-#if defined(__unix__) || defined(__GNUC__)
     __asm__ __volatile__ ( "vmovaps %%ymm1, %0":"=m"(r_cos));
-#else // Windows
-    _asm vmovapd r_cos, ymm1;
-#endif
     *pcos = r_cos;
     return r_sin;
 }
-#endif // inline assembly available
+#endif // sincos
 
-static inline Vec8f tan (Vec8f const x) {   // tangent
+static inline Vec8f tan (Vec8f const x) {      // tangent
     return  __svml_tanf8(x);
 }
-static inline Vec4d tan (Vec4d const x) {   // tangent
+static inline Vec4d tan (Vec4d const x) {      // tangent
     return  __svml_tan4(x);
 }
 
+static inline Vec8f sinpi (Vec8f const x) {    // sine
+    return  __svml_sinpif8(x);
+}
+static inline Vec4d sinpi (Vec4d const x) {    // sine
+    return  __svml_sinpi4(x);
+}
+static inline Vec8f cospi (Vec8f const x) {    // cosine
+    return  __svml_cospif8(x);
+}
+static inline Vec4d cospi (Vec4d const x) {    // cosine
+    return  __svml_cospi4(x);
+}
+static inline Vec8f tanpi (Vec8f const x) {    // tangent
+    return  __svml_tanpif8(x);
+}
+static inline Vec4d tanpi (Vec4d const x) {    // tangent
+    return  __svml_tanpi4(x);
+}
+
 // inverse trigonometric functions
-static inline Vec8f asin (Vec8f const x) {  // inverse sine
+static inline Vec8f asin (Vec8f const x) {     // inverse sine
     return  __svml_asinf8(x);
 }
-static inline Vec4d asin (Vec4d const x) {  // inverse sine
+static inline Vec4d asin (Vec4d const x) {     // inverse sine
     return  __svml_asin4(x);
 }
-static inline Vec8f acos (Vec8f const x) {  // inverse cosine
+static inline Vec8f acos (Vec8f const x) {     // inverse cosine
     return  __svml_acosf8(x);
 }
-static inline Vec4d acos (Vec4d const x) {  // inverse cosine
+static inline Vec4d acos (Vec4d const x) {     // inverse cosine
     return  __svml_acos4(x);
 }
-static inline Vec8f atan (Vec8f const x) {  // inverse tangent
+static inline Vec8f atan (Vec8f const x) {     // inverse tangent
     return  __svml_atanf8(x);
 }
-static inline Vec4d atan (Vec4d const x) {  // inverse tangent
+static inline Vec4d atan (Vec4d const x) {     // inverse tangent
     return  __svml_atan4(x);
 }
 static inline Vec8f atan2 (Vec8f const a, Vec8f const b) { // inverse tangent of a/b
@@ -1002,285 +1105,303 @@ static inline Vec4d atan2 (Vec4d const a, Vec4d const b) { // inverse tangent of
 }
 
 // hyperbolic functions and inverse hyperbolic functions
-static inline Vec8f sinh (Vec8f const x) {  // hyperbolic sine
+static inline Vec8f sinh (Vec8f const x) {     // hyperbolic sine
     return  __svml_sinhf8(x);
 }
-static inline Vec4d sinh (Vec4d const x) {  // hyperbolic sine
+static inline Vec4d sinh (Vec4d const x) {     // hyperbolic sine
     return  __svml_sinh4(x);
 }
-static inline Vec8f cosh (Vec8f const x) {  // hyperbolic cosine
+static inline Vec8f cosh (Vec8f const x) {     // hyperbolic cosine
     return  __svml_coshf8(x);
 }
-static inline Vec4d cosh (Vec4d const x) {  // hyperbolic cosine
+static inline Vec4d cosh (Vec4d const x) {     // hyperbolic cosine
     return  __svml_cosh4(x);
 }
-static inline Vec8f tanh (Vec8f const x) {  // hyperbolic tangent
+static inline Vec8f tanh (Vec8f const x) {     // hyperbolic tangent
     return  __svml_tanhf8(x);
 }
-static inline Vec4d tanh (Vec4d const x) {  // hyperbolic tangent
+static inline Vec4d tanh (Vec4d const x) {     // hyperbolic tangent
     return  __svml_tanh4(x);
 }
-static inline Vec8f asinh (Vec8f const x) { // inverse hyperbolic sine
+static inline Vec8f asinh (Vec8f const x) {    // inverse hyperbolic sine
     return  __svml_asinhf8(x);
 }
-static inline Vec4d asinh (Vec4d const x) { // inverse hyperbolic sine
+static inline Vec4d asinh (Vec4d const x) {    // inverse hyperbolic sine
     return  __svml_asinh4(x);
 }
-static inline Vec8f acosh (Vec8f const x) { // inverse hyperbolic cosine
+static inline Vec8f acosh (Vec8f const x) {    // inverse hyperbolic cosine
     return  __svml_acoshf8(x);
 }
-static inline Vec4d acosh (Vec4d const x) { // inverse hyperbolic cosine
+static inline Vec4d acosh (Vec4d const x) {    // inverse hyperbolic cosine
     return  __svml_acosh4(x);
 }
-
-static inline Vec8f atanh (Vec8f const x) { // inverse hyperbolic tangent
+static inline Vec8f atanh (Vec8f const x) {    // inverse hyperbolic tangent
     return  __svml_atanhf8(x);
 }
-static inline Vec4d atanh (Vec4d const x) { // inverse hyperbolic tangent
+static inline Vec4d atanh (Vec4d const x) {    // inverse hyperbolic tangent
     return  __svml_atanh4(x);
 }
 
 // error function
-static inline Vec8f erf (Vec8f const x) {   // error function
+static inline Vec8f erf (Vec8f const x) {      // error function
     return  __svml_erff8(x);
 }
-static inline Vec4d erf (Vec4d const x) {   // error function
+static inline Vec4d erf (Vec4d const x) {      // error function
     return  __svml_erf4(x);
 }
-static inline Vec8f erfc (Vec8f const x) {  // error function complement
+static inline Vec8f erfc (Vec8f const x) {     // error function complement
     return  __svml_erfcf8(x);
 }
-static inline Vec4d erfc (Vec4d const x) {  // error function complement
+static inline Vec4d erfc (Vec4d const x) {     // error function complement
     return  __svml_erfc4(x);
 }
-static inline Vec8f erfinv (Vec8f const x) {     // inverse error function
+static inline Vec8f erfinv (Vec8f const x) {   // inverse error function
     return  __svml_erfinvf8(x);
 }
-static inline Vec4d erfinv (Vec4d const x) {     // inverse error function
+static inline Vec4d erfinv (Vec4d const x) {   // inverse error function
     return  __svml_erfinv4(x);
 }
 
-static inline Vec8f cdfnorm (Vec8f const x) {    // cumulative normal distribution function
+static inline Vec8f cdfnorm (Vec8f const x) {  // cumulative normal distribution function
     return  __svml_cdfnormf8(x);
 }
-static inline Vec4d cdfnorm (Vec4d const x) {    // cumulative normal distribution function
+static inline Vec4d cdfnorm (Vec4d const x) {  // cumulative normal distribution function
     return  __svml_cdfnorm4(x);
 }
-static inline Vec8f cdfnorminv (Vec8f const x) { // inverse cumulative normal distribution function
+static inline Vec8f cdfnorminv (Vec8f const x) {  // inverse cumulative normal distribution function
     return  __svml_cdfnorminvf8(x);
 }
-static inline Vec4d cdfnorminv (Vec4d const x) { // inverse cumulative normal distribution function
+static inline Vec4d cdfnorminv (Vec4d const x) {  // inverse cumulative normal distribution function
     return  __svml_cdfnorminv4(x);
 }
 
-#endif   // __INTEL_COMPILER
+#endif   // USE_SVML_INTRINSICS
 
-#else    // VECTORF256_H
+#else    // not VECTORF256_H
 
 /*****************************************************************************
 *
 *      256-bit vector functions emulated with 128-bit vectors
 *
 *****************************************************************************/
+
 // exponential and power functions
-static inline Vec8f exp (Vec8f const x) {        // exponential function
+static inline Vec8f exp (Vec8f const x) {      // exponential function
     return Vec8f(exp(x.get_low()), exp(x.get_high()));
 }
-static inline Vec4d exp (Vec4d const x) {        // exponential function
+static inline Vec4d exp (Vec4d const x) {      // exponential function
     return Vec4d(exp(x.get_low()), exp(x.get_high()));
 }
-static inline Vec8f expm1 (Vec8f const x) {      // exp(x)-1. Avoids loss of precision if x is close to 1
+static inline Vec8f expm1 (Vec8f const x) {    // exp(x)-1
     return Vec8f(expm1(x.get_low()), expm1(x.get_high()));
 }
-static inline Vec4d expm1 (Vec4d const x) {      // exp(x)-1. Avoids loss of precision if x is close to 1
+static inline Vec4d expm1 (Vec4d const x) {    // exp(x)-1
     return Vec4d(expm1(x.get_low()), expm1(x.get_high()));
 }
-static inline Vec8f exp2 (Vec8f const x) {       // pow(2,x)
+static inline Vec8f exp2 (Vec8f const x) {     // pow(2,x)
     return Vec8f(exp2(x.get_low()), exp2(x.get_high()));
 }
-static inline Vec4d exp2 (Vec4d const x) {       // pow(2,x)
+static inline Vec4d exp2 (Vec4d const x) {     // pow(2,x)
     return Vec4d(exp2(x.get_low()), exp2(x.get_high()));
 }
-static inline Vec8f exp10 (Vec8f const x) {      // pow(10,x)
+static inline Vec8f exp10 (Vec8f const x) {    // pow(10,x)
     return Vec8f(exp10(x.get_low()), exp10(x.get_high()));
 }
-static inline Vec4d exp10 (Vec4d const x) {      // pow(10,x)
+static inline Vec4d exp10 (Vec4d const x) {    // pow(10,x)
     return Vec4d(exp10(x.get_low()), exp10(x.get_high()));
 }
-static inline Vec8f pow (Vec8f const a, Vec8f const b) {   // pow(a,b) = a to the power of b
+static inline Vec8f pow (Vec8f const a, Vec8f const b) {  // pow(a,b) = a to the power of b
     return Vec8f(pow(a.get_low(),b.get_low()), pow(a.get_high(),b.get_high()));
 }
-static inline Vec8f pow (Vec8f const a, float const b) {   // pow(a,b) = a to the power of b
+static inline Vec8f pow (Vec8f const a, float const b) {  // pow(a,b)
     return Vec8f(pow(a.get_low(),b), pow(a.get_high(),b));
 }
-static inline Vec4d pow (Vec4d const a, Vec4d const b) {   // pow(a,b) = a to the power of b
+static inline Vec4d pow (Vec4d const a, Vec4d const b) {  // pow(a,b)
     return Vec4d(pow(a.get_low(),b.get_low()), pow(a.get_high(),b.get_high()));
 }
-static inline Vec4d pow (Vec4d const a, double const b) {  // pow(a,b) = a to the power of b
+static inline Vec4d pow (Vec4d const a, double const b) { // pow(a,b)
     return Vec4d(pow(a.get_low(),b), pow(a.get_high(),b));
 }
-static inline Vec8f cbrt (Vec8f const x) {   // pow(x,1/3)
+static inline Vec8f cbrt (Vec8f const x) {     // pow(x,1/3)
     return Vec8f(cbrt(x.get_low()), cbrt(x.get_high()));
 }
-static inline Vec4d cbrt (Vec4d const x) {   // pow(x,1/3)
+static inline Vec4d cbrt (Vec4d const x) {     // pow(x,1/3)
     return Vec4d(cbrt(x.get_low()), cbrt(x.get_high()));
 }
 
 // logarithms
-static inline Vec8f log (Vec8f const x) {   // natural logarithm
+static inline Vec8f log (Vec8f const x) {      // natural logarithm
     return Vec8f(log(x.get_low()), log(x.get_high()));
 }
-static inline Vec4d log (Vec4d const x) {   // natural logarithm
+static inline Vec4d log (Vec4d const x) {      // natural logarithm
     return Vec4d(log(x.get_low()), log(x.get_high()));
 }
-static inline Vec8f log1p (Vec8f const x) { // log(1+x). Avoids loss of precision if 1+x is close to 1
+static inline Vec8f log1p (Vec8f const x) {    // log(1+x). Avoids loss of precision if 1+x is close to 1
     return Vec8f(log1p(x.get_low()), log1p(x.get_high()));
 }
-static inline Vec4d log1p (Vec4d const x) { // log(1+x). Avoids loss of precision if 1+x is close to 1
+static inline Vec4d log1p (Vec4d const x) {    // log(1+x). Avoids loss of precision if 1+x is close to 1
     return Vec4d(log1p(x.get_low()), log1p(x.get_high()));
 }
-static inline Vec8f log2 (Vec8f const x) {  // logarithm base 2
+static inline Vec8f log2 (Vec8f const x) {     // logarithm base 2
     return Vec8f(log2(x.get_low()), log2(x.get_high()));
 }
-static inline Vec4d log2 (Vec4d const x) {  // logarithm base 2
+static inline Vec4d log2 (Vec4d const x) {     // logarithm base 2
     return Vec4d(log2(x.get_low()), log2(x.get_high()));
 }
-static inline Vec8f log10 (Vec8f const x) { // logarithm base 10
+static inline Vec8f log10 (Vec8f const x) {    // logarithm base 10
     return Vec8f(log10(x.get_low()), log10(x.get_high()));
 }
-static inline Vec4d log10 (Vec4d const x) { // logarithm base 10
+static inline Vec4d log10 (Vec4d const x) {    // logarithm base 10
     return Vec4d(log10(x.get_low()), log10(x.get_high()));
 }
 
 // trigonometric functions (angles in radians)
-static inline Vec8f sin (Vec8f const x) {   // sine
+static inline Vec8f sin (Vec8f const x) {      // sine
     return Vec8f(sin(x.get_low()), sin(x.get_high()));
 }
-static inline Vec4d sin (Vec4d const x) {   // sine
+static inline Vec4d sin (Vec4d const x) {      // sine
     return Vec4d(sin(x.get_low()), sin(x.get_high()));
 }
-static inline Vec8f cos (Vec8f const x) {   // cosine
+static inline Vec8f cos (Vec8f const x) {      // cosine
     return Vec8f(cos(x.get_low()), cos(x.get_high()));
 }
-static inline Vec4d cos (Vec4d const x) {   // cosine
+static inline Vec4d cos (Vec4d const x) {      // cosine
     return Vec4d(cos(x.get_low()), cos(x.get_high()));
 }
-
-#if defined(__unix__) || defined(__INTEL_COMPILER) || !defined(__x86_64__) || !defined(_MSC_VER)
-// no inline assembly in 64 bit MS compiler
+#ifdef SINCOS_ASM  // sincos can be fixed with inline assembly
 static inline Vec8f sincos (Vec8f * pcos, Vec8f const x) { // sine and cosine. sin(x) returned, cos(x) in pcos
-    Vec4f r_sin0, r_sin1, r_cos0, r_cos1;
-    r_sin0 = sincos(&r_cos0, x.get_low());
-    r_sin1 = sincos(&r_cos1, x.get_high());
+    Vec4f r_cos0, r_cos1;
+    Vec8f r_sin = Vec8f(sincos(&r_cos0, x.get_low()), sincos(&r_cos1, x.get_high()));
     *pcos = Vec8f(r_cos0, r_cos1);
-    return Vec8f(r_sin0, r_sin1);
+    return r_sin;
 }
+
 static inline Vec4d sincos (Vec4d * pcos, Vec4d const x) { // sine and cosine. sin(x) returned, cos(x) in pcos
-    Vec2d r_sin0, r_sin1, r_cos0, r_cos1;
-    r_sin0 = sincos(&r_cos0, x.get_low());
-    r_sin1 = sincos(&r_cos1, x.get_high());
+    Vec2d r_cos0, r_cos1;
+    Vec4d r_sin = Vec4d(sincos(&r_cos0, x.get_low()), sincos(&r_cos1, x.get_high()));
     *pcos = Vec4d(r_cos0, r_cos1);
-    return Vec4d(r_sin0, r_sin1);
+    return r_sin;
 }
-#endif // inline assembly available
+#endif  // sincos
 
-static inline Vec8f tan (Vec8f const x) {   // tangent
+static inline Vec8f tan (Vec8f const x) {      // tangent
     return Vec8f(tan(x.get_low()), tan(x.get_high()));
 }
-static inline Vec4d tan (Vec4d const x) {   // tangent
+static inline Vec4d tan (Vec4d const x) {      // tangent
     return Vec4d(tan(x.get_low()), tan(x.get_high()));
 }
 
+#ifdef TRIGPI_FUNCTIONS
+static inline Vec8f sinpi (Vec8f const x) {    // sine
+    return Vec8f(sinpi(x.get_low()), sinpi(x.get_high()));
+}
+static inline Vec4d sinpi (Vec4d const x) {    // sine
+    return Vec4d(sinpi(x.get_low()), sinpi(x.get_high()));
+}
+static inline Vec8f cospi (Vec8f const x) {    // cosine
+    return Vec8f(cospi(x.get_low()), cospi(x.get_high()));
+}
+static inline Vec4d cospi (Vec4d const x) {    // cosine
+    return Vec4d(cospi(x.get_low()), cospi(x.get_high()));
+}
+static inline Vec8f tanpi (Vec8f const x) {    // tangent
+    return Vec8f(tanpi(x.get_low()), tanpi(x.get_high()));
+}
+static inline Vec4d tanpi (Vec4d const x) {    // tangent
+    return Vec4d(tanpi(x.get_low()), tanpi(x.get_high()));
+}
+#endif
+
 // inverse trigonometric functions
-static inline Vec8f asin (Vec8f const x) {  // inverse sine
+static inline Vec8f asin (Vec8f const x) {     // inverse sine
     return Vec8f(asin(x.get_low()), asin(x.get_high()));
 }
-static inline Vec4d asin (Vec4d const x) {  // inverse sine
+static inline Vec4d asin (Vec4d const x) {     // inverse sine
     return Vec4d(asin(x.get_low()), asin(x.get_high()));
 }
-static inline Vec8f acos (Vec8f const x) {  // inverse cosine
+static inline Vec8f acos (Vec8f const x) {     // inverse cosine
     return Vec8f(acos(x.get_low()), acos(x.get_high()));
 }
-static inline Vec4d acos (Vec4d const x) {  // inverse cosine
+static inline Vec4d acos (Vec4d const x) {     // inverse cosine
     return Vec4d(acos(x.get_low()), acos(x.get_high()));
 }
-static inline Vec8f atan (Vec8f const x) {  // inverse tangent
+static inline Vec8f atan (Vec8f const x) {     // inverse tangent
     return Vec8f(atan(x.get_low()), atan(x.get_high()));
 }
-static inline Vec4d atan (Vec4d const x) {  // inverse tangent
+static inline Vec4d atan (Vec4d const x) {     // inverse tangent
     return Vec4d(atan(x.get_low()), atan(x.get_high()));
 }
-static inline Vec8f atan2 (Vec8f const a, Vec8f const b) { // inverse tangent of a/b
+static inline Vec8f atan2 (Vec8f const a, Vec8f const b) {  // inverse tangent of a/b
     return Vec8f(atan2(a.get_low(),b.get_low()), atan2(a.get_high(),b.get_high()));
 }
-static inline Vec4d atan2 (Vec4d const a, Vec4d const b) { // inverse tangent of a/b
+static inline Vec4d atan2 (Vec4d const a, Vec4d const b) {  // inverse tangent of a/b
     return Vec4d(atan2(a.get_low(),b.get_low()), atan2(a.get_high(),b.get_high()));
 }
 
 // hyperbolic functions
-static inline Vec8f sinh (Vec8f const x) {  // hyperbolic sine
+static inline Vec8f sinh (Vec8f const x) {     // hyperbolic sine
     return Vec8f(sinh(x.get_low()), sinh(x.get_high()));
 }
-static inline Vec4d sinh (Vec4d const x) {  // hyperbolic sine
+static inline Vec4d sinh (Vec4d const x) {     // hyperbolic sine
     return Vec4d(sinh(x.get_low()), sinh(x.get_high()));
 }
-static inline Vec8f cosh (Vec8f const x) {  // hyperbolic cosine
+static inline Vec8f cosh (Vec8f const x) {     // hyperbolic cosine
     return Vec8f(cosh(x.get_low()), cosh(x.get_high()));
 }
-static inline Vec4d cosh (Vec4d const x) {  // hyperbolic cosine
+static inline Vec4d cosh (Vec4d const x) {     // hyperbolic cosine
     return Vec4d(cosh(x.get_low()), cosh(x.get_high()));
 }
-static inline Vec8f tanh (Vec8f const x) {  // hyperbolic tangent
+static inline Vec8f tanh (Vec8f const x) {     // hyperbolic tangent
     return Vec8f(tanh(x.get_low()), tanh(x.get_high()));
 }
-static inline Vec4d tanh (Vec4d const x) {  // hyperbolic tangent
+static inline Vec4d tanh (Vec4d const x) {     // hyperbolic tangent
     return Vec4d(tanh(x.get_low()), tanh(x.get_high()));
 }
 
 // inverse hyperbolic functions
-static inline Vec8f asinh (Vec8f const x) { // inverse hyperbolic sine
+static inline Vec8f asinh (Vec8f const x) {    // inverse hyperbolic sine
     return Vec8f(asinh(x.get_low()), asinh(x.get_high()));
 }
-static inline Vec4d asinh (Vec4d const x) { // inverse hyperbolic sine
+static inline Vec4d asinh (Vec4d const x) {    // inverse hyperbolic sine
     return Vec4d(asinh(x.get_low()), asinh(x.get_high()));
 }
-static inline Vec8f acosh (Vec8f const x) { // inverse hyperbolic cosine
+static inline Vec8f acosh (Vec8f const x) {    // inverse hyperbolic cosine
     return Vec8f(acosh(x.get_low()), acosh(x.get_high()));
 }
-static inline Vec4d acosh (Vec4d const x) { // inverse hyperbolic cosine
+static inline Vec4d acosh (Vec4d const x) {    // inverse hyperbolic cosine
     return Vec4d(acosh(x.get_low()), acosh(x.get_high()));
 }
-static inline Vec8f atanh (Vec8f const x) { // inverse hyperbolic tangent
+static inline Vec8f atanh (Vec8f const x) {    // inverse hyperbolic tangent
     return Vec8f(atanh(x.get_low()), atanh(x.get_high()));
 }
-static inline Vec4d atanh (Vec4d const x) { // inverse hyperbolic tangent
+static inline Vec4d atanh (Vec4d const x) {    // inverse hyperbolic tangent
     return Vec4d(atanh(x.get_low()), atanh(x.get_high()));
 }
 
 // error function
-static inline Vec8f erf (Vec8f const x) {   // error function
+static inline Vec8f erf (Vec8f const x) {      // error function
     return Vec8f(erf(x.get_low()), erf(x.get_high()));
 }
-static inline Vec4d erf (Vec4d const x) {   // error function
+static inline Vec4d erf (Vec4d const x) {      // error function
     return Vec4d(erf(x.get_low()), erf(x.get_high()));
 }
-static inline Vec8f erfc (Vec8f const x) {  // error function complement
+static inline Vec8f erfc (Vec8f const x) {     // error function complement
     return Vec8f(erfc(x.get_low()), erfc(x.get_high()));
 }
-static inline Vec4d erfc (Vec4d const x) {  // error function complement
+static inline Vec4d erfc (Vec4d const x) {     // error function complement
     return Vec4d(erfc(x.get_low()), erfc(x.get_high()));
 }
-static inline Vec8f erfinv (Vec8f const x) {     // inverse error function
+static inline Vec8f erfinv (Vec8f const x) {   // inverse error function
     return Vec8f(erfinv(x.get_low()), erfinv(x.get_high()));
 }
-static inline Vec4d erfinv (Vec4d const x) {     // inverse error function
+static inline Vec4d erfinv (Vec4d const x) {   // inverse error function
     return Vec4d(erfinv(x.get_low()), erfinv(x.get_high()));
 }
 
-static inline Vec8f cdfnorm (Vec8f const x) {    // cumulative normal distribution function
+static inline Vec8f cdfnorm (Vec8f const x) {  // cumulative normal distribution function
     return Vec8f(cdfnorm(x.get_low()), cdfnorm(x.get_high()));
 }
-static inline Vec4d cdfnorm (Vec4d const x) {    // cumulative normal distribution function
+static inline Vec4d cdfnorm (Vec4d const x) {  // cumulative normal distribution function
     return Vec4d(cdfnorm(x.get_low()), cdfnorm(x.get_high()));
 }
 static inline Vec8f cdfnorminv (Vec8f const x) { // inverse cumulative normal distribution function
@@ -1292,16 +1413,17 @@ static inline Vec4d cdfnorminv (Vec4d const x) { // inverse cumulative normal di
 
 #endif   // VECTORF256_H
 
-#endif   // MAX_VECTOR_SIZE >= 256
+#endif  // 256 bits
+
 
 #if defined (MAX_VECTOR_SIZE) && MAX_VECTOR_SIZE >= 512    // 512 bit vectors
 
 #if defined (VECTORF512_H)  // 512-bit vector registers supported
 
-#ifdef __INTEL_COMPILER
+#ifdef USE_SVML_INTRINSICS
 /*****************************************************************************
 *
-*      512-bit vector functions using Intel compiler
+*      512-bit vector functions using Intel compiler intrinsic functions
 *
 *****************************************************************************/
 
@@ -1312,10 +1434,10 @@ static inline Vec16f exp(Vec16f const x) {       // exponential function
 static inline Vec8d exp(Vec8d const x) {         // exponential function
     return _mm512_exp_pd(x);
 }
-static inline Vec16f expm1(Vec16f const x) {     // exp(x)-1. Avoids loss of precision if x is close to 1
+static inline Vec16f expm1(Vec16f const x) {     // exp(x)-1
     return _mm512_expm1_ps(x);
 }
-static inline Vec8d expm1(Vec8d const x) {       // exp(x)-1. Avoids loss of precision if x is close to 1
+static inline Vec8d expm1(Vec8d const x) {       // exp(x)-1
     return _mm512_expm1_pd(x);
 }
 static inline Vec16f exp2(Vec16f const x) {      // pow(2,x)
@@ -1333,13 +1455,13 @@ static inline Vec8d exp10(Vec8d const x) {       // pow(10,x)
 static inline Vec16f pow(Vec16f const a, Vec16f const b) { // pow(a,b) = a to the power of b
     return _mm512_pow_ps(a, b);
 }
-static inline Vec16f pow(Vec16f const a, float const b) {  // pow(a,b) = a to the power of b
+static inline Vec16f pow(Vec16f const a, float const b) {  // pow(a,b)
     return _mm512_pow_ps(a, Vec16f(b));
 }
-static inline Vec8d pow(Vec8d const a, Vec8d const b) {    // pow(a,b) = a to the power of b
+static inline Vec8d pow(Vec8d const a, Vec8d const b) {    // pow(a,b)
     return _mm512_pow_pd(a, b);
 }
-static inline Vec8d pow(Vec8d const a, double const b) {   // pow(a,b) = a to the power of b
+static inline Vec8d pow(Vec8d const a, double const b) {   // pow(a,b)
     return _mm512_pow_pd(a, Vec8d(b));
 }
 static inline Vec16f cbrt(Vec16f const x) {      // pow(x,1/3)
@@ -1355,10 +1477,10 @@ static inline Vec16f log(Vec16f const x) {       // natural logarithm
 static inline Vec8d log(Vec8d const x) {         // natural logarithm
     return _mm512_log_pd(x);
 }
-static inline Vec16f log1p(Vec16f const x) {     // log(1+x). Avoids loss of precision if 1+x is close to 1
+static inline Vec16f log1p(Vec16f const x) {     // log(1+x)
     return _mm512_log1p_ps(x);
 }
-static inline Vec8d log1p(Vec8d const x) {       // log(1+x). Avoids loss of precision if 1+x is close to 1
+static inline Vec8d log1p(Vec8d const x) {       // log(1+x)
     return _mm512_log1p_pd(x);
 }
 static inline Vec16f log2(Vec16f const x) {      // logarithm base 2
@@ -1406,6 +1528,34 @@ static inline Vec8d tan(Vec8d const x) {         // tangent
     return _mm512_tan_pd(x);
 }
 
+#ifdef TRIGPI_FUNCTIONS
+
+static inline Vec16f sinpi(Vec16f const x) {     // sine
+    return _mm512_sinpi_ps(x);
+}
+static inline Vec8d sinpi(Vec8d const x) {       // sine
+    return _mm512_sinpi_pd(x);
+}
+static inline Vec16f cospi(Vec16f const x) {     // cosine
+    return _mm512_cospi_ps(x);
+}
+static inline Vec8d cospi(Vec8d const x) {       // cosine
+    return _mm512_cospi_pd(x);
+}
+static inline Vec16f tanpi(Vec16f const x) {     // tangent
+    return _mm512_tanpi_ps(x);
+}
+
+static inline Vec8d tanpi(Vec8d const x) {       // tangent
+#ifdef __INTEL_COMPILER
+    // see https://community.intel.com/t5/Intel-C-Compiler/mm512-tanpi-pd-wrong-declaration/m-p/1404627
+    return _mm512_castps_pd(_mm512_tanpi_pd(_mm512_castpd_ps(x)));
+#else
+    return _mm512_tanpi_pd(x);
+#endif
+}
+#endif  // TRIGPI_FUNCTIONS
+
 // inverse trigonometric functions
 static inline Vec16f asin(Vec16f const x) {      // inverse sine
     return _mm512_asin_ps(x);
@@ -1505,77 +1655,83 @@ static inline Vec8d cdfnorminv(Vec8d const x) {  // inverse cumulative normal di
     return _mm512_cdfnorminv_pd(x);
 }
 
-#else    // __INTEL_COMPILER
+#else    // USE_SVML_INTRINSICS
 /*****************************************************************************
 *
 *      512-bit vector functions using other compiler than Intel
 *
 *****************************************************************************/
 
-// External function prototypes, 512-bit vectors
+// External function prototypes for SVML library, 512-bit vectors
 extern "C" {
     extern __m512  V_VECTORCALL __svml_expf16       (__m512);
-    extern __m512d V_VECTORCALL __svml_exp8        (__m512d);
+    extern __m512d V_VECTORCALL __svml_exp8         (__m512d);
     extern __m512  V_VECTORCALL __svml_expm1f16     (__m512);
-    extern __m512d V_VECTORCALL __svml_expm18      (__m512d);
+    extern __m512d V_VECTORCALL __svml_expm18       (__m512d);
     extern __m512  V_VECTORCALL __svml_exp2f16      (__m512);
-    extern __m512d V_VECTORCALL __svml_exp28       (__m512d);
+    extern __m512d V_VECTORCALL __svml_exp28        (__m512d);
     extern __m512  V_VECTORCALL __svml_exp10f16     (__m512);
-    extern __m512d V_VECTORCALL __svml_exp108      (__m512d);
-    extern __m512  V_VECTORCALL __svml_powf16       (__m512,  __m512);
-    extern __m512d V_VECTORCALL __svml_pow8        (__m512d, __m512d);
+    extern __m512d V_VECTORCALL __svml_exp108       (__m512d);
+    extern __m512  V_VECTORCALL2 __svml_powf16      (__m512,  __m512);
+    extern __m512d V_VECTORCALL2 __svml_pow8        (__m512d, __m512d);
     extern __m512  V_VECTORCALL __svml_cbrtf16      (__m512);
-    extern __m512d V_VECTORCALL __svml_cbrt8       (__m512d);
+    extern __m512d V_VECTORCALL __svml_cbrt8        (__m512d);
     extern __m512  V_VECTORCALL __svml_invsqrtf16   (__m512);
-    extern __m512d V_VECTORCALL __svml_invsqrt8    (__m512d);
+    extern __m512d V_VECTORCALL __svml_invsqrt8     (__m512d);
     extern __m512  V_VECTORCALL __svml_logf16       (__m512);
-    extern __m512d V_VECTORCALL __svml_log8        (__m512d);
+    extern __m512d V_VECTORCALL __svml_log8         (__m512d);
     extern __m512  V_VECTORCALL __svml_log1pf16     (__m512);
-    extern __m512d V_VECTORCALL __svml_log1p8      (__m512d);
+    extern __m512d V_VECTORCALL __svml_log1p8       (__m512d);
     extern __m512  V_VECTORCALL __svml_log2f16      (__m512);
-    extern __m512d V_VECTORCALL __svml_log28       (__m512d);
+    extern __m512d V_VECTORCALL __svml_log28        (__m512d);
     extern __m512  V_VECTORCALL __svml_log10f16     (__m512);
-    extern __m512d V_VECTORCALL __svml_log108      (__m512d);
+    extern __m512d V_VECTORCALL __svml_log108       (__m512d);
     extern __m512  V_VECTORCALL __svml_sinf16       (__m512);
-    extern __m512d V_VECTORCALL __svml_sin8        (__m512d);
+    extern __m512d V_VECTORCALL __svml_sin8         (__m512d);
     extern __m512  V_VECTORCALL __svml_cosf16       (__m512);
-    extern __m512d V_VECTORCALL __svml_cos8        (__m512d);
-    extern __m512  V_VECTORCALL __svml_sincosf16    (__m512); // cos returned in ymm1
-    extern __m512d V_VECTORCALL __svml_sincos8     (__m512d); // cos returned in ymm1
+    extern __m512d V_VECTORCALL __svml_cos8         (__m512d);
+    extern __m512  V_VECTORCALL2 __svml_sincosf16   (__m512);  // cos returned in ymm1
+    extern __m512d V_VECTORCALL2 __svml_sincos8     (__m512d); // cos returned in ymm1
     extern __m512  V_VECTORCALL __svml_tanf16       (__m512);
-    extern __m512d V_VECTORCALL __svml_tan8        (__m512d);
+    extern __m512d V_VECTORCALL __svml_tan8         (__m512d);
+    extern __m512  V_VECTORCALL __svml_sinpif16     (__m512);
+    extern __m512d V_VECTORCALL __svml_sinpi8       (__m512d);
+    extern __m512  V_VECTORCALL __svml_cospif16     (__m512);
+    extern __m512d V_VECTORCALL __svml_cospi8       (__m512d);
+    extern __m512  V_VECTORCALL __svml_tanpif16     (__m512);
+    extern __m512d V_VECTORCALL __svml_tanpi8       (__m512d);
     extern __m512  V_VECTORCALL __svml_asinf16      (__m512);
-    extern __m512d V_VECTORCALL __svml_asin8       (__m512d);
+    extern __m512d V_VECTORCALL __svml_asin8        (__m512d);
     extern __m512  V_VECTORCALL __svml_acosf16      (__m512);
-    extern __m512d V_VECTORCALL __svml_acos8       (__m512d);
+    extern __m512d V_VECTORCALL __svml_acos8        (__m512d);
     extern __m512  V_VECTORCALL __svml_atanf16      (__m512);
-    extern __m512d V_VECTORCALL __svml_atan8       (__m512d);
-    extern __m512  V_VECTORCALL __svml_atan2f16     (__m512, __m512);
-    extern __m512d V_VECTORCALL __svml_atan28      (__m512d, __m512d);
+    extern __m512d V_VECTORCALL __svml_atan8        (__m512d);
+    extern __m512  V_VECTORCALL2 __svml_atan2f16    (__m512, __m512);
+    extern __m512d V_VECTORCALL2 __svml_atan28      (__m512d, __m512d);
     extern __m512  V_VECTORCALL __svml_sinhf16      (__m512);
-    extern __m512d V_VECTORCALL __svml_sinh8       (__m512d);
+    extern __m512d V_VECTORCALL __svml_sinh8        (__m512d);
     extern __m512  V_VECTORCALL __svml_coshf16      (__m512);
-    extern __m512d V_VECTORCALL __svml_cosh8       (__m512d);
+    extern __m512d V_VECTORCALL __svml_cosh8        (__m512d);
     extern __m512  V_VECTORCALL __svml_tanhf16      (__m512);
-    extern __m512d V_VECTORCALL __svml_tanh8       (__m512d);
+    extern __m512d V_VECTORCALL __svml_tanh8        (__m512d);
     extern __m512  V_VECTORCALL __svml_asinhf16     (__m512);
-    extern __m512d V_VECTORCALL __svml_asinh8      (__m512d);
+    extern __m512d V_VECTORCALL __svml_asinh8       (__m512d);
     extern __m512  V_VECTORCALL __svml_acoshf16     (__m512);
-    extern __m512d V_VECTORCALL __svml_acosh8      (__m512d);
+    extern __m512d V_VECTORCALL __svml_acosh8       (__m512d);
     extern __m512  V_VECTORCALL __svml_atanhf16     (__m512);
-    extern __m512d V_VECTORCALL __svml_atanh8      (__m512d);
+    extern __m512d V_VECTORCALL __svml_atanh8       (__m512d);
     extern __m512  V_VECTORCALL __svml_erff16       (__m512);
-    extern __m512d V_VECTORCALL __svml_erf8        (__m512d);
+    extern __m512d V_VECTORCALL __svml_erf8         (__m512d);
     extern __m512  V_VECTORCALL __svml_erfcf16      (__m512);
-    extern __m512d V_VECTORCALL __svml_erfc8       (__m512d);
+    extern __m512d V_VECTORCALL __svml_erfc8        (__m512d);
     extern __m512  V_VECTORCALL __svml_erfinvf16    (__m512);
-    extern __m512d V_VECTORCALL __svml_erfinv8     (__m512d);
+    extern __m512d V_VECTORCALL __svml_erfinv8      (__m512d);
     extern __m512  V_VECTORCALL __svml_cdfnorminvf16(__m512);
-    extern __m512d V_VECTORCALL __svml_cdfnorminv8 (__m512d);
+    extern __m512d V_VECTORCALL __svml_cdfnorminv8  (__m512d);
     extern __m512  V_VECTORCALL __svml_cdfnormf16   (__m512);
-    extern __m512d V_VECTORCALL __svml_cdfnorm8    (__m512d);
+    extern __m512d V_VECTORCALL __svml_cdfnorm8     (__m512d);
     //extern __m512  V_VECTORCALL __svml_cexpf16    (__m512);
-    //extern __m512d V_VECTORCALL __svml_cexp8     (__m512d);
+    //extern __m512d V_VECTORCALL __svml_cexp8      (__m512d);
 }
 
 
@@ -1607,13 +1763,13 @@ static inline Vec8d exp10 (Vec8d const x) {      // pow(10,x)
 static inline Vec16f pow (Vec16f const a, Vec16f const b) {  // pow(a,b) = a to the power of b
     return  __svml_powf16(a,b);
 }
-static inline Vec16f pow (Vec16f const a, float const b) {   // pow(a,b) = a to the power of b
+static inline Vec16f pow (Vec16f const a, float const b) {   // pow(a,b)
     return  __svml_powf16(a,Vec16f(b));
 }
-static inline Vec8d pow (Vec8d const a, Vec8d const b) {     // pow(a,b) = a to the power of b
+static inline Vec8d pow (Vec8d const a, Vec8d const b) {     // pow(a,b)
     return  __svml_pow8(a,b);
 }
-static inline Vec8d pow (Vec8d const a, double const b) {    // pow(a,b) = a to the power of b
+static inline Vec8d pow (Vec8d const a, double const b) {    // pow(a,b)
     return  __svml_pow8(a,Vec8d(b));
 }
 static inline Vec16f cbrt (Vec16f const x) {     // pow(x,1/3)
@@ -1630,10 +1786,10 @@ static inline Vec16f log (Vec16f const x) {      // natural logarithm
 static inline Vec8d log (Vec8d const x) {        // natural logarithm
     return  __svml_log8(x);
 }
-static inline Vec16f log1p (Vec16f const x) {    // log(1+x). Avoids loss of precision if 1+x is close to 1
+static inline Vec16f log1p (Vec16f const x) {    // log(1+x)
     return  __svml_log1pf16(x);
 }
-static inline Vec8d log1p (Vec8d const x) {      // log(1+x). Avoids loss of precision if 1+x is close to 1
+static inline Vec8d log1p (Vec8d const x) {      // log(1+x)
     return  __svml_log1p8(x);
 }
 static inline Vec16f log2 (Vec16f const x) {     // logarithm base 2
@@ -1663,17 +1819,13 @@ static inline Vec8d cos (Vec8d const x) {        // cosine
     return  __svml_cos8(x);
 }
 
-#if defined(__unix__) || defined(__INTEL_COMPILER) //|| !defined(__x86_64__) || !defined(_MSC_VER)
+#ifdef SINCOS_ASM  // sincos can be fixed with inline assembly
 // no inline assembly in 64 bit MS compiler
 // sine and cosine. sin(x) returned, cos(x) in pcos
 static inline Vec16f sincos (Vec16f * pcos, Vec16f const x) {
     __m512 r_sin, r_cos;
     r_sin = __svml_sincosf16(x);
-#if defined(__unix__) || defined(__GNUC__)
     __asm__ __volatile__ ( "vmovaps %%zmm1, %0":"=m"(r_cos));
-#else // Windows
-    // _asm vmovaps r_cos, zmm1; // does not work in VS 2019
-#endif
     *pcos = r_cos;
     return r_sin;
 }
@@ -1681,15 +1833,11 @@ static inline Vec16f sincos (Vec16f * pcos, Vec16f const x) {
 static inline Vec8d sincos (Vec8d * pcos, Vec8d const x) {
     __m512d r_sin, r_cos;
     r_sin = __svml_sincos8(x);
-#if defined(__unix__) || defined(__GNUC__)
     __asm__ __volatile__ ( "vmovaps %%zmm1, %0":"=m"(r_cos));
-#else // Windows
-    // _asm vmovapd r_cos, zmm1;  // does not work in VS 2019
-#endif
     *pcos = r_cos;
     return r_sin;
 }
-#endif // inline assembly available
+#endif // sincos
 
 static inline Vec16f tan (Vec16f const x) {      // tangent
     return  __svml_tanf16(x);
@@ -1698,6 +1846,25 @@ static inline Vec8d tan (Vec8d const x) {        // tangent
     return  __svml_tan8(x);
 }
 
+static inline Vec16f sinpi (Vec16f const x) {    // sine
+    return  __svml_sinpif16(x);
+}
+static inline Vec8d sinpi (Vec8d const x) {      // sine
+    return  __svml_sinpi8(x);
+}
+static inline Vec16f cospi (Vec16f const x) {    // cosine
+    return  __svml_cospif16(x);
+}
+static inline Vec8d cospi (Vec8d const x) {      // cosine
+    return  __svml_cospi8(x);
+}
+static inline Vec16f tanpi (Vec16f const x) {    // tangent
+    return  __svml_tanpif16(x);
+}
+static inline Vec8d tanpi (Vec8d const x) {      // tangent
+    return  __svml_tanpi8(x);
+}
+
 // inverse trigonometric functions
 static inline Vec16f asin (Vec16f const x) {     // inverse sine
     return  __svml_asinf16(x);
@@ -1795,9 +1962,10 @@ static inline Vec8d cdfnorminv (Vec8d const x) {    // inverse cumulative normal
     return  __svml_cdfnorminv8(x);
 }
 
-#endif   // __INTEL_COMPILER
+#endif   // USE_SVML_INTRINSICS
 
 #else    // VECTORF512_H
+
 /*****************************************************************************
 *
 *      512-bit vector functions emulated with 256-bit vectors
@@ -1811,10 +1979,10 @@ static inline Vec16f exp (Vec16f const x) {      // exponential function
 static inline Vec8d exp (Vec8d const x) {        // exponential function
     return Vec8d(exp(x.get_low()), exp(x.get_high()));
 }
-static inline Vec16f expm1 (Vec16f const x) {    // exp(x)-1. Avoids loss of precision if x is close to 1
+static inline Vec16f expm1 (Vec16f const x) {    // exp(x)-1
     return Vec16f(expm1(x.get_low()), expm1(x.get_high()));
 }
-static inline Vec8d expm1 (Vec8d const x) {      // exp(x)-1. Avoids loss of precision if x is close to 1
+static inline Vec8d expm1 (Vec8d const x) {      // exp(x)-1
     return Vec8d(expm1(x.get_low()), expm1(x.get_high()));
 }
 static inline Vec16f exp2 (Vec16f const x) {     // pow(2,x)
@@ -1832,13 +2000,13 @@ static inline Vec8d exp10 (Vec8d const x) {      // pow(10,x)
 static inline Vec16f pow (Vec16f const a, Vec16f const b) {  // pow(a,b) = a to the power of b
     return Vec16f(pow(a.get_low(),b.get_low()), pow(a.get_high(),b.get_high()));
 }
-static inline Vec16f pow (Vec16f const a, float const b) {   // pow(a,b) = a to the power of b
+static inline Vec16f pow (Vec16f const a, float const b) {   // pow(a,b)
     return Vec16f(pow(a.get_low(),b), pow(a.get_high(),b));
 }
-static inline Vec8d pow (Vec8d const a, Vec8d const b) {     // pow(a,b) = a to the power of b
+static inline Vec8d pow (Vec8d const a, Vec8d const b) {     // pow(a,b)
     return Vec8d(pow(a.get_low(),b.get_low()), pow(a.get_high(),b.get_high()));
 }
-static inline Vec8d pow (Vec8d const a, double const b) {    // pow(a,b) = a to the power of b
+static inline Vec8d pow (Vec8d const a, double const b) {    // pow(a,b)
     return Vec8d(pow(a.get_low(),b), pow(a.get_high(),b));
 }
 static inline Vec16f cbrt (Vec16f const x) {     // pow(x,1/3)
@@ -1855,10 +2023,10 @@ static inline Vec16f log (Vec16f const x) {      // natural logarithm
 static inline Vec8d log (Vec8d const x) {        // natural logarithm
     return Vec8d(log(x.get_low()), log(x.get_high()));
 }
-static inline Vec16f log1p (Vec16f const x) {    // log(1+x). Avoids loss of precision if 1+x is close to 1
+static inline Vec16f log1p (Vec16f const x) {    // log(1+x)
     return Vec16f(log1p(x.get_low()), log1p(x.get_high()));
 }
-static inline Vec8d log1p (Vec8d const x) {      // log(1+x). Avoids loss of precision if 1+x is close to 1
+static inline Vec8d log1p (Vec8d const x) {      // log(1+x)
     return Vec8d(log1p(x.get_low()), log1p(x.get_high()));
 }
 static inline Vec16f log2 (Vec16f const x) {     // logarithm base 2
@@ -1887,25 +2055,21 @@ static inline Vec16f cos (Vec16f const x) {      // cosine
 static inline Vec8d cos (Vec8d const x) {        // cosine
     return Vec8d(cos(x.get_low()), cos(x.get_high()));
 }
-
-#if defined(__unix__) || defined(__INTEL_COMPILER) || !defined(__x86_64__) || !defined(_MSC_VER)
-// no inline assembly in 64 bit MS compiler
+#ifdef SINCOS_ASM  // sincos can be fixed with inline assembly
 static inline Vec16f sincos (Vec16f * pcos, Vec16f const x) {  // sine and cosine. sin(x) returned, cos(x) in pcos
-    Vec8f r_sin0, r_sin1, r_cos0, r_cos1;
-    r_sin0 = sincos(&r_cos0, x.get_low());
-    r_sin1 = sincos(&r_cos1, x.get_high());
+    Vec8f r_cos0, r_cos1;
+    Vec16f r_sin = Vec16f(sincos(&r_cos0, x.get_low()), sincos(&r_cos1, x.get_high()));
     *pcos = Vec16f(r_cos0, r_cos1);
-    return Vec16f(r_sin0, r_sin1);
+    return r_sin;
 }
+
 static inline Vec8d sincos (Vec8d * pcos, Vec8d const x) {     // sine and cosine. sin(x) returned, cos(x) in pcos
-    Vec4d r_sin0, r_sin1, r_cos0, r_cos1;
-    r_sin0 = sincos(&r_cos0, x.get_low());
-    r_sin1 = sincos(&r_cos1, x.get_high());
+    Vec4d r_cos0, r_cos1;
+    Vec8d r_sin = Vec8d(sincos(&r_cos0, x.get_low()), sincos(&r_cos1, x.get_high()));
     *pcos = Vec8d(r_cos0, r_cos1);
-    return Vec8d(r_sin0, r_sin1);
+    return r_sin;
 }
-#endif // inline assembly available
-
+#endif  // sincos
 
 static inline Vec16f tan (Vec16f const x) {      // tangent
     return Vec16f(tan(x.get_low()), tan(x.get_high()));
@@ -1914,6 +2078,27 @@ static inline Vec8d tan (Vec8d const x) {        // tangent
     return Vec8d(tan(x.get_low()), tan(x.get_high()));
 }
 
+#ifdef TRIGPI_FUNCTIONS
+static inline Vec16f sinpi (Vec16f const x) {    // sine
+    return Vec16f(sinpi(x.get_low()), sinpi(x.get_high()));
+}
+static inline Vec8d sinpi (Vec8d const x) {      // sine
+    return Vec8d(sinpi(x.get_low()), sinpi(x.get_high()));
+}
+static inline Vec16f cospi (Vec16f const x) {    // cosine
+    return Vec16f(cospi(x.get_low()), cospi(x.get_high()));
+}
+static inline Vec8d cospi (Vec8d const x) {      // cosine
+    return Vec8d(cospi(x.get_low()), cospi(x.get_high()));
+}
+static inline Vec16f tanpi (Vec16f const x) {    // tangent
+    return Vec16f(tanpi(x.get_low()), tanpi(x.get_high()));
+}
+static inline Vec8d tanpi (Vec8d const x) {      // tangent
+    return Vec8d(tanpi(x.get_low()), tanpi(x.get_high()));
+}
+#endif
+
 // inverse trigonometric functions
 static inline Vec16f asin (Vec16f const x) {     // inverse sine
     return Vec16f(asin(x.get_low()), asin(x.get_high()));
@@ -2006,10 +2191,10 @@ static inline Vec16f cdfnorm (Vec16f const x) {  // cumulative normal distributi
 static inline Vec8d cdfnorm (Vec8d const x) {    // cumulative normal distribution function
     return Vec8d(cdfnorm(x.get_low()), cdfnorm(x.get_high()));
 }
-static inline Vec16f cdfnorminv (Vec16f const x) { // inverse cumulative normal distribution function
+static inline Vec16f cdfnorminv (Vec16f const x) {// inverse cumulative normal distribution function
     return Vec16f(cdfnorminv(x.get_low()), cdfnorminv(x.get_high()));
 }
-static inline Vec8d cdfnorminv (Vec8d const x) {   // inverse cumulative normal distribution function
+static inline Vec8d cdfnorminv (Vec8d const x) {  // inverse cumulative normal distribution function
     return Vec8d(cdfnorminv(x.get_low()), cdfnorminv(x.get_high()));
 }
 
diff --git a/LGhost/VCL2/vectormath_trig.h b/LGhost/VCL2/vectormath_trig.h
index 7b33886..72d5c57 100644
--- a/LGhost/VCL2/vectormath_trig.h
+++ b/LGhost/VCL2/vectormath_trig.h
@@ -1,8 +1,8 @@
 /****************************  vectormath_trig.h   ******************************
 * Author:        Agner Fog
 * Date created:  2014-04-18
-* Last modified: 2020-06-08
-* Version:       2.00.03
+* Last modified: 2022-07-26
+* Version:       2.02.00
 * Project:       vector class library
 * Description:
 * Header file containing inline version of trigonometric functions
@@ -10,7 +10,7 @@
 * sin, cos, sincos, tan
 * asin, acos, atan, atan2
 *
-* Theory, methods and inspiration based partially on these sources:
+* Theory, methods, and inspiration based partially on these sources:
 * > Moshier, Stephen Lloyd Baluk: Methods and programs for mathematical functions.
 *   Ellis Horwood, 1989.
 * > VDT library developed on CERN by Danilo Piparo, Thomas Hauth and
@@ -20,12 +20,12 @@
 *
 * For detailed instructions, see vectormath_common.h and vcl_manual.pdf
 *
-* (c) Copyright 2014-2020 Agner Fog.
+* (c) Copyright 2014-2022 Agner Fog.
 * Apache License version 2.0 or later.
 ******************************************************************************/
 
 #ifndef VECTORMATH_TRIG_H
-#define VECTORMATH_TRIG_H  1
+#define VECTORMATH_TRIG_H  202
 
 #include "vectormath_common.h"
 
@@ -39,8 +39,8 @@ namespace VCL_NAMESPACE {
 // *************************************************************
 // Template parameters:
 // VTYPE:  f.p. vector type
-// SC:     1 = sin, 2 = cos, 3 = sincos
-// Paramterers:
+// SC:     1 = sin, 2 = cos, 3 = sincos, 4 = tan, 8 = multiply by pi
+// Parameters:
 // xx = input x (radians)
 // cosret = return pointer (only if SC = 3)
 template<typename VTYPE, int SC>
@@ -64,35 +64,51 @@ static inline VTYPE sincos_d(VTYPE * cosret, VTYPE const xx) {
     const double DP1 = 7.853981554508209228515625E-1 * 2.;
     const double DP2 = 7.94662735614792836714E-9 * 2.;
     const double DP3 = 3.06161699786838294307E-17 * 2.;
-    /*
-    const double DP1sc = 7.85398125648498535156E-1;
-    const double DP2sc = 3.77489470793079817668E-8;
-    const double DP3sc = 2.69515142907905952645E-15;
-    */
+
     typedef decltype(roundi(xx)) ITYPE;          // integer vector type
-    typedef decltype(nan_code(xx)) UITYPE;       // unsigned integer vector type
+    //typedef decltype(nan_code(xx)) UITYPE;       // unsigned integer vector type
     typedef decltype(xx < xx) BVTYPE;            // boolean vector type
 
     VTYPE  xa, x, y, x2, s, c, sin1, cos1;       // data vectors
-    ITYPE  q, qq, signsin, signcos;              // integer vectors, 64 bit
+    ITYPE  q, signsin, signcos;                  // integer vectors, 64 bit
 
-    BVTYPE swap, overflow;                       // boolean vectors
+    BVTYPE swap;                                 // boolean vector
+
+#if INSTRSET < 8  // no FMA
+    const double input_limit = 1.E13;            // lower overflow limit without FMA
+#else
+    const double input_limit = 1.E15;
+#endif
 
     xa = abs(xx);
 
     // Find quadrant
-    y = round(xa * (double)(2. / VM_PI));        // quadrant, as float
+    if constexpr ((SC & 8) != 0) {
+        y = round(xa * 2.0);
+    }
+    else {
+        xa = select(xa > VTYPE(input_limit), VTYPE(0.f), xa); // overflow limit
+        y = round(xa * (double)(2. / VM_PI));    // quadrant, as float
+    }
     q = roundi(y);                               // quadrant, as integer
-    // Find quadrant
+    // Quadrant:
     //      0 -   pi/4 => 0
     //   pi/4 - 3*pi/4 => 1
     // 3*pi/4 - 5*pi/4 => 2
     // 5*pi/4 - 7*pi/4 => 3
     // 7*pi/4 - 8*pi/4 => 4
 
-    // Reduce by extended precision modular arithmetic
-    x = nmul_add(y, DP3, nmul_add(y, DP2, nmul_add(y, DP1, xa)));    // x = ((xa - y * DP1) - y * DP2) - y * DP3;
-
+    if constexpr ((SC & 8) != 0) {
+        x = nmul_add(y, 0.5, xa) * (VM_PI);
+    }
+    else {
+        // Reduce by extended precision modular arithmetic
+#if INSTRSET < 8  // no FMA
+        x = ((xa - y * DP1) - y * DP2) - y * DP3;
+#else
+        x = nmul_add(y, DP3, nmul_add(y, DP2 + DP1, xa));
+#endif
+    }
     // Expansion of sin and cos, valid for -pi/4 <= x <= pi/4
     x2 = x * x;
     s = polynomial_5(x2, P0sin, P1sin, P2sin, P3sin, P4sin, P5sin);
@@ -103,12 +119,6 @@ static inline VTYPE sincos_d(VTYPE * cosret, VTYPE const xx) {
     // swap sin and cos if odd quadrant
     swap = BVTYPE((q & 1) != 0);
 
-    // check for overflow
-    overflow = BVTYPE(UITYPE(q) > 0x80000000000000);  // q big if overflow
-    overflow &= is_finite(xa);
-    s = select(overflow, 0.0, s);
-    c = select(overflow, 1.0, c);
-
     if constexpr ((SC & 1) != 0) {  // calculate sin
         sin1 = select(swap, c, s);
         signsin = ((q << 62) ^ ITYPE(reinterpret_i(xx)));
@@ -119,7 +129,7 @@ static inline VTYPE sincos_d(VTYPE * cosret, VTYPE const xx) {
         signcos = ((q + 1) & 2) << 62;
         cos1 ^= reinterpret_d(signcos);
     }
-    if constexpr (SC == 3) {  // calculate both. cos returned through pointer
+    if constexpr ((SC & 7) == 3) {  // calculate both. cos returned through pointer
         *cosret = cos1;
     }
     if constexpr ((SC & 1) != 0) return sin1; else return cos1;
@@ -139,6 +149,19 @@ static inline Vec2d sincos(Vec2d * cosret, Vec2d const x) {
     return sincos_d<Vec2d, 3>(cosret, x);
 }
 
+static inline Vec2d sinpi(Vec2d const x) {
+    return sincos_d<Vec2d, 9>(0, x);
+}
+
+static inline Vec2d cospi(Vec2d const x) {
+    return sincos_d<Vec2d, 10>(0, x);
+}
+
+static inline Vec2d sincospi(Vec2d * cosret, Vec2d const x) {
+    return sincos_d<Vec2d, 11>(cosret, x);
+}
+
+
 #if MAX_VECTOR_SIZE >= 256
 static inline Vec4d sin(Vec4d const x) {
     return sincos_d<Vec4d, 1>(0, x);
@@ -151,6 +174,19 @@ static inline Vec4d cos(Vec4d const x) {
 static inline Vec4d sincos(Vec4d * cosret, Vec4d const x) {
     return sincos_d<Vec4d, 3>(cosret, x);
 }
+
+static inline Vec4d sinpi(Vec4d const x) {
+    return sincos_d<Vec4d, 9>(0, x);
+}
+
+static inline Vec4d cospi(Vec4d const x) {
+    return sincos_d<Vec4d, 10>(0, x);
+}
+
+static inline Vec4d sincospi(Vec4d * cosret, Vec4d const x) {
+    return sincos_d<Vec4d, 11>(cosret, x);
+}
+
 #endif // MAX_VECTOR_SIZE >= 256
 
 #if MAX_VECTOR_SIZE >= 512
@@ -165,6 +201,19 @@ static inline Vec8d cos(Vec8d const x) {
 static inline Vec8d sincos(Vec8d * cosret, Vec8d const x) {
     return sincos_d<Vec8d, 3>(cosret, x);
 }
+
+static inline Vec8d sinpi(Vec8d const x) {
+    return sincos_d<Vec8d, 9>(0, x);
+}
+
+static inline Vec8d cospi(Vec8d const x) {
+    return sincos_d<Vec8d, 10>(0, x);
+}
+
+static inline Vec8d sincospi(Vec8d * cosret, Vec8d const x) {
+    return sincos_d<Vec8d, 11>(cosret, x);
+}
+
 #endif // MAX_VECTOR_SIZE >= 512
 
 
@@ -173,12 +222,12 @@ static inline Vec8d sincos(Vec8d * cosret, Vec8d const x) {
 // *************************************************************
 // Template parameters:
 // VTYPE:  f.p. vector type
-// SC:     1 = sin, 2 = cos, 3 = sincos, 4 = tan
-// Paramterers:
+// SC:     1 = sin, 2 = cos, 3 = sincos, 4 = tan, 8 = multiply by pi
+// Parameters:
 // xx = input x (radians)
 // cosret = return pointer (only if SC = 3)
 template<typename VTYPE, int SC>
-static inline VTYPE sincos_f(VTYPE * cosret, VTYPE const xx) {
+static inline VTYPE sincos_f(VTYPE* cosret, VTYPE const xx) {
 
     // define constants
     const float DP1F = 0.78515625f * 2.f;
@@ -194,31 +243,48 @@ static inline VTYPE sincos_f(VTYPE * cosret, VTYPE const xx) {
     const float P2cosf = 2.443315711809948E-5f;
 
     typedef decltype(roundi(xx)) ITYPE;          // integer vector type
-    typedef decltype(nan_code(xx)) UITYPE;       // unsigned integer vector type
+    //typedef decltype(nan_code(xx)) UITYPE;       // unsigned integer vector type
     typedef decltype(xx < xx) BVTYPE;            // boolean vector type
+    
+#if INSTRSET < 8  // no FMA
+    const float input_limit = 1.E5f;             // lower overflow limit without FMA
+#else
+    const float input_limit = 1.E7f;
+#endif
 
     VTYPE  xa, x, y, x2, s, c, sin1, cos1;       // data vectors
     ITYPE  q, signsin, signcos;                  // integer vectors
-    BVTYPE swap, overflow;                       // boolean vectors
+    BVTYPE swap;                                 // boolean vector
 
     xa = abs(xx);
 
     // Find quadrant
-    y = round(xa * (float)(2. / VM_PI));         // quadrant, as float
+    if constexpr ((SC & 8) != 0) {
+        y = round(xa * 2.0f);
+    }
+    else {
+        xa = select(xa > VTYPE(input_limit), VTYPE(0.f), xa); // overflow limit
+        y = round(xa * (float)(2. / VM_PI));     // quadrant, as float
+    }
     q = roundi(y);                               // quadrant, as integer
+    // Quadrant:
     //      0 -   pi/4 => 0
     //   pi/4 - 3*pi/4 => 1
     // 3*pi/4 - 5*pi/4 => 2
     // 5*pi/4 - 7*pi/4 => 3
     // 7*pi/4 - 8*pi/4 => 4
 
-    // Reduce by extended precision modular arithmetic
-    // x = ((xa - y * DP1F) - y * DP2F) - y * DP3F;
-    x = nmul_add(y, DP3F, nmul_add(y, DP2F, nmul_add(y, DP1F, xa)));
-
-    // A two-step reduction saves time at the cost of precision for very big x:
-    //x = (xa - y * DP1F) - y * (DP2F+DP3F);
-
+    if constexpr ((SC & 8) != 0) {
+        x = nmul_add(y, 0.5f, xa)*float(VM_PI);
+    }
+    else {
+        // Reduce by extended precision modular arithmetic
+#if INSTRSET < 8  // no FMA
+        x = ((xa - y * DP1F) - y * DP2F) - y * DP3F;
+#else
+        x = nmul_add(y, DP3F, nmul_add(y, DP2F + DP1F, xa));
+#endif
+    }
     // Taylor expansion of sin and cos, valid for -pi/4 <= x <= pi/4
     x2 = x * x;
     s = polynomial_2(x2, P0sinf, P1sinf, P2sinf) * (x*x2) + x;
@@ -227,12 +293,6 @@ static inline VTYPE sincos_f(VTYPE * cosret, VTYPE const xx) {
     // swap sin and cos if odd quadrant
     swap = BVTYPE((q & 1) != 0);
 
-    // check for overflow
-    overflow = BVTYPE(UITYPE(q) > 0x2000000);  // q big if overflow
-    overflow &= is_finite(xa);
-    s = select(overflow, 0.0f, s);
-    c = select(overflow, 1.0f, c);
-
     if constexpr ((SC & 5) != 0) {  // calculate sin
         sin1 = select(swap, c, s);
         signsin = ((q << 30) ^ ITYPE(reinterpret_i(xx)));
@@ -243,13 +303,18 @@ static inline VTYPE sincos_f(VTYPE * cosret, VTYPE const xx) {
         signcos = ((q + 1) & 2) << 30;
         cos1 ^= reinterpret_f(signcos);
     }
-    if constexpr (SC == 1) return sin1;
-    else if constexpr (SC == 2) return cos1;
-    else if constexpr (SC == 3) {  // calculate both. cos returned through pointer
+    if constexpr ((SC & 7) == 1) return sin1;
+    else if constexpr ((SC & 7) == 2) return cos1;
+    else if constexpr ((SC & 7) == 3) {  // calculate both. cos returned through pointer
         *cosret = cos1;
         return sin1;
     }
     else {  // SC == 4. tan
+        if constexpr (SC == 12) {
+            // tanpi can give INF result, tan cannot. Get the right sign of INF result according to IEEE 754-2019
+            cos1 = select(cos1 == 0.f, 0.f, cos1); // remove sign of 0
+            // the sign of zero output is arbitrary. fixing it would be a waste of code
+        }
         return sin1 / cos1;
     }
 }
@@ -272,6 +337,22 @@ static inline Vec4f tan(Vec4f const x) {
     return sincos_f<Vec4f, 4>(0, x);
 }
 
+static inline Vec4f sinpi(Vec4f const x) {
+    return sincos_f<Vec4f, 9>(0, x);
+}
+
+static inline Vec4f cospi(Vec4f const x) {
+    return sincos_f<Vec4f, 10>(0, x);
+}
+
+static inline Vec4f sincospi(Vec4f * cosret, Vec4f const x) {
+    return sincos_f<Vec4f, 11>(cosret, x);
+}
+
+static inline Vec4f tanpi(Vec4f const x) {
+    return sincos_f<Vec4f, 12>(0, x);
+}
+
 #if MAX_VECTOR_SIZE >= 256
 static inline Vec8f sin(Vec8f const x) {
     return sincos_f<Vec8f, 1>(0, x);
@@ -287,7 +368,24 @@ static inline Vec8f sincos(Vec8f * cosret, Vec8f const x) {
 
 static inline Vec8f tan(Vec8f const x) {
     return sincos_f<Vec8f, 4>(0, x);
+} 
+
+static inline Vec8f sinpi(Vec8f const x) {
+    return sincos_f<Vec8f, 9>(0, x);
+}
+
+static inline Vec8f cospi(Vec8f const x) {
+    return sincos_f<Vec8f, 10>(0, x);
 }
+
+static inline Vec8f sincospi(Vec8f * cosret, Vec8f const x) {
+    return sincos_f<Vec8f, 11>(cosret, x);
+}
+
+static inline Vec8f tanpi(Vec8f const x) {
+    return sincos_f<Vec8f, 12>(0, x);
+}
+
 #endif // MAX_VECTOR_SIZE >= 256
 
 #if MAX_VECTOR_SIZE >= 512
@@ -306,6 +404,23 @@ static inline Vec16f sincos(Vec16f * cosret, Vec16f const x) {
 static inline Vec16f tan(Vec16f const x) {
     return sincos_f<Vec16f, 4>(0, x);
 }
+
+static inline Vec16f sinpi(Vec16f const x) {
+    return sincos_f<Vec16f, 9>(0, x);
+}
+
+static inline Vec16f cospi(Vec16f const x) {
+    return sincos_f<Vec16f, 10>(0, x);
+}
+
+static inline Vec16f sincospi(Vec16f * cosret, Vec16f const x) {
+    return sincos_f<Vec16f, 11>(cosret, x);
+}
+
+static inline Vec16f tanpi(Vec16f const x) {
+    return sincos_f<Vec16f, 12>(0, x);
+}
+
 #endif // MAX_VECTOR_SIZE >= 512
 
 
@@ -314,15 +429,17 @@ static inline Vec16f tan(Vec16f const x) {
 // *************************************************************
 // Template parameters:
 // VTYPE:  f.p. vector type
-// Paramterers:
+// Template parameters:
+// SC:  0 = tan, 8 = multiply by pi
+// Parameters:
 // x = input x (radians)
-template<typename VTYPE>
+template<typename VTYPE, int SC>
 static inline VTYPE tan_d(VTYPE const x) {
 
     // define constants
-    const double DP1 = 7.853981554508209228515625E-1 * 2.;;
-    const double DP2 = 7.94662735614792836714E-9 * 2.;;
-    const double DP3 = 3.06161699786838294307E-17 * 2.;;
+    const double DP1 = 7.853981554508209228515625E-1 * 2.;
+    const double DP2 = 7.94662735614792836714E-9 * 2.;
+    const double DP3 = 3.06161699786838294307E-17 * 2.;
 
     const double P2tan = -1.30936939181383777646E4;
     const double P1tan = 1.15351664838587416140E6;
@@ -335,27 +452,39 @@ static inline VTYPE tan_d(VTYPE const x) {
 
     typedef decltype(x > x) BVTYPE;         // boolean vector type
     VTYPE  xa, y, z, zz, px, qx, tn, recip; // data vectors
-    BVTYPE doinvert, xzero, overflow;       // boolean vectors
+    BVTYPE doinvert;                        // boolean vector
     typedef decltype(nan_code(x)) UITYPE;   // unsigned integer vector type
 
-
     xa = abs(x);
 
     // Find quadrant
-    y = round(xa * (double)(2. / VM_PI));   // quadrant, as float
-    auto q = roundi(y);                     // quadrant, as integer
-    // Find quadrant
+    if constexpr ((SC & 8) != 0) {
+        y = round(xa * 2.0);
+    }
+    else {
+        xa = select(xa > VTYPE(1.E15), VTYPE(0.), xa); // overflow limit
+        y = round(xa * (double)(2. / VM_PI));    // quadrant, as float
+    }
+    auto q = roundi(y);                          // quadrant, as integer
+    // Quadrant:
     //      0 -   pi/4 => 0
     //   pi/4 - 3*pi/4 => 1
     // 3*pi/4 - 5*pi/4 => 2
     // 5*pi/4 - 7*pi/4 => 3
     // 7*pi/4 - 8*pi/4 => 4
 
-    // Reduce by extended precision modular arithmetic
-    // z = ((xa - y * DP1) - y * DP2) - y * DP3;
-    z = nmul_add(y, DP3, nmul_add(y, DP2, nmul_add(y, DP1, xa)));
-
-    // Pade expansion of tan, valid for -pi/4 <= x <= pi/4
+    if constexpr ((SC & 8) != 0) {
+        z = nmul_add(y, 0.5, xa) * (VM_PI);
+    }
+    else {
+        // Reduce by extended precision modular arithmetic
+#if INSTRSET < 8  // no FMA
+        z = ((xa - y * DP1) - y * DP2) - y * DP3;
+#else
+        z = nmul_add(y, DP3, nmul_add(y, DP2 + DP1, xa));
+#endif
+    }
+    // Pade approximation of tan, valid for -pi/4 <= x <= pi/4
     zz = z * z;
     px = polynomial_2(zz, P0tan, P1tan, P2tan);
     qx = polynomial_4n(zz, Q0tan, Q1tan, Q2tan, Q3tan);
@@ -365,35 +494,48 @@ static inline VTYPE tan_d(VTYPE const x) {
 
     // if (q&2) tn = -1/tn
     doinvert = BVTYPE((q & 1) != 0);
-    xzero = (xa == 0.);
-    // avoid division by 0. We will not be using recip anyway if xa == 0.
-    // tn never becomes exactly 0 when x = pi/2 so we only have to make
-    // a special case for x == 0.
-    recip = (-1.) / select(xzero, VTYPE(-1.), tn);
-    tn = select(doinvert, recip, tn);
-    tn = sign_combine(tn, x);       // get original sign
-
-    overflow = BVTYPE(UITYPE(q) > 0x80000000000000) & is_finite(xa);
-    tn = select(overflow, 0., tn);
 
+    if constexpr ((SC & 8) != 0) {
+        // tan cannot give infinity because the input cannot be exactly pi/2.
+        // tanpi can generate infinity. Get the right sign of infinity:
+        UITYPE infsign = UITYPE(q) << 62;   // get bit 1 into the sign bit position
+        VTYPE  zsign = sign_combine(VTYPE(-0.), reinterpret_d(infsign));
+        tn = select(tn == 0., zsign, tn);   // get INF with the right sign when tn == 0
+        // the sign of zero output is arbitrary. fixing it would be a waste of code
+    }
+    recip = -1. / tn;
+    tn = select(doinvert, recip, tn);
+    tn = sign_combine(tn, x);       // combine with original sign of x
     return tn;
 }
 
 // instantiations of tan_d template:
 
 static inline Vec2d tan(Vec2d const x) {
-    return tan_d(x);
+    return tan_d<Vec2d, 0>(x);
+}
+
+static inline Vec2d tanpi(Vec2d const x) {
+    return tan_d<Vec2d, 8>(x);
 }
 
 #if MAX_VECTOR_SIZE >= 256
 static inline Vec4d tan(Vec4d const x) {
-    return tan_d(x);
+    return tan_d<Vec4d, 0>(x);
+}
+
+static inline Vec4d tanpi(Vec4d const x) {
+    return tan_d<Vec4d, 8>(x);
 }
 #endif // MAX_VECTOR_SIZE >= 256
 
 #if MAX_VECTOR_SIZE >= 512
 static inline Vec8d tan(Vec8d const x) {
-    return tan_d(x);
+    return tan_d<Vec8d, 0>(x);
+}
+
+static inline Vec8d tanpi(Vec8d const x) {
+    return tan_d<Vec8d, 8>(x);
 }
 #endif // MAX_VECTOR_SIZE >= 512
 
@@ -412,7 +554,7 @@ static inline Vec8d tan(Vec8d const x) {
 // Template parameters:
 // VTYPE:  f.p. vector type
 // AC: 0 = asin, 1 = acos
-// Paramterers:
+// Parameters:
 // x = input x
 template<typename VTYPE, int AC>
 static inline VTYPE asin_d(VTYPE const x) {
@@ -442,7 +584,7 @@ static inline VTYPE asin_d(VTYPE const x) {
     const double Q1asin = 1.395105614657485689735E2;
     const double Q0asin = -4.918853881490881290097E1;
 
-    VTYPE  xa, xb, x1, x2, x3, x4, x5, px, qx, rx, sx, vx, wx, y1, yb, z, z1, z2;
+    VTYPE  xa, xb, x1, x2, x3, x4, x5, px, qx, rx, sx, vx, wx, y1, z, z1, z2;
     bool   dobig, dosmall;
 
     xa = abs(x);
@@ -560,7 +702,7 @@ static inline Vec8d acos(Vec8d const x) {
 // Template parameters:
 // VTYPE:  f.p. vector type
 // AC: 0 = asin, 1 = acos
-// Paramterers:
+// Parameters:
 // x = input x
 template<typename VTYPE, int AC>
 static inline VTYPE asin_f(VTYPE const x) {
@@ -641,7 +783,7 @@ static inline Vec16f acos(Vec16f const x) {
 // Template parameters:
 // VTYPE:  f.p. vector type
 // T2:     0 = atan, 1 = atan2
-// Paramterers:
+// Parameters:
 // y, x. calculate tan(y/x)
 // result is between -pi/2 and +pi/2 when x > 0
 // result is between -pi and -pi/2 or between pi/2 and pi when x < 0 for atan2
@@ -771,7 +913,7 @@ static inline Vec8d atan(Vec8d const y) {
 // Template parameters:
 // VTYPE:  f.p. vector type
 // T2:     0 = atan, 1 = atan2
-// Paramterers:
+// Parameters:
 // y, x. calculate tan(y/x)
 // result is between -pi/2 and +pi/2 when x > 0
 // result is between -pi and -pi/2 or between pi/2 and pi when x < 0 for atan2
diff --git a/meson.build b/meson.build
index 0075f70..b06dbd8 100644
--- a/meson.build
+++ b/meson.build
@@ -12,7 +12,7 @@ sources = [
 vapoursynth_dep = dependency('vapoursynth').partial_dependency(compile_args: true, includes: true)
 
 libs = []
-
+add_project_arguments('-O3', language: 'cpp')
 if host_machine.cpu_family().startswith('x86')
   add_project_arguments('-fno-math-errno', '-fno-trapping-math', '-DLGHOST_X86', '-mfpmath=sse', '-msse2', language: 'cpp')
 
@@ -52,8 +52,25 @@ if host_machine.cpu_family().startswith('x86')
     cpp_args: ['-mavx512f', '-mavx512vl', '-mavx512bw', '-mavx512dq', '-mfma'],
     gnu_symbol_visibility: 'hidden'
   )
-endif
 
+elif host_machine.cpu_family().startswith('arm') or host_machine.cpu_family() == 'aarch64'
+  project_args = ['-O3', '-funroll-loops', '-fno-math-errno', '-fno-trapping-math']
+  sources += [
+    'LGhost/LGhost_SSE2.cpp',
+    'LGhost/VCL2/instrset.h',
+    'LGhost/VCL2/instrset_detect.cpp',
+    'LGhost/VCL2/vector_convert.h',
+    'LGhost/VCL2/vectorclass.h',
+    'LGhost/VCL2/vectorf128.h',
+    'LGhost/VCL2/vectori128.h',
+    'LGhost/VCL2/vectormath_common.h',
+    'LGhost/VCL2/vectormath_exp.h',
+    'LGhost/VCL2/vectormath_hyp.h',
+    'LGhost/VCL2/vectormath_lib.h',
+    'LGhost/VCL2/vectormath_trig.h'
+  ]
+  add_project_arguments(project_args, language: 'cpp')
+endif
 shared_module('lghost', sources,
   dependencies: vapoursynth_dep,
   link_with: libs,
